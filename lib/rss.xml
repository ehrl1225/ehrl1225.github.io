<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[프로그래머스 수업]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>프로그래머스 수업</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 06 Jul 2025 23:35:26 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 06 Jul 2025 23:35:00 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[디버깅]]></title><description><![CDATA[ 
 <br><br>오류를 수정하는 것<br>
정확히는 의도와 다르게 작동하는 것을 의도와 맞게 작동되게 만드는 것<br>
실제로 옛날에 컴퓨터에 벌레가 들어가 오류를 발생시킨 것을 벌레를 빼면서 오류를 수정한 적 있는데<br>
이 이후로 오류를 수정하는 것을 디버깅이라고 부르게 되었다고 한다.<br>
요즘은 발달 해서 코딩 툴 그러니까 <a data-href="IDE" href="컴퓨터 공학\프로그램\IDE\IDE.html" class="internal-link" target="_self" rel="noopener nofollow">IDE</a>에서도 디버깅을 도와준다.<br><br>프로그래밍을 0과 1로 할 수는 없으니까 그것 보다는 사람에게 친숙한 언어를 만들었고<br>
그걸 컴퓨터에게 친숙한 0과 1로 변환시켜주는 방식을 채택했음<br>
그래서 사람에게 친숙한 언어를 컴퓨터에게 친숙한 언어로 변환시켜주는 녀석이 컴파일러임<br>
컴파일러는 기계어 또는 바이트 코드를 생성함<br>인터프리터는 코드를 한줄 한줄 번역해서 실행한다.<br><br>개발자가 작성한 코드, 다른 곳에서 작성한 코드 즉 라이브러리, 이미지나 기타 파일들을 보통은 하나의 파일로 압축하여 만드는게 빌드다.<br>
한 파일로 묶이지 않고 적은 수의 파일로 정리되기도 한다.<br><br>빌드한 프로그램을 사용자에게 전달하는 것이다.<br>
업데이트 하면 새 버전을 배포한 것<br><br>컴퓨터 마다 지정된 값<br>
보통 설정하는건 PATH 값<br>
컴퓨터가 달라도 같은 프로그램을 가리키게 PATH값을 정할 수 있음<br>
값에 따라 다른 동작을 시킬 수 도 있음<br>
비밀번호를 저장해서 보안을 지킬 수 있음<br><br>내가 제어함<br>
필요하면 가져올 수 있음<br><br>프레임워크가 제어함<br>
세부사항을 내가 작성하는 것일 뿐]]></description><link>기타\개발용어.html</link><guid isPermaLink="false">기타/개발용어.md</guid><pubDate>Wed, 02 Jul 2025 07:56:30 GMT</pubDate></item><item><title><![CDATA[한영 변환]]></title><description><![CDATA[ 
 <br><br>Caps Lock<br>
control + Space bar<br><br>선택후 option<br><br>cmd + control + space bar<br><br>cmd + Tab 오른쪽 방향<br>
~ 추가하면 왼쪽 방향<br><br>cmd + option + esc<br><br>cmd + delete<br><br>cmd + shift + delete<br><br>return<br><br>cmd + M<br><br>cmd + option + space bar<br><br><br>cmd + 위 아래<br><br>cmd + f<br><br>cmd + T<br><br>control + tab<br><br>cmd + 클릭<br><br>cmd + w<br><br>cmd + shift + T<br><br>cmd + shift + 3<br><br>cmd + shift + 4<br><br>cmd + shift + 4 + space bar<br><br>cmd + shift + 4 + space bar + option<br><br>cmd + shift + 5<br><br>cmd + shift + 4 + control]]></description><link>기타\맥 단축키.html</link><guid isPermaLink="false">기타/맥 단축키.md</guid><pubDate>Wed, 04 Jun 2025 14:13:22 GMT</pubDate></item><item><title><![CDATA[현재 창 닫기]]></title><description><![CDATA[ 
 <br><br><br><br>f2<br><br>win + e<br><br>win + ← or →<br><br>win + ↑ or ↓<br><br>win + D<br><br>ctrl + win + D<br><br>ctrl + win + ← or →<br><br>win + tab<br><br>ctrl + win + f4<br><br>win + 숫자키 1~0<br><br>win + shift + 숫자키<br><br>win + T<br><br>shift + ctrl + ← or →<br><br>shift + home or end<br><br>win + I<br><br>win + L<br><br>ctrl + L<br><br>shift + enter<br><br>ctrl + 마우스 휠 위 아래<br><br>ctrl + 0<br><br>win + shift + S<br><br>Power Toys를 설치해야함<br>
ctrl + win + T]]></description><link>기타\윈도우 단축키.html</link><guid isPermaLink="false">기타/윈도우 단축키.md</guid><pubDate>Sun, 01 Jun 2025 23:55:24 GMT</pubDate></item><item><title><![CDATA[웹 표준]]></title><description><![CDATA[ 
 <br><br><a data-href="웹 브라우저" href="컴퓨터 공학\프로그램\웹 브라우저.html" class="internal-link" target="_self" rel="noopener nofollow">웹 브라우저</a>가 여러개라서 웹 표준이 생김<br>
<a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>과 <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>의 표준을 정하는 W3C<br>
<a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>를 관장하는 ECMA<br>
이를 웹 표준이라고 부름<br><br>웹 표준을 따르지 않음<br>
성능이 안좋음<br>어느 사용자는 익스플로러를 쓰기 때문에 익스플로러도 지원해야함<br>각 기능이 어느 버전까지 지원하는지 확인을 해야함<br><br>다른 웹 브라우저에서 돌아가는지 확인하는데 사용한다.]]></description><link>기타\익스플로러를 싫어하는 이유.html</link><guid isPermaLink="false">기타/익스플로러를 싫어하는 이유.md</guid><pubDate>Tue, 17 Jun 2025 15:09:51 GMT</pubDate></item><item><title><![CDATA[재귀함수]]></title><description><![CDATA[ 
 <br>함수에서 스스로를 호출하는 방법으로 동적 계획법 알고리즘에 사용된다.]]></description><link>컴퓨터 공학\수학\이산수학\재귀함수.html</link><guid isPermaLink="false">컴퓨터 공학/수학/이산수학/재귀함수.md</guid><pubDate>Thu, 03 Jul 2025 07:32:59 GMT</pubDate></item><item><title><![CDATA[선형대수학]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\수학\선형대수학.html</link><guid isPermaLink="false">컴퓨터 공학/수학/선형대수학.md</guid><pubDate>Mon, 30 Jun 2025 07:47:43 GMT</pubDate></item><item><title><![CDATA[카오스 이론]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\수학\카오스 이론.html</link><guid isPermaLink="false">컴퓨터 공학/수학/카오스 이론.md</guid><pubDate>Mon, 30 Jun 2025 07:47:22 GMT</pubDate></item><item><title><![CDATA[맥북에서 Docker 설치시 주의 사항]]></title><description><![CDATA[ 
 <br>맥북은 <a data-href="ARM" href="컴퓨터 공학\컴퓨터 구조\CPU\아키텍쳐\ARM.html" class="internal-link" target="_self" rel="noopener nofollow">ARM</a>아키텍쳐를 가지고 있기에 docker 설치시에 ARM 버전으로 설치해야한다.<br>
기본적으로는 <a data-href="x86" href="컴퓨터 공학\컴퓨터 구조\CPU\아키텍쳐\x86.html" class="internal-link" target="_self" rel="noopener nofollow">x86</a>아키텍쳐로 설치하기 때문에 에뮬레이터를 통해 x86으로 만들어진 명령어를 실행한다.]]></description><link>컴퓨터 공학\운영체제\가상화\docker\맥북에서 Docker 설치시 주의 사항.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/docker/맥북에서 Docker 설치시 주의 사항.md</guid><pubDate>Sun, 06 Jul 2025 12:41:42 GMT</pubDate></item><item><title><![CDATA[Docker]]></title><description><![CDATA[ 
 <br>개발된 환경을 이미지로 저장하고<br>
이미지를 DockerHub에 올릴 수 있고<br>
이미지 여러 개를 함께 연결 되어서 동작하게 설정된 상태를 명령어 텍스트나 문서 형태로 저장이 가능하다.<br>
이 환경을 컨테이너라는 독립된 공간에 저장한다.<br>
가상 머신은 물리적 자원을 지정해서 분할해 사용해서 성능에 한계가 있는데<br>
도커는 실행 환경만 독립적으로 돌려서 자원의 제한으로 부터 자유롭다.<br>Dockerfile에서 실행될 스크립트를 작성할 수 있다.<br>Container Engine을 통해서 Container를 돌리고<br>
운영체제를 돌리지 않기에 가볍다.<br><br>
<br>어떤 파일을 사용할 지
<br>어떤 라이브러리를 설치해야 하는지
<br>어떤 환경 변수를 설정해야하는지
<br>어떻게 실행해야하는지 스크립트<br>
를 설정할 수 있다.
<br><br>어플리케이션을 실행하는데 필요한 코드, 설정, 에셋, 라이브러리를 포함한 것으로<br>
스냅샷이라고 보면 된다.<br>
수정은 불가능하다.<br><br>이미지를 독립된 공간에서 실행시킬 수 있는 것을 의미한다.<br>
Container에서는 수정이 가능하다.<br><br>Container Registry에 Push를 하면 다른 컴퓨터가 PULL 해서 받아 올 수 있다.<br><br>
<br>docker hub
<br>red hat quay.io
<br>github packages
<br><br>
<br>aws
<br>google cloud
<br>microsoft azure
<br><br>예시로<br>docker build -f Dockerfile -t fun-docker .
<br>이걸로 현재 위치의 Dockerfile을 읽어서 fun-docker라는 이름으로 빌드하는 것이다.]]></description><link>컴퓨터 공학\운영체제\가상화\docker\Docker.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/docker/Docker.md</guid><pubDate>Wed, 25 Jun 2025 07:44:13 GMT</pubDate></item><item><title><![CDATA[Dockerfile]]></title><description><![CDATA[ 
 <br>FROM을 통해 베이스 이미지를 정할수 있고<br>
WORKDIR을 통해 어느 디렉토리에 어플리케이션을 복사할지 정할 수 있다.<br>COPY 를 통해 패키지 매니징 파일을 복사하고<br>패키지 매니징 파일을 실행하고<br>COPY를 통해 코드를 복사하고<br>ENTRYPOINT를 통해 어떻게 실행할지에 대해서 작성할 수 있다.<br>위에서부터 아래까지 레이어로 되어있고<br>자주 변경되는 레이어면 밑에 둬서 밑의 부분만 변경할 수 있게 하는게 좋다.]]></description><link>컴퓨터 공학\운영체제\가상화\docker\Dockerfile.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/docker/Dockerfile.md</guid><pubDate>Wed, 25 Jun 2025 07:42:42 GMT</pubDate></item><item><title><![CDATA[WSL2에 mariaDB]]></title><description><![CDATA[ 
 <br>일단 최신화를 해야하고<br>sudo apt update -y
sudo apt upgrade -y
<br>필수 패키지 설치하고<br>sudo apt install -y apt-transport-https ca-certificates curl software-properties-common
<br>Docker GPG키 &amp; 저장소 추가<br>curl -fsSL &lt;https://download.docker.com/linux/ubuntu/gpg&gt; | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] &lt;https://download.docker.com/linux/ubuntu&gt; $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
<br>Docker 패키지 목록 업데이트 하고<br>sudo apt update -y
<br>docker를 설치한다.<br>sudo apt install -y docker-ce docker-ce-cli containerd.io
<br>User 계정에 Docker 권한을 추가하고<br>sudo usermod -aG docker $USER
<br>Docker를 실행시키면 된다.<br>sudo service docker start
<br>docker pull mariadb:latest
<br>로 최신 버전 MariaDB를 설치할 수 있고<br>docker run --name mariadb -p 3306:3306 -e MYSQL_ROOT_PASSWORD=pw_mariadb -d mariadb:latest
<br>로 MariaDB가 설치된 도커 컨테이너가 생성된다.<br>echo "docker start mariadb" &gt; start
chmod +x start
echo "docker exec -it mariadb /bin/bash" &gt; connect
chmod +x connect
echo "docker stop mariadb" &gt; stop
chmod +x stop
<br>대충 이걸로 mariadb 컨테이너를 실행시키거나 접속하거나 정지시키거나 하는 파일을 만들었다.<br>WSL2 도 VM이고 docker은 WSL2 안에 있으니까 VM 안에 있는 VM인데 호스트 컴퓨터인 windows에서 WSL2 안에 있는 docker의 mariadb에 연결되는 걸 보면 신기하다.<br>wsl2에 mariaDB를 설치한 Docker를 실행시키고<br>
윈도우에서 3306 포트로 접속을 하니까 접속이 되었음]]></description><link>컴퓨터 공학\운영체제\가상화\docker\WSL2에 mariaDB.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/docker/WSL2에 mariaDB.md</guid><pubDate>Fri, 30 May 2025 01:42:19 GMT</pubDate></item><item><title><![CDATA[가상머신]]></title><description><![CDATA[ 
 <br>호스트 컴퓨터의 자원을 나눠서 가상으로 운영체제를 돌리는 방식으로<br>
운영체제를 포함시켜 동작하기 때문에 무겁다.]]></description><link>컴퓨터 공학\운영체제\가상화\VM\가상머신.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/VM/가상머신.md</guid><pubDate>Wed, 25 Jun 2025 07:27:03 GMT</pubDate></item><item><title><![CDATA[설치]]></title><description><![CDATA[ 
 <br><a data-href="가상머신" href="컴퓨터 공학\운영체제\가상화\VM\가상머신.html" class="internal-link" target="_self" rel="noopener nofollow">가상머신</a>을 돌릴 때 쓰는 프로그램이다.<br>ISO파일을 CD로 생각하면 좋다.<br>
요즘은 대부분 대신 해주는 경우가 있긴 한데<br>
문제가 발생하면 이 방법을 시도해보도록 하면 된다.<br><br>ISO 파일을 인터넷이나 어느 곳에서 다운받는다.<br>
그리고 virtualbox에 새로 만들기를 눌러 가상 머신의 이름과 ISO 파일을 넣는다.<br>
메모리와 프로세서를 할당한 후<br>
가상 하드 디스크도 할당하고 ]]></description><link>컴퓨터 공학\운영체제\가상화\VM\VirtualBox.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/VM/VirtualBox.md</guid><pubDate>Wed, 02 Jul 2025 08:33:03 GMT</pubDate></item><item><title><![CDATA[VMware]]></title><description><![CDATA[ 
 <br><a data-href="가상머신" href="컴퓨터 공학\운영체제\가상화\VM\가상머신.html" class="internal-link" target="_self" rel="noopener nofollow">가상머신</a>을 돌릴 때 쓰는 프로그램이다.<br>설치를 대신 해주기도 한다.]]></description><link>컴퓨터 공학\운영체제\가상화\VM\VMware.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/VM/VMware.md</guid><pubDate>Wed, 02 Jul 2025 08:33:21 GMT</pubDate></item><item><title><![CDATA[<a data-href="가상머신" href="컴퓨터 공학/운영체제/가상화/VM/가상머신.html" class="internal-link" target="_self" rel="noopener nofollow">가상머신</a>과 <a data-href="Docker" href="컴퓨터 공학/운영체제/가상화/docker/Docker.html" class="internal-link" target="_self" rel="noopener nofollow">Docker</a>의 차이]]></title><description><![CDATA[ 
 <br><br>가상머신은 사용할 환경의 크기를 미리 지정하고 돌리는 반면<br>
Docker는 사용할 환경의 크기를 정하지 않고 돌린다.]]></description><link>컴퓨터 공학\운영체제\가상화\가상화.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/가상화/가상화.md</guid><pubDate>Mon, 23 Jun 2025 08:25:12 GMT</pubDate></item><item><title><![CDATA[컴퓨터 구조]]></title><description><![CDATA[ 
 <br><a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a> 전체가 메모리에 올라오지 않더라도 실행 가능하도록 하는 기법<br><br>레지스터에 저장하기엔 가격이 비싸고 용량도 작아서<br>
이를 해결하기 위해 물리 <a data-href="메모리" href="컴퓨터 공학\운영체제\메모리\메모리.html" class="internal-link" target="_self" rel="noopener nofollow">메모리</a>에서 데이터를 가져와서 해결한다.<br><br><a data-href="프로그램" href="컴퓨터 공학\운영체제\프로그램.html" class="internal-link" target="_self" rel="noopener nofollow">프로그램</a>을 실행하면 fort()를 통해 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>를 생성하고<br>
exec()으로 로더를 호출한다.<br>
로더는 새로 생성된 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>의 주소공간을 이용해 이진실행파일을 <a data-href="메모리" href="컴퓨터 공학\운영체제\메모리\메모리.html" class="internal-link" target="_self" rel="noopener nofollow">메모리</a>에 올린다.<br><a data-href="컴퓨터 공학/컴퓨터 구조/CPU/CPU" href="컴퓨터 공학\컴퓨터 구조\CPU\CPU.html" class="internal-link" target="_self" rel="noopener nofollow">컴퓨터 공학/컴퓨터 구조/CPU/CPU</a>는 0번 부터 시작하는 독자적인 주소공간을 생성한다.<br>
이 주소를 논리 주소라고 한다.<br>운영체제로부터 논리 주소를 물리주소로 매핑시키는데 이걸 주소 바인딩이라고 함<br>MMU를 통해 논리적 주소를 넣으면 물리적 주소로 연결되게 한다.<br><br><a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>가 여러 개면 메모리가 부족할 수 있는데<br>
보조 메모리의 영역도 활용해서 메모리 공간으로 활용하는 개념이다.<br><br>자주 안쓰이는 페이지는 SWAP 영역에 두고 자주 사용되는 페이지만 물리 메모리에 저장하는 방식으로<br>
Swapping을 자주 하면 IO에 사용하는 시간이 늘어나면서 느려진다.<br>
RAM보다 SSD가 더 빠를 수는 없는거니까]]></description><link>컴퓨터 공학\운영체제\메모리\가상 메모리.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/메모리/가상 메모리.md</guid><pubDate>Thu, 03 Jul 2025 08:19:21 GMT</pubDate></item><item><title><![CDATA[메모리]]></title><description><![CDATA[ 
 <br><a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>가 <a data-href="컴퓨터 공학/컴퓨터 구조/CPU/CPU" href="컴퓨터 공학\컴퓨터 구조\CPU\CPU.html" class="internal-link" target="_self" rel="noopener nofollow">컴퓨터 공학/컴퓨터 구조/CPU/CPU</a>에서 실행되기 위해 대기하는 곳이다.]]></description><link>컴퓨터 공학\운영체제\메모리\메모리.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/메모리/메모리.md</guid><pubDate>Thu, 03 Jul 2025 08:19:21 GMT</pubDate></item><item><title><![CDATA[리틀 엔디안]]></title><description><![CDATA[ 
 <br><br>최하위 바이트부터 차례로 저장하는 방식<br>
평소 우리가 숫자를 사용하는 선형 방식돠 반대로 거꾸로 읽어야함<br>
보통 리눅스가 리틀 엔디안 방식이다.<br><br>최상위 바이트부터 차례로 저장하는 방식<br>
보통 윈도우가 빅 엔디안 방식이다.<br><br>그래서 네트워크 통신할 때 위의 정렬 중 하나의 바이트 정렬로 맞추고 주고 받는다.]]></description><link>컴퓨터 공학\운영체제\메모리\바이트 정렬.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/메모리/바이트 정렬.md</guid><pubDate>Mon, 09 Jun 2025 07:38:54 GMT</pubDate></item><item><title><![CDATA[Swap 메모리]]></title><description><![CDATA[ 
 <br>메모리가 부족해서 보조 저장 장치에서 일부를 메모리로 사용하는 것을 말한다.]]></description><link>컴퓨터 공학\운영체제\메모리\Swap 메모리.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/메모리/Swap 메모리.md</guid><pubDate>Wed, 02 Jul 2025 08:35:20 GMT</pubDate></item><item><title><![CDATA[CentOS]]></title><description><![CDATA[ 
 <br><br>]]></description><link>컴퓨터 공학\운영체제\종류\리눅스\분류\페도라.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/리눅스/분류/페도라.md</guid><pubDate>Tue, 01 Jul 2025 00:43:02 GMT</pubDate></item><item><title><![CDATA[Android]]></title><description><![CDATA[ 
 <br><a data-href="리눅스" href="컴퓨터 공학\운영체제\종류\리눅스\리눅스.html" class="internal-link" target="_self" rel="noopener nofollow">리눅스</a>를 일반 스마트폰 사용자들이 사용할 수 있게 모바일 OS로 개조한 것이다.<br>관리자 권한이 막혀있다.<br>
관리자 권한을 얻는 것을 루팅이라고 한다.<br>
루팅을 할 경우 보안기능이 제한되면서 은행업무를 볼 수 없게 된다.<br>
한번 루팅하면 물리적으로 고장내는 기능이 있어서 루팅을 할 생각이 있다면<br>
공기계로 하는 것을 추천한다.]]></description><link>컴퓨터 공학\운영체제\종류\리눅스\분류\Android.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/리눅스/분류/Android.md</guid><pubDate>Tue, 01 Jul 2025 07:34:11 GMT</pubDate></item><item><title><![CDATA[라즈베리파이 OS]]></title><description><![CDATA[ 
 <br><br>]]></description><link>컴퓨터 공학\운영체제\종류\리눅스\분류\Debian.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/리눅스/분류/Debian.md</guid><pubDate>Tue, 01 Jul 2025 00:44:05 GMT</pubDate></item><item><title><![CDATA[리눅스 커널]]></title><description><![CDATA[ 
 <br><a data-href="오픈소스" href="컴퓨터 공학\프로그래밍\오픈소스.html" class="internal-link" target="_self" rel="noopener nofollow">오픈소스</a>운영체제다.<br><br>하드웨어들을 직접 관리해서 응용 프로그램에서는 커널을 통해 쉽게 사용한다.<br><br>커널을 제외한 것들<br><br>최상위 폴더는 /이다.<br><br>리눅스 쉘을 통해 운영체제와 상호작용할 수 있다.<br><br>Epoll을 사용한다.]]></description><link>컴퓨터 공학\운영체제\종류\리눅스\리눅스.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/리눅스/리눅스.md</guid><pubDate>Tue, 01 Jul 2025 00:46:45 GMT</pubDate></item><item><title><![CDATA[touch {file name}]]></title><description><![CDATA[ 
 <br><br>비어있는 파일을 만들기 위함이다.<br><br>폴더의 파일들의 이름을 보기 위함이다.<br>
간단하게 두 개의 매개변수를 설명하고자 한다.<br>
directory name을 비우면 기본적으로 .이 들어간다.<br>
.은 현재 폴더를 말하고<br>
..은 상위 폴더를 말한다.<br>
~은 사용자의 폴더를 의미한다.<br><br>좀 더 자세하게 표시한다.<br><br>숨겨진 파일도 표시한다.<br>
보통은 앞에 .이 붙은 폴더들이 숨겨져 있는데 이 폴더도 발견한다.<br><br>폴더를 이동할 때 사용한다.<br>
위에서 말했든 .은 현재 폴더고 ..은 상위 폴더이다.<br>
~은 사용자의 폴더를 의미한다.<br>
directory name을 비우면 기본적으로 ~가 들어간다.<br><br>화면에 출력할 때 사용한다.<br>
보통 파일에 작성할 때 자주 사용하는데<br>
예시로는<br>echo "Hello" &gt; file.txt 2&gt; error.txt
<br>이런식으로 작성한다 &gt; 이거를 사용하는 걸 redirection이라고 하는데 출력 값을 다른 곳으로 넘겨주는 것이다.<br>2&gt; 를 통해 오류 값만을 다른 곳으로 보낼 수 있다. 주로 보내는 곳은 /dev/null로 휴지통에 버린다.<br>&gt;&gt;를 통해 값을 추가적으로 넣을 수 있다.<br><br>환경 변수를 의미한다. Windows에서는 명령어로 하는건 잘 모르지만 GUI로 하는 방법이 있다.<br>set $PATH:추가적인 경로
<br>를 통해 환경변수에 추가하고 <br><br>화면의 텍스트를 지운다.<br><br>현재 폴더의 위치를 알려준다.<br><br>명령어의 매뉴얼을 보여준다.<br><br>폴더를 만든다.<br><br><a data-href="Vim" href="컴퓨터 공학\프로그램\Vim.html" class="internal-link" target="_self" rel="noopener nofollow">Vim</a>을 사용할 때 사용한다.<br><br>파일을 복사한다.<br><br>만약 폴더 안의 모든 것을 복사하고 싶을 때 사용한다.<br><br>파일을 이동한다.<br><br>파일을 삭제할 때 사용한다.<br><br>인터넷에서 파일을 다운 받을 때 사용한다.<br><br>관리자의 권한으로 실행할 때 사용한다.<br>
sudoer 파일에 적혀있는 유저 만 사용가능하다.]]></description><link>컴퓨터 공학\운영체제\종류\리눅스\리눅스 명령어.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/리눅스/리눅스 명령어.md</guid><pubDate>Tue, 01 Jul 2025 00:39:42 GMT</pubDate></item><item><title><![CDATA[만들어진 이유]]></title><description><![CDATA[ 
 <br><br>운영체제와 소통하기 위함<br>]]></description><link>컴퓨터 공학\운영체제\종류\리눅스\리눅스 쉘.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/리눅스/리눅스 쉘.md</guid><pubDate>Mon, 23 Jun 2025 08:26:02 GMT</pubDate></item><item><title><![CDATA[윈도우]]></title><description><![CDATA[ 
 <br><a data-href="소켓 통신" href="컴퓨터 공학\인터넷\네트워크\소켓통신\소켓 통신.html" class="internal-link" target="_self" rel="noopener nofollow">소켓 통신</a>의 경우 IOCP(I/O Completion Port)방식을 사용한다.]]></description><link>컴퓨터 공학\운영체제\종류\윈도우\윈도우.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/윈도우/윈도우.md</guid><pubDate>Tue, 01 Jul 2025 07:34:23 GMT</pubDate></item><item><title><![CDATA[Os X]]></title><description><![CDATA[ 
 <br>MacOS라고도 불린다.<br>
유로 OS 중 하나다.<br>
Epoll이 불가능하다.]]></description><link>컴퓨터 공학\운영체제\종류\유닉스\Os X.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/종류/유닉스/Os X.md</guid><pubDate>Tue, 01 Jul 2025 00:45:13 GMT</pubDate></item><item><title><![CDATA[GUI]]></title><description><![CDATA[ 
 <br><a data-href="커널" href="컴퓨터 공학\운영체제\커널\커널.html" class="internal-link" target="_self" rel="noopener nofollow">커널</a>을 감싼다.<br>사용자나 앱은 쉘을 통해 요청하고 서비스를 제공받는다.<br><br>MacOS의 경우 Finder<br>
Windows의 경우 Explorer, MS-DOS Shell(과거엔 그랬음)<br><br>bash, zsh<br>
powershell<br>이걸 terminal이라고 부르는데 터미널 기기에서 따온 것이다.<br>
그리고 현재는 CLI 에뮬레이터라고 생각하면 되는게<br>
GUI 위에 CLI를 만든 것이기 때문]]></description><link>컴퓨터 공학\운영체제\커널\쉘.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/커널/쉘.md</guid><pubDate>Tue, 01 Jul 2025 07:34:02 GMT</pubDate></item><item><title><![CDATA[시스템 콜]]></title><description><![CDATA[ 
 <br>운영체제의 <a data-href="커널" href="컴퓨터 공학\운영체제\커널\커널.html" class="internal-link" target="_self" rel="noopener nofollow">커널</a>이 제공하는 서비스에 대해,<br>
응용 <a data-href="프로그램" href="컴퓨터 공학\운영체제\프로그램.html" class="internal-link" target="_self" rel="noopener nofollow">프로그램</a>의 요청에 따라 <a data-href="커널" href="컴퓨터 공학\운영체제\커널\커널.html" class="internal-link" target="_self" rel="noopener nofollow">커널</a>에 접근하기 위한 인터페이스를 말한다.<br><a data-href="x86" href="컴퓨터 공학\컴퓨터 구조\CPU\아키텍쳐\x86.html" class="internal-link" target="_self" rel="noopener nofollow">x86</a>시스템의 <a data-href="리눅스" href="컴퓨터 공학\운영체제\종류\리눅스\리눅스.html" class="internal-link" target="_self" rel="noopener nofollow">리눅스</a> 시스템 콜의 정보를 담은 사이트 <a data-tooltip-position="top" aria-label="%5Bx86.syscall.sh%5D(https://x86.syscall.sh/)" rel="noopener nofollow" class="external-link" href="[x86.syscall.sh](https:\\x86.syscall.sh\)" target="_blank">링크</a>도 있다.]]></description><link>컴퓨터 공학\운영체제\커널\시스템 콜.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/커널/시스템 콜.md</guid><pubDate>Tue, 01 Jul 2025 07:33:39 GMT</pubDate></item><item><title><![CDATA[커널]]></title><description><![CDATA[ 
 <br><a data-href="IO 작업" href="컴퓨터 공학\운영체제\IO 작업.html" class="internal-link" target="_self" rel="noopener nofollow">IO 작업</a> 할 때 사용한다.<br>드라이버를 관리한다.<br>운영체제의 핵심으로<br>
하드웨어를 직접 제어하며<br>
사용자가 직접 통제 할 수 없다.<br>보통 Low한 언어를 사용한다.<br>
<a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>나 <a data-href="어셈블리어" href="컴퓨터 공학\프로그래밍\언어\어셈블리\어셈블리어.html" class="internal-link" target="_self" rel="noopener nofollow">어셈블리어</a>를 사용한다.]]></description><link>컴퓨터 공학\운영체제\커널\커널.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/커널/커널.md</guid><pubDate>Tue, 01 Jul 2025 07:33:58 GMT</pubDate></item><item><title><![CDATA[뮤텍스]]></title><description><![CDATA[ 
 <br>한 번에 하나의 프로세스만 자원에 접근하도록 보장하는데 사용<br>
뮤텍스를 획득한 프로세스만 잠금 해제 가능하다.]]></description><link>컴퓨터 공학\운영체제\프로세스\스레드\스레드 동기화\뮤텍스.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/스레드/스레드 동기화/뮤텍스.md</guid><pubDate>Thu, 03 Jul 2025 07:41:53 GMT</pubDate></item><item><title><![CDATA[세마포어]]></title><description><![CDATA[ 
 <br>사용 가능한 자원의 수를 의마한다.<br>
특수한 연산들만 접근 할 수 있다.<br>P연산과 V연산이 있다.<br>
이 연산은 원자적으로 동작한다.<br>세마포어의 획득과 반환이 독립적이다.<br><br>S의 값이 0을 초과하면 들여보내주고 0 이하면 대기한다.<br><br>대기중인 프로세스가 존재하면 진행하고 아니면 S의 값을 1 추가한다.<br><br>자원이 있는지 계속 확인한다.<br><br>block을 통해 대기시키고 Wakeup을 통해 진행시킨다.<br><br><br>변수가 0과 1의 값만을 가질 수 있는 세마포어<br><br>음이 아닌 모든 정수가 될 수 있는 세마포어<br>
따라서 여러개의 프로세스가 접근이 가능하다.]]></description><link>컴퓨터 공학\운영체제\프로세스\스레드\스레드 동기화\세마포어.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/스레드/스레드 동기화/세마포어.md</guid><pubDate>Thu, 03 Jul 2025 07:42:13 GMT</pubDate></item><item><title><![CDATA[문제]]></title><description><![CDATA[ 
 <br>여러 개의 스레드가 돌아가는데 공유하는 자원이 있을 경우<br>
여러가지 문제가 발생하는데 그걸 막기 위한 방법이다.<br><br>만약에 int a= 0라는 변수를 여러 스레드가 공유하고 있고 각 스레드가 a+=1을 한다면<br>
A스레드와 B스레드의 경우로 나눠서 설명하겠습니다.<br>
a+=1의 코드는 3가지 단계로 나뉘어 집니다.<br>
<br>변수 a로부터 값을 가져와 레지스터에 넣습니다.
<br>레지스터에 1을 더합니다.
<br>레지스터의 값을 a에 넣습니다.<br>
A스레드가 변수 a로부터 값(0)을 가져와 레지스터에 넣고<br>
B스레드도 변수 a로부터 값(0)을 가져와 레지스터에 넣고<br>
A스레드가 레지스터(0)에 1을 더합니다.<br>
B스레드도 레지스터(0)에 1을 더합니다.<br>
A스레드가 레지스터의 값(1)을 a에 넣습니다.<br>
B스레드가 레지스터의 값(1)을 a에 넣습니다.<br>
따라서 a에는 1의 값이 저장됩니다.<br>
A스레드와 B스레드가 돌아갔지만 A 스레드의 연산값이 무시되었습니다.
<br><br>공유하는 자원을 사용하여 다른 스레드와 동시에 사용할 경우 문제가 발생할 수 있는 부분을 말한다.<br><a data-href="원자성 어셈블리 코드" href="컴퓨터 공학\컴퓨터 구조\원자성 어셈블리 코드.html" class="internal-link" target="_self" rel="noopener nofollow">원자성 어셈블리 코드</a>를 통해 모든 스레드 중 한 스레드만 임계구역에 들어올 수 있도록 막는다.<br><br>임계 구역 내에는 한 번에 하나의 프로세스만 있어야 한다. 이를 위해<br>
<a data-href="뮤텍스" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드 동기화\뮤텍스.html" class="internal-link" target="_self" rel="noopener nofollow">뮤텍스</a>, <a data-href="스핀락" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드 동기화\스핀락.html" class="internal-link" target="_self" rel="noopener nofollow">스핀락</a>, <a data-href="세마포어" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드 동기화\세마포어.html" class="internal-link" target="_self" rel="noopener nofollow">세마포어</a>가 존재한다.<br><br>]]></description><link>컴퓨터 공학\운영체제\프로세스\스레드\스레드 동기화\스레드 동기화.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/스레드/스레드 동기화/스레드 동기화.md</guid><pubDate>Thu, 03 Jul 2025 07:34:26 GMT</pubDate></item><item><title><![CDATA[특징]]></title><description><![CDATA[ 
 <br>스레드간 자원이 공유된다.<br>
공유되는 자원은 코드, 데이터, 힙 영역이다.<br>
CPU 코어 여러 개가 동시에 작업할 수 있는데 이 병렬성을 Parallelism<br>
정확히 동시에 한 동작을 하면 한 개의 동작이 무시 될 수 있다.<br>
그래서 스레드를 사용하고 공유하는 자원이 있으면 스레드 안전하게 코드를 짜야한다.<br>
CPU에서 실행되는 단위다.<br>스레드의 개수에는 제한이 있지는 않다.<br>
동시에 얼마나 돌릴 수 있는지는 하드웨어의 스레드 개수만큼 돌릴 수 있다.<br><br>Thread끼리 긴밀하게 연결되어 있음<br>
공유된 자원으로 통신 비용 절감<br>
공유된 자원으로 메모리가 효율적임<br>
Context Switching 비용이 적음<br>
공유 자원 관리를 해야함<br>
<a data-tooltip-position="top" aria-label="메모리 구조 > 스택 영역" data-href="메모리 구조#스택 영역" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html#스택_영역" class="internal-link" target="_self" rel="noopener nofollow">스택 영역</a>은 스레드 마다 가지고 있다.]]></description><link>컴퓨터 공학\운영체제\프로세스\스레드\스레드.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/스레드/스레드.md</guid><pubDate>Mon, 30 Jun 2025 06:04:18 GMT</pubDate></item><item><title><![CDATA[단점]]></title><description><![CDATA[ 
 <br>한번에 하나의 프로그램만 실행됨<br><br>CPU 사용률이 좋지 않다.<br>
<a data-href="IO 작업" href="컴퓨터 공학\운영체제\IO 작업.html" class="internal-link" target="_self" rel="noopener nofollow">IO 작업</a>을 하는 동안 쉰다.<br><br>여러 개의 프로그램을 메모리에 올려놓고 동시에 실행시키는 방법<br>
IO작업이 발생하면 다른 프로세스가 CPU에서 실행되는 구조]]></description><link>컴퓨터 공학\운영체제\프로세스\실행방식\단일 프로세스 시스템.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/실행방식/단일 프로세스 시스템.md</guid><pubDate>Tue, 01 Jul 2025 07:27:56 GMT</pubDate></item><item><title><![CDATA[멀티스레딩]]></title><description><![CDATA[ 
 <br>하나의 프로세스가 동시에 여러 작업을 실행하는데 목적]]></description><link>컴퓨터 공학\운영체제\프로세스\실행방식\멀티스레딩.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/실행방식/멀티스레딩.md</guid><pubDate>Tue, 24 Jun 2025 08:36:57 GMT</pubDate></item><item><title><![CDATA[단점]]></title><description><![CDATA[ 
 <br>프로세스의 응답 시간을 최소화 하는게 목적이다.<br>
동시에 실행된다고 느끼게 된다.<br><br>하나의 프로세스가 동시에 여러 작업을 수행하지는 못함<br>
프로세스의 컨텍스트 스위칭은 무거운 작업<br>
프로세스끼리 데이터 공유가 까다롭다.<br>
듀얼 코어를 활용할 수 없음<br><br>여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 CPU Time을 나눠 갖는 것]]></description><link>컴퓨터 공학\운영체제\프로세스\실행방식\멀티태스킹.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/실행방식/멀티태스킹.md</guid><pubDate>Tue, 24 Jun 2025 08:37:45 GMT</pubDate></item><item><title><![CDATA[단점]]></title><description><![CDATA[ 
 <br>CPU 사용률을 극대화 시키는 것이 목적이다.<br><br><a data-href="컴퓨터 공학/컴퓨터 구조/CPU/CPU" href="컴퓨터 공학\컴퓨터 구조\CPU\CPU.html" class="internal-link" target="_self" rel="noopener nofollow">컴퓨터 공학/컴퓨터 구조/CPU/CPU</a> 사용 시간이 길어지면 다른 프로세스는 계속 대기한다.<br><br>프로세스는 한번 CPU를 사용할 때<br>
아주 짧은 시간만 CPU에서 실행되게 하자]]></description><link>컴퓨터 공학\운영체제\프로세스\실행방식\멀티프로그래밍.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/실행방식/멀티프로그래밍.md</guid><pubDate>Thu, 03 Jul 2025 08:19:21 GMT</pubDate></item><item><title><![CDATA[멀티프로세싱]]></title><description><![CDATA[ 
 <br>두 개 이상의 프로세서나 코어를 활용하는 시스템]]></description><link>컴퓨터 공학\운영체제\프로세스\실행방식\멀티프로세싱.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/실행방식/멀티프로세싱.md</guid><pubDate>Tue, 24 Jun 2025 08:38:09 GMT</pubDate></item><item><title><![CDATA[시작]]></title><description><![CDATA[ 
 <br>프로세스간 자원이 공유가 되지 않는다.<br>
여러 프로세스가 돌아가면서 실행되는데<br>
실행 프로세스를 바꾸면서 Context Switching이 발생한다.<br>
프로세스가 빠르게 돌아가면서 실행되어서 동시에 실행되는 것 처럼 느껴지는데<br>
이 병렬성을 Concurrency라고 부른다.<br>
프로세스는 한 개 이상의 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>를 가질 수 있다.<br><br><a data-href="메모리 구조" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html" class="internal-link" target="_self" rel="noopener nofollow">메모리 구조</a>에 맞게 메모리에 값이 올라간다.<br>
PCB(Process Control Block)이 프로세스 생성시 함께 만들어짐<br><br>fork()를 통해 자식 프로세스를 만듬<br>
자식 프로세스는 부모와 별개의 메모리 영역을 가짐<br><br>각 프로세스는 독립적<br>
IPC를 통한 통신<br>
자원 소모적, 개별 메모리 차지<br>
Context Switching 비용이 큼<br>
동기화 작업이 필요하지 않음]]></description><link>컴퓨터 공학\운영체제\프로세스\프로세스.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/프로세스.md</guid><pubDate>Tue, 24 Jun 2025 08:32:12 GMT</pubDate></item><item><title><![CDATA[<a data-href="프로세스" href="컴퓨터 공학/운영체제/프로세스/프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>]]></title><description><![CDATA[ 
 <br><br><br><br>위 두 개는 멀티 코어가 있어야만 실행되는 게 아니라 싱글 코어로도 가능하다.<br>
다만 멀티 프로세스는 동시성이고 멀티 스레드는 병렬성이 가능한 것일 뿐이다.<br><br>리눅스 커널에서는 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>와 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>를 동일하게 본다.<br>
사용자 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>당 커널 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>가 하나가 매칭이 되어있다.<br>
이 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>는 각각 메모리를 가진 건 아니고 메모리를 공유한다.<br>
그래서 light weight process라고 부름<br>
한 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>에서 생성된 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>는 모두 같은 pid를 가진다.<br>
사용자 레벨에서 보면 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a> 그룹 아이디가 pid로 보이고<br>
커널 입장에서는 tid가 pid로 인식된다.]]></description><link>컴퓨터 공학\운영체제\프로세스\프로세스와 스레드.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로세스/프로세스와 스레드.md</guid><pubDate>Thu, 19 Jun 2025 08:36:45 GMT</pubDate></item><item><title><![CDATA[프로그램]]></title><description><![CDATA[ 
 <br>컴퓨터가 실행할 수 있는 명령어들의 집합]]></description><link>컴퓨터 공학\운영체제\프로그램.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/프로그램.md</guid><pubDate>Tue, 24 Jun 2025 08:02:35 GMT</pubDate></item><item><title><![CDATA[IO 작업]]></title><description><![CDATA[ 
 <br>IO는 Input Output을 말한다.<br>파일을 읽고 쓰거나<br>
<a data-href="네트워크" href="컴퓨터 공학\인터넷\네트워크\네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크</a>의 어딘가와 데이터를 주고 받는 것이다.<br>
입출력 장치와 데이터를 주거나 받는 것이다.<br>이 작업을 하는 동안 <a data-href="CPU" href="컴퓨터 공학\컴퓨터 구조\CPU\CPU.html" class="internal-link" target="_self" rel="noopener nofollow">CPU</a>는 쉰다.<br>
인터럽트를 통해 IO작업을 시작할 수 도 있고 끝난 신호로 받기도 한다.<br>간단하게 하면<br>
화면에 출력하는 것은 standard output 파일에 값을 쓰면<br>
화면에 출력되고<br>
입력 받는 것은 standard input 파일에 값을 쓰면 입력 받는다.]]></description><link>컴퓨터 공학\운영체제\IO 작업.html</link><guid isPermaLink="false">컴퓨터 공학/운영체제/IO 작업.md</guid><pubDate>Fri, 04 Jul 2025 08:51:04 GMT</pubDate></item><item><title><![CDATA[LNum]]></title><description><![CDATA[ 
 <br><a data-href="레이어드 아키텍쳐" href="컴퓨터 공학\프로그래밍\레이어드 아키텍쳐.html" class="internal-link" target="_self" rel="noopener nofollow">레이어드 아키텍쳐</a>방식이다.<br><br>물리 계층 부터 응용 계층까지 L1, L2 ~ L7으로 부른다.<br><br>0과 1을 주고 받을 수 있으면 모든 데이터를 주고 받을 수 있으니 연결된 것<br>
전기는 전자기파의 형태를 가지는데<br>
완전히 디지털의 형태로 만들 수 없어서<br>
보낼 때 디지털 신호를 아날로그 신호로 바꾸어서 전선으로 내보내고<br>
받을 때 아날로그 신호를 디지털 신호로 바꾸어 컴퓨터가 인식한다.<br>
이렇게 컴퓨터가 디지털 신호를 주고 받게 하는 모듈이 물리 계층이다.<br><br>디지털을 아날로그 신호로 변환하는 것<br><br>아날로그 신호를 디지털 신호로 변환하는 것<br><br><a data-href="토폴로지" href="컴퓨터 공학\인터넷\네트워크\토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">토폴로지</a>의 방법으로 함<br><br>하드웨어로 되어있다.<br><br>한 네트워크에서 한 곳에서 한 곳으로 데이터를 전송하려고 함<br>
근데 다른 컴퓨터는 읽지 않게 하고 싶음<br>
그러기 위해 스위치를 사용함<br>네트워크가 계층으로 연결되는데 전세계가 연결되면 인터넷이라고 함<br>같은 네트워크에서 여러 대의 컴퓨터가 데이터를 주고받기 위해 필요한 모듈이다.<br>
데이터의 시작과 끝을 알아야 정확하게 데이터를 받을 수 있는데 시작할 때 1111을 넣고<br>
끝날때 0000을 붙임 이를 Framing이라고 함<br><br>하드웨어로 되어있다.<br><br>IP 주소를 MAC 주소로 변환시켜주는 <a data-href="프로토콜" href="컴퓨터 공학\인터넷\네트워크\프로토콜.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜</a>이다.<br><br>MAC 주소를 IP주소로 변환시켜주는 <a data-href="프로토콜" href="컴퓨터 공학\인터넷\네트워크\프로토콜.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜</a>이다.<br><br>스위치와 스위치를 연결하려면 라우터로 연결함<br>
데이터를 보낼 때 상대 IP와 함께 데이터를 전송함<br>
라우팅 기법을 통해 경로를 파악해서 목적지와 연결된 라우터로 전송을 해서<br>
목적지로 배달을 완료함<br>
호스트 간의 통신을 담당한다.<br>
네트워크 간의 최적의 경로를 결정한다.<br><br>운영체제의 커널에 소프트웨어적으로 구현되어있다.<br><br>
<br>신뢰성 : 데이터를 순차적으로 안정적인 전달
<br>전송 : 포트 번호에 해당하는 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>에 데이터를 전달
<br>데이터의 순차 전송을 담당하고<br>
흐름 문제(원인 : 송수신자 간의 데이터 처리 속도 차이)를 해결하고<br>
혼잡 문제(원인 : 네트워크의 데이터 처리 속도)를 해결한다.<br>송신자는 데이터를 보낼 때 데이터를 받을 수신자 컴퓨터의 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>의 포트번호를 붙여서 보내야함<br>
포트 번호를 사용해 도착지 컴퓨터의 최종 도착지 <a data-href="프로세스" href="컴퓨터 공학\운영체제\프로세스\프로세스.html" class="internal-link" target="_self" rel="noopener nofollow">프로세스</a>에 도달하게 하는 모듈<br><br>논리적인 접속장소를 뜻하고<br>
네트워크 상의 특정 서버 프로그램을 지정할 때 사용한다.<br><br>운영체제의 커널에 소프트웨어적으로 구현되어있다.<br><br><a data-href="TCP UDP" href="컴퓨터 공학\인터넷\네트워크\TCP UDP.html" class="internal-link" target="_self" rel="noopener nofollow">TCP UDP</a><br><br>애플리케이션 간의 통신에서 세션을 관리한다.<br>예시는 RPC(remote procedure call)<br><br>애플리케이션 간의 통신에서 메시지 포맷 관리<br>
인코딩과 디코딩<br>
암호화와 복호화<br>
압축과 압축 풀기<br><br>누구든 Application Layer 인코더와 디코더를 만들 수 있음<br>
애플리케이션 목적에 맞는 통신 방법을 제공한다.<br>
예시는<br>
<br><a data-href="HTTP" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\HTTP.html" class="internal-link" target="_self" rel="noopener nofollow">HTTP</a> : HTML 전달
<br><a data-href="DNS" href="컴퓨터 공학\인터넷\DNS.html" class="internal-link" target="_self" rel="noopener nofollow">DNS</a> : 도메인 이름 서비스
<br>SMTP : 이메일 서비스
<br><a data-href="FTP" href="컴퓨터 공학\프로그램\SSH\FTP.html" class="internal-link" target="_self" rel="noopener nofollow">FTP</a> : 파일 전송
<br><br>세션 계층과 표현 계층과 응용 계층을 하나로 묶어서 응용계층으로 함<br>
그래서 여기서 세션과 표현 계층을 생략함<br><br>운영체제의 Transprot Layer에서 제공하는 API를 활용하여 통신 가능한 프로그램을 만드는 것을 말함]]></description><link>컴퓨터 공학\인터넷\네트워크\네트워크 계층 구조\OSI 7 Layers.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/네트워크 계층 구조/OSI 7 Layers.md</guid><pubDate>Fri, 27 Jun 2025 08:51:30 GMT</pubDate></item><item><title><![CDATA[TCP IP]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\인터넷\네트워크\네트워크 계층 구조\TCP IP.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/네트워크 계층 구조/TCP IP.md</guid><pubDate>Fri, 27 Jun 2025 08:37:23 GMT</pubDate></item><item><title><![CDATA[블로킹과 논 블로킹]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\인터넷\네트워크\소켓통신\블로킹과 논 블로킹.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/소켓통신/블로킹과 논 블로킹.md</guid><pubDate>Thu, 03 Jul 2025 02:06:35 GMT</pubDate></item><item><title><![CDATA[<a data-href="TCP IP 소켓통신" href="컴퓨터 공학/인터넷/네트워크/소켓통신/TCP IP 소켓통신.html" class="internal-link" target="_self" rel="noopener nofollow">TCP IP 소켓통신</a>]]></title><description><![CDATA[ 
 <br>컴퓨터와 컴퓨터를 연결하기 위해서는 소켓으로 연결하는 방식이다.<br><br>]]></description><link>컴퓨터 공학\인터넷\네트워크\소켓통신\소켓 통신.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/소켓통신/소켓 통신.md</guid><pubDate>Tue, 01 Jul 2025 00:04:54 GMT</pubDate></item><item><title><![CDATA[서버]]></title><description><![CDATA[ 
 <br><br><br>bind를 통해 서버에서 특정 포트를 통해 서버를 열겠다고 운영체제에게 말하는 단계입니다.<br>
이 작업 이후에는 다른 프로그램에서 해당 포트로 서버를 여는 게 방지됩니다.<br><br>클라이언트를 받을 준비를 합니다.<br>
한번에 몇 개의 클라이언트를 대기시키고 처리할지 설정이 가능합니다.<br><br>클라이언트를 받습니다.<br><br><br>서버에 접속합니다.]]></description><link>컴퓨터 공학\인터넷\네트워크\소켓통신\TCP IP 소켓통신.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/소켓통신/TCP IP 소켓통신.md</guid><pubDate>Sat, 21 Jun 2025 14:14:04 GMT</pubDate></item><item><title><![CDATA[UDP IP 소켓통신]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\인터넷\네트워크\소켓통신\UDP IP 소켓통신.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/소켓통신/UDP IP 소켓통신.md</guid><pubDate>Fri, 27 Jun 2025 08:24:11 GMT</pubDate></item><item><title><![CDATA[포트포워딩]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\인터넷\네트워크\포트\포트포워딩.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/포트/포트포워딩.md</guid><pubDate>Tue, 01 Jul 2025 02:51:11 GMT</pubDate></item><item><title><![CDATA[기능]]></title><description><![CDATA[ 
 <br>컴퓨터나 기타 기기들이<br>
리소스를 공유하거나 데이터를 주고 받기 위해<br>
유선 혹은 무선으로 연결된 통신 체계<br><br>애플리케이션 목적에 맞느 통신 방법을 제공<br>
신뢰할 수 있는 데이터 전송 방법 제공<br>
네트워크 간의 최적의 통신 경로 결정<br>
목적지로 데이터 전송<br>
노드 사이의 데이터 전송]]></description><link>컴퓨터 공학\인터넷\네트워크\네트워크.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/네트워크.md</guid><pubDate>Fri, 27 Jun 2025 08:15:03 GMT</pubDate></item><item><title><![CDATA[Bus]]></title><description><![CDATA[ 
 <br><br>하나의 통신 회선에 장치가 여러대 연결되어 있는 간단한 구조<br>
비용이 저렴함<br>
실제로 이 방식으로 되어있음<br><br>하나의 원을 만들어 정보의 흐름이 단방향임<br><br>중앙집중식 구조<br>
하나에 여러 개가 연결되어 있음<br><br>서로 전부 연결함<br><br>중앙 컴퓨터와 일정 지역 단말까지는 하나의 통신 회선<br>
이웃하는 단말장치는 일정 지역내의 중간 단말장치로 연결<br>
트리 형태]]></description><link>컴퓨터 공학\인터넷\네트워크\토폴로지.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/토폴로지.md</guid><pubDate>Sat, 21 Jun 2025 14:15:28 GMT</pubDate></item><item><title><![CDATA[프로토콜]]></title><description><![CDATA[ 
 <br>통신을 하기 위해서는 참여자들 사이 에서의 약속된 통신 방법이 필요하다.<br><a data-href="네트워크" href="컴퓨터 공학\인터넷\네트워크\네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크</a> 통신을 하기 위해서 통신에 참여하는 주체들이 따라야 하는 형식, 절차, 규약을<br>
<a data-href="네트워크" href="컴퓨터 공학\인터넷\네트워크\네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크</a> 프로토콜이라고 한다.<br>모든 기능을 하나의 프로토콜로 구현할 수 없다.<br>
따라서 모듈화를 해서 기능 별로 프로토콜을 만들어야 한다.]]></description><link>컴퓨터 공학\인터넷\네트워크\프로토콜.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/프로토콜.md</guid><pubDate>Tue, 01 Jul 2025 08:18:29 GMT</pubDate></item><item><title><![CDATA[Content Delivery Network]]></title><description><![CDATA[ 
 <br><br>컨텐츠를 좀 더 빠르게 제공하기 위해서 여기저기 서버를 두는 것<br>
서버를 싹 다 복사하는건 미러 서버고<br>
캐시해서 저장한다고 함<br>
DNS에 요청을 해서 가장 빠르게 접속이 가능한 위치로 연결되게 한다.<br>
이 CDN서버들을 Edge라고 함<br>정적 캐싱은 미리 데이터를 넣어두는 방식<br>
동적 캐싱은 사용자가 요청할 때마다 넣는 방식<br>TTL(Time To Live) 데이터를 캐시에 얼마나 남아있게 할지도 정할 수 있다.<br>본 서버에 주어지는 과부하가 줄어듬<br>DDOS를 받더라도 CDN이 대신 맞아주게 할 수 있음<br><br>물리적 거리를 얼마나 빠르게 이동하는가<br><br>데이터를 얼마나 많이 보내는 가]]></description><link>컴퓨터 공학\인터넷\네트워크\CDN.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/CDN.md</guid><pubDate>Tue, 17 Jun 2025 08:38:37 GMT</pubDate></item><item><title><![CDATA[IPv4]]></title><description><![CDATA[ 
 <br><br>0~255의 4개의 숫자<br>
IP가 부족함<br>
그래서 공인 IP를 주고 공인 IP를 공유하는 기기들에게 사설 IP를 줘서 구별한다.<br>사설 IP에서 공인IP로 접속이 가능하지만 반대는 못함<br><br>16진수 4자리가 8개<br>
IPv4가 부족해지면 IPv6로 대체될 거임<br><br>공인 IP에 포트를 열어 사설 포트로 연결하면 공인 IP에서 사설 IP로 접속이 가능하다.<br><br>공인IP의 모든 포트를 특정 사설 IP에 몰아줌<br>
모든 포트를 열기에 권장하지 않음<br><br>실제로 쓰고 있는 기기에게만 할당해주고 나머지는 회수하는 방식으로<br>
변경되는 거임<br>
IP가 변경되니까 보안상 더 좋음<br><br>서버 같은 경우 비싸게 사용함<br><br>수시로 바뀌는 유동 IP를 감지해 도메인에 연결해주는 방식]]></description><link>컴퓨터 공학\인터넷\네트워크\IP 주소.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/IP 주소.md</guid><pubDate>Wed, 04 Jun 2025 14:46:04 GMT</pubDate></item><item><title><![CDATA[전송 계층]]></title><description><![CDATA[ 
 <br><br><a data-href="OSI 7 Layers" href="컴퓨터 공학\인터넷\네트워크\네트워크 계층 구조\OSI 7 Layers.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 7 Layers</a>에서의 전송 계층에 속해있다.<br><br>3 Way-Handshake라고 하는데 양방향 통신이다.<br>데이터를 주고 받을 때 신뢰성 있는 연결을 할 수 있다.<br>
데이터의 순차 전송을 보장한다.<br>
흐름 제어, 혼잡 제어, 오류 감지를 한다.<br>데이터를 쪼개서 TCP header를 붙이는데 붙인걸 세그먼트라고 한다.<br><br>클라이언트가 서버에게 접속을 요청하는 SYN 패킷을 보내고 SYN/ACK 응답을 기다린다.<br>
서버는 SYN 요청을 받고 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고 ACK 응답을 기다린다.<br>
클라이언트는 서버에게 SYN/ACK를 받고 서버에게 ACK를 보내고 연결에 성공하여 데이터를 주고받기 시작한다.<br><br>클라이언트에서 패킷을 전송하고 서버에서는 받으면 ACK를 보내고<br>
클라이언트는 ACK를 받으면 다음 패킷을 전송한다.<br>
ACK를 못 받으면 다시 패킷을 전송한다.<br><br>클라이언트에서 FIN을 보낸다.<br>
서버가 ACK를 송신한다.<br>
서버에서 남은 패킷을 받고 서버가 FIN을 송신하면<br>
클라이언트가 ACK를 송신한다.<br><br>전송의 신뢰성은 보장하지만<br>
패킷이 조금만 손실해도 재전송을 하기에<br>
시간이 오래 걸릴 수 있다.<br><br>데이터를 주고 받을 때 신뢰성이 없지만 빠르게 주고 받을 수 있다.<br>
순차 전송, 흐름 제어, 혼잡 제어 하지 않는다.<br>
Error Detection을 한다.<br>
데이터의 신뢰성이 중요하지 않을 때 사용한다. (예시는 영상 스트리밍이다.)<br>
데이터에 UDP Header를 추가해서 보낸다. 여기선 쪼개지 않음<br>전송 방법이 패킷을 보낸다.<br>
접속을 하지 않음]]></description><link>컴퓨터 공학\인터넷\네트워크\TCP UDP.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/네트워크/TCP UDP.md</guid><pubDate>Sun, 08 Jun 2025 13:12:17 GMT</pubDate></item><item><title><![CDATA[<a data-href="HTML 태그" href="컴퓨터 공학/인터넷/web/데이터양식/HTML/HTML 태그.html" class="internal-link" target="_self" rel="noopener nofollow">HTML 태그</a>]]></title><description><![CDATA[ 
 <br>데이터를 주고 받을 때 사용하는 <a data-tooltip-position="top" aria-label="Markup Language" data-href="Markup Language" href="컴퓨터 공학\프로그래밍\언어\Mark 언어\Markup Language\Markup Language.html" class="internal-link" target="_self" rel="noopener nofollow">마크업</a> 언어다.<br>
Hyper Text Markup Language로<br>
링크를 통해 문서를 이동할 수 있다.<br>
hyper text가 링크가 달려있는 Text다.<br><br><br>각종 설정을 놓는 곳이다.<br>
여기서 <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>와 <a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>를 연결한다.<br><br>화면의 요소들을 담는 곳이다.<br><br>특정 한개의 엘리먼트를 특정할 때 사용한다.<br><br>여러 개의 엘리먼트를 특정할 때 사용한다.<br>
띄어서 작성하면 여러 개의 클래스를 넣을 수 있다.<br><br>
<br>멀티미디어 : 플러그인 없이 음악과 동영상 재생 가능
<br>그래픽 : 2차원 그래픽, 3차원 그래픽 구현
<br>통신 : 서버와 실시간 쌍방향 통신
<br>장치 : 장치와의 연동을 통해 접근 및 기능 사용
<br>오프라인 : 인터넷 연결 없이도 응용 프로그램 동작 가능
<br>시맨틱 : 정보를 분석, 자료를 검색 및 처리하여 제공하는 지능형 웹
<br><br>nav.menu-1&gt;ul&gt;li*3&gt;a[href="#"]{메뉴 아이템 $}
<br>이렇게 하면 빠르게 작성 가능<br>
+를 통해 자식 여러 개 설정 가능하다.]]></description><link>컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/데이터양식/HTML/HTML.md</guid><pubDate>Thu, 03 Jul 2025 08:35:06 GMT</pubDate></item><item><title><![CDATA[기본 구조]]></title><description><![CDATA[ 
 <br><br>태그 여는건 &lt;태그&gt;로<br>
태그 닫는건 &lt;/태그&gt;로<br>
안에 작성할거 없으면 &lt;태그 /&gt;로<br>&lt;script&gt; 태그를 통해 <a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>를 불러온다.<br>
&lt;link&gt; 태그를 통해 <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>를 불러온다.<br><br>분리할 때 사용함<br>
display:block 처리를 한다.<br>
따라서 div + inline = span<br><br>분리할 때 사용한다.<br>
display:inline 처리를 한다.<br>
따라서 span + block = div<br><br>입력을 할 수 있는 element다.<br><br>어딘가로 전송하기 위해서 만드는 것이다.<br>&lt;form action="https://search.naver.com/search.naver" target="_blank"&gt;
<br>input에 name을 넣고 type이 submit인 Button을 누르면 링크에 파라미터를 넣고 이동한다.<br><br>여러가지 기능을 하는데 사용한다.<br>
예를들어 검색어로 검색되게 만들기도 가능하고<br>
검색되지 않게 만들 수도 있고<br>
테마 색상을 정할 수도 있고<br>
휴대폰 위나 아래에 가려지는것을 피하게 할 수도 있다.<br>
링크 공유할 때 어떻게 표시될지도 정할 수 있다.<br>
출처 <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=giCR2IneTPw&amp;feature=youtu.be" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=giCR2IneTPw&amp;feature=youtu.be" target="_blank">링크</a>]]></description><link>컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML 태그.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/데이터양식/HTML/HTML 태그.md</guid><pubDate>Thu, 03 Jul 2025 08:41:49 GMT</pubDate></item><item><title><![CDATA[JSON]]></title><description><![CDATA[ 
 <br>JavaScript Object Notation의 약자다.]]></description><link>컴퓨터 공학\인터넷\web\데이터양식\JSON.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/데이터양식/JSON.md</guid><pubDate>Tue, 01 Jul 2025 00:49:16 GMT</pubDate></item><item><title><![CDATA[XML]]></title><description><![CDATA[ 
 <br><a data-href="Markup Language" href="컴퓨터 공학\프로그래밍\언어\Mark 언어\Markup Language\Markup Language.html" class="internal-link" target="_self" rel="noopener nofollow">Markup Language</a>이다.<br>
HTML과 비슷하지만 HTML보다 더 유연하다.]]></description><link>컴퓨터 공학\인터넷\web\데이터양식\XML.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/데이터양식/XML.md</guid><pubDate>Tue, 01 Jul 2025 02:47:54 GMT</pubDate></item><item><title><![CDATA[API]]></title><description><![CDATA[ 
 <br>소프트웨어 애플리케이션들이 서로 통신하고 상호작용할 수 있도록 하는 규칙 또는 <a data-href="프로토콜" href="컴퓨터 공학\인터넷\네트워크\프로토콜.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜</a>의 집합을 말한다.]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\API\API.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/API/API.md</guid><pubDate>Tue, 01 Jul 2025 08:18:09 GMT</pubDate></item><item><title><![CDATA[CORS]]></title><description><![CDATA[ 
 <br>브라우저에서 HTML을 가져온 서버와 다른 서버에서 API 요청을 하면<br>
문제가 있다고 생각하여 거부한다.<br>
그래서 API 서버에서 허용한다고 설정을 해줘야 한다.]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\API\CORS.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/API/CORS.md</guid><pubDate>Tue, 01 Jul 2025 01:18:30 GMT</pubDate></item><item><title><![CDATA[OPEN API]]></title><description><![CDATA[ 
 <br>수동으로도 만들 수 있고<br>
자동으로 만들 수 있다.<br>자동으로 만들어 주는 문서는 스프링 doc과 스웨거가 있다.]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\API\OPEN API.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/API/OPEN API.md</guid><pubDate>Mon, 30 Jun 2025 05:14:18 GMT</pubDate></item><item><title><![CDATA[SpringDoc]]></title><description><![CDATA[ 
 <br>내부적으로 스웨거를 사용해 open API문서를 만들어준다.<br>spring에서 추천하는 방법은 아니라 직접 implement 해야한다.<br>
<a data-tooltip-position="top" aria-label="https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui" rel="noopener nofollow" class="external-link" href="https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui" target="_blank">링크</a>를 통해 implement 코드를 얻을 수 있다.<br>implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.9")
]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\API\SpringDoc.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/API/SpringDoc.md</guid><pubDate>Mon, 30 Jun 2025 05:35:06 GMT</pubDate></item><item><title><![CDATA[C HTTP common.h]]></title><description><![CDATA[ 
 <br>#ifndef COMMON_H

#define COMMON_H

  

#define BUF_SIZE 1000

#define HEADER_FMT "HTTP/1.1 %d %s\nContent-Length: %ld\nContent-Type: %s\n\n"

#define NOT_FOUND_CONTENT   "&lt;h1&gt;404 Not Found&lt;/h1&gt;\n"

#define SERVER_ERROR_CONTENT "&lt;h1&gt;500 Internal Server Error&lt;/h1&gt;\n"

#define SOCKET_ERROR -1

  

#include &lt;stdio.h&gt;

#include &lt;string.h&gt;

#include &lt;stdlib.h&gt;

#include &lt;unistd.h&gt;

#include &lt;fcntl.h&gt;

#include &lt;signal.h&gt;

#include &lt;sys/types.h&gt;

#include &lt;sys/stat.h&gt;

#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#include &lt;pthread.h&gt;

#include &lt;stdbool.h&gt;

  

typedef int Socket;

#endif // COMMON_H
<br>소켓 값이 int이지만 구분을 위해 Socket이라고 작성했습니다.<br>
리눅스 전용으로 만들어져 있어 windows에는 없는 라이브러리가 있습니다.]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP common.h.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/HTTP/C로 만드는 HTTP/C HTTP common.h.md</guid><pubDate>Mon, 23 Jun 2025 05:57:51 GMT</pubDate></item><item><title><![CDATA[C HTTP http_functions.c]]></title><description><![CDATA[ 
 <br>#include "common.h"

#include "http_functions.h"

  

int bind_lsock(int lsock, int port){

    struct sockaddr_in sin;

    sin.sin_family = AF_INET;

    sin.sin_addr.s_addr = htonl(INADDR_ANY);

    sin.sin_port = htons(port);

    return bind(lsock, (struct sockaddr *)&amp;sin, sizeof(sin));

}

  

void fill_header(char *header, int status, long len, char *type){

    char status_text[40];

    switch (status){

        case 200:

            strcpy(status_text, "OK");

            break;

        case 404:

            strcpy(status_text, "Not Found");

            break;

        case 500:

        default:

            strcpy(status_text, "Internal Server Error");

            break;

    }

    sprintf(header, HEADER_FMT, status, status_text, len, type);

}

  

void find_mime(char *ct_type, char *uri){

    char *ext = strrchr(uri, '.');

    if (!strcmp(ext, ".html"))

        strcpy(ct_type, "text/html");

    else if (!strcmp(ext, ".jpg") || !strcmp(ext, "jpeg"))

        strcpy(ct_type, "image/jpeg");

    else if (!strcmp(ext, ".png"))

        strcpy(ct_type, "image/png");

    else if (!strcmp(ext, ".css"))

        strcpy(ct_type, "text/css");

    else if (!strcmp(ext, ".js"))

        strcpy(ct_type, "text/javascript");

    else

        strcpy(ct_type, "text/plain");

}

  

void handle_404(int asock){

    char header[BUF_SIZE];

    fill_header(header, 404, sizeof(NOT_FOUND_CONTENT), "text/html");

  

    write(asock, header, strlen(header));

    write(asock, NOT_FOUND_CONTENT, sizeof(NOT_FOUND_CONTENT));

}

  

void handle_500(int asock){

    char header[BUF_SIZE];

    fill_header(header, 500, sizeof(SERVER_ERROR_CONTENT), "text/html");

  

    write(asock, header, strlen(header));

    write(asock, SERVER_ERROR_CONTENT, sizeof(SERVER_ERROR_CONTENT));

}

  

void http_handler(int asock){

    char header[BUF_SIZE];

    char buf[BUF_SIZE];

  

    if (read(asock, buf, BUF_SIZE) &lt; 0){

        perror("[ERR] Failed to read request.\n");

        handle_500(asock);

        return;

    }

  

    char *method = strtok(buf, " ");

    char *uri = strtok(NULL, " ");

  

    if (method == NULL || uri == NULL){

        perror("[ERR] Failed to identify method, URI.\n");

        handle_500(asock);

        return;

    }

  

    printf("[INFO] Handling Request: method=%s, URI=-%s\n", method, uri);

  

    char safe_uri[BUF_SIZE];

    char *local_uri;

    struct stat st;

  

    strcpy(safe_uri, uri);

    if (!strcmp(safe_uri, "/"))

        strcpy(safe_uri, "/index.html");

    local_uri = safe_uri + 1;

    if (stat(local_uri, &amp;st) &lt; 0){

        perror("[WARN] No file found matching URI.\n");

        handle_404(asock);

        return;

    }

  

    int fd = open(local_uri, O_RDONLY);

    if (fd &lt; 0){

        perror("[ERR] Failed to open file.\n");

        handle_500(asock);

        return;

    }

  

    int ct_len = st.st_size;

    char ct_type[40];

    find_mime(ct_type, local_uri);

    fill_header(header, 200, ct_len, ct_type);

    write(asock, header, strlen(header));

  

    int cnt;

    while((cnt = read(fd,buf, BUF_SIZE)) &gt; 0)

        write(asock, buf, cnt);

}
<br>200, 404, 500번 대의 <a data-href="상태 코드" href="컴퓨터 공학\인터넷\web\back end\상태 코드.html" class="internal-link" target="_self" rel="noopener nofollow">상태 코드</a>가 구현되어있습니다.<br><a data-href="소켓 통신" href="컴퓨터 공학\인터넷\네트워크\소켓통신\소켓 통신.html" class="internal-link" target="_self" rel="noopener nofollow">소켓 통신</a>에서도 설명하지만<br>
보면 클라이언트가 서버에게 파일을 요청하면 서버가 해당 위치에 파일이 있는지 확인한 후<br>
상태코드와 함께 파일을 전송합니다.<br>
write로 전송하는데 소켓을 일종의 파일 같은 거라 생각한 거라 보면 됩니다.]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP http_functions.c.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/HTTP/C로 만드는 HTTP/C HTTP http_functions.c.md</guid><pubDate>Sat, 21 Jun 2025 14:12:13 GMT</pubDate></item><item><title><![CDATA[C HTTP main.c]]></title><description><![CDATA[ 
 <br>#include "common.h"

#include "my_thread.h"

  

#define THREAD_COUNT 10

pthread_mutex_t mutex_lock = PTHREAD_MUTEX_INITIALIZER;

  

int main(int argc, char **argv){

    int port, pid;

    Socket lsock, asock;

    pthread_mutex_init(&amp;mutex_lock, NULL);

  

    struct sockaddr_in remote_sin;

    socklen_t remote_sin_len;

    pthread_t thread;

  

    if (argc &lt; 2){

        printf("Usage: \n");

        printf("\t%s {port}: runs mini HTTP server. \n", argv[0]);

        exit(0);

    }

  

    port = atoi(argv[1]);

    printf("[INFO] The server will listen to port : %d.\n", port);

  

    lsock = socket(AF_INET, SOCK_STREAM, 0);

    if (lsock == SOCKET_ERROR){

        perror("[ERR] failed to create listen socket.\n");

        exit(1);

    }

  

    int optval = 1;

    if (setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)) &lt; 0) {

        perror("[ERR] failed to set socket options.\n");

        exit(1);

    }

  

    if (bind_lsock(lsock, port) == SOCKET_ERROR){

        perror("[ERR] failed to bind listen socket.\n");

        exit(1);

    }

  

    if (listen(lsock, 10) == SOCKET_ERROR){

        perror("[ERR] failed to listen listen socket.\n");

        exit(1);

    }

  

    struct ClientThread *clientThreads = malloc(sizeof(struct ClientThread) * THREAD_COUNT);

    int thread_index = 0;

    while (1){

        printf("[INFO] waiting...\n");

        asock = accept(lsock, (struct sockaddr *)&amp;remote_sin, &amp;remote_sin_len);

        if (asock == SOCKET_ERROR){

            perror("[ERR] failed to accept.\n");

            continue;

        }

        bool found = false;

        pthread_mutex_lock(&amp;mutex_lock);

        for (int i = 1; i &lt;= THREAD_COUNT; i++){

            int real_index = (thread_index + i ) % THREAD_COUNT;

            if (clientThreads[real_index].is_running == false){

                clientThreads[i].socket = asock;

                clientThreads[i].is_running = true;

                found = true;

                thread_index = real_index;

                break;

            }

        }

        if (!found){

            printf("[ERR] No available thread.\n");

            close(asock);

            continue;

        }

        clientThreads[thread_index].socket = asock;

        clientThreads[thread_index].is_running = true;

        pthread_create(&amp;thread, NULL, (void*)thread_func, (void *)(&amp;clientThreads[thread_index]));

        clientThreads[thread_index].id = thread;

        pthread_mutex_unlock(&amp;mutex_lock);

    }

  

    for (int thread_num = 0; thread_num &lt; THREAD_COUNT; thread_num++){

        if (clientThreads[thread_num].is_running){

            pthread_join(clientThreads[thread_num].id, NULL);

            clientThreads[thread_num].is_running = false;

            printf("[INFO] Thread %d finished.\n", thread_num);

        }

    }

    close(lsock);

    free(clientThreads);

    pthread_mutex_destroy(&amp;mutex_lock);

    return 0;

}
<br>
소켓을 만들고<br>
소켓에 사용하려는 포트가 이미 열려 있어도 그 포트로 열라고 설정하고<br>
(이거는 실행할 때 편하게 하려고 한겁니다.<br>
다시 실행시킬 때 포트가 열려있다며 서버가 열리지 않는 문제를 해결합니다.)<br>
bind, listen을 통해 클라이언트를 받을 준비를 하고<br>
accept를 통해 클라이언트를 받습니다.<br>
여기서는 클라이언트를 사용 가능한 스레드에 할당하고 스레드를 실행시키는 방법입니다.
]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP main.c.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/HTTP/C로 만드는 HTTP/C HTTP main.c.md</guid><pubDate>Sat, 21 Jun 2025 14:08:59 GMT</pubDate></item><item><title><![CDATA[C HTTP my_thread.c]]></title><description><![CDATA[ 
 <br>#include "common.h"

#include "my_thread.h"

extern pthread_mutex_t mutex_lock;

  

void *thread_func(void* arg){

    struct ClientThread *client_thread = (struct ClientThread *)arg;

    http_handler(client_thread-&gt;socket);

    close(client_thread-&gt;socket);

    pthread_mutex_lock(&amp;mutex_lock);

    client_thread-&gt;is_running = false;

    pthread_mutex_unlock(&amp;mutex_lock);

    printf("[INFO] Thread %ld finished.\n", client_thread-&gt;id);

    return NULL;

}
<br>
각 스레드 마다 일어나는 일인데<br>
http_handler 함수로 처리를 하고<br>
소켓을 닫아 클라이언트와의 연결을 끊고<br>
종료합니다.
]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP my_thread.c.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/HTTP/C로 만드는 HTTP/C HTTP my_thread.c.md</guid><pubDate>Mon, 23 Jun 2025 05:56:42 GMT</pubDate></item><item><title><![CDATA[common]]></title><description><![CDATA[ 
 <br>모든 네트워크와 연결되는 프로그램은 소켓을 통해 통신한다.<br>
따라서 <a data-href="소켓 통신" href="컴퓨터 공학\인터넷\네트워크\소켓통신\소켓 통신.html" class="internal-link" target="_self" rel="noopener nofollow">소켓 통신</a>에 대해서 알아야 한다.<br>
<a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>로 만드니 <a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>에 대한 지식도 가져야 한다.<br>우분투에서 돌린 것입니다.<br>
헤더파일이랑 CMakeLists.txt파일은 생략되었습니다.<br><br>헤더 파일을 일단 정의 해두려 한다.<br>
<a data-href="C HTTP common.h" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP common.h.html" class="internal-link" target="_self" rel="noopener nofollow">C HTTP common.h</a><br><br>시작 부분이다.<br>
<a data-href="C HTTP main.c" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP main.c.html" class="internal-link" target="_self" rel="noopener nofollow">C HTTP main.c</a><br><br>http 관련 작업을 합니다.<br>
<a data-href="C HTTP http_functions.c" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP http_functions.c.html" class="internal-link" target="_self" rel="noopener nofollow">C HTTP http_functions.c</a><br><br>각 클라이언트의 스레드에서 동작하는 코드입니다.<br>
<a data-href="C HTTP my_thread.c" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C HTTP my_thread.c.html" class="internal-link" target="_self" rel="noopener nofollow">C HTTP my_thread.c</a>]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C로 만드는 HTTP.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/HTTP/C로 만드는 HTTP/C로 만드는 HTTP.md</guid><pubDate>Sat, 21 Jun 2025 13:58:23 GMT</pubDate></item><item><title><![CDATA[HTTP]]></title><description><![CDATA[ 
 <br>요청과 응답의 형태로 이루어진 웹 통신 규약<br>소켓 통신으로 구현이 가능하다.<br><a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>, 이미지, <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>, <a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>, json 등 여러가지 데이터를 주고 받을 수 있다.<br>클라이언트가 파일을 서버에게 요청을 하면<br>
서버는 해당 파일을 응답하여 클라이언트에게 전송한다.<br>
클라이언트의 웹브라우저는 파일을 해석해서 클라이언트에게 웹 페이지를 보여줌<br><a data-href="C로 만드는 HTTP" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\C로 만드는 HTTP\C로 만드는 HTTP.html" class="internal-link" target="_self" rel="noopener nofollow">C로 만드는 HTTP</a>를 통해 구조를 확인할 수 있을 거라 생각한다.]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\HTTP\HTTP.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/HTTP/HTTP.md</guid><pubDate>Sat, 21 Jun 2025 14:16:19 GMT</pubDate></item><item><title><![CDATA[웹서버]]></title><description><![CDATA[ 
 <br><br>특정 폴더에 <a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>, <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>, <a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a> 의 파일들을 저장해 두고<br>
외부에서 접속하면 이 파일들을 가져갈 수 있게 하는 것<br>아파치, NginX, IIS가 대표적인 웹 서버이다.<br>
<a data-href="정적 웹, 동적 웹" href="컴퓨터 공학\인터넷\web\정적 웹, 동적 웹.html" class="internal-link" target="_self" rel="noopener nofollow">정적 웹, 동적 웹</a> 중 동적 웹을 아파치나 NginX의 모듈로 만들 수 있다.<br><br>스프링을 통해 웹 또는 API 어플리케이션을 실행할 때<br>
톰캣 같은 Web Application Server가 사용된다.<br>
WAS라고 부르기도 함<br>
파일을 전송하기만 하지 않고 좀 더 가공을 한다.<br>스프링으로 코딩한 웹앱을 war 파일로 빌드하고<br>
톰캣을 다운 받고 톰캣의 특정 폴더에 war파일을 넣고 실행하면<br>
스프링 서비스가 톰캣을 사용해 돌게 된다.<br>요즘은 스프링을 톰캣이 들어있는 jar 파일로 빌드해서 배포함<br><br>자신의 주소를 숨기기 위해 중간에 서버를 통해서 접속하는 것<br><br>서버가 리소스 파일의 위치를 숨기는 것<br>
보안이 좋아진다.<br>
이를 위해 아파치를 통해 서버를 만들어 클라이언트와 데이터를 주고 받고<br>
복잡한 부분은 톰캣이 한다.<br><br>사용자가 반복적을 찾을 것 같은 데이터를 준비해 두는 것<br><br>톰캣을 여러개 실행시켜서 사용자를 분산하는 것<br>
업데이트할 때 순서대로 하나씩 업데이트를 해서 서버가 끊기지 않고 작동되도록 한다.<br><br>멀티 프로세스 모듈 방식으로 동작<br>
메모리를 많이 씀<br>
그리고 컨택스트 스위칭 비용이 비쌈<br>
그래서 이벤트도 채택함<br><br>이벤트 방식으로 사용자가 있을 때만 반응한다.<br>
성능적으로 좋음<br>
그리고 가벼움]]></description><link>컴퓨터 공학\인터넷\web\back end\서버\아파치, NginX, 톰캣.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/서버/아파치, NginX, 톰캣.md</guid><pubDate>Wed, 18 Jun 2025 07:48:43 GMT</pubDate></item><item><title><![CDATA[200번대]]></title><description><![CDATA[ 
 <br><br>성공한 경우다.<br><br>해당 페이지에서 바로 벗어나라는 코드다.<br><br>클라이언트가 잘못하여 오류가 난 경우다.<br><br>서버가 잘못하여 오류가 발생항 경우다.<br><br>고양이 사진과 함께 HTTP Code의 설명이 있는 사이트다.]]></description><link>컴퓨터 공학\인터넷\web\back end\상태 코드.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/상태 코드.md</guid><pubDate>Wed, 25 Jun 2025 01:37:12 GMT</pubDate></item><item><title><![CDATA[쿠키]]></title><description><![CDATA[ 
 <br>웹사이트에서 어떤 일을 했는지 저장하는 데이터를 말한다.<br>웹사이트에 접속하면 서버가 쿠키를 만들어 브라우저에 저장시킨다.<br>
브라우저는 쿠키를 가지고 있다 서버가 요청하면 쿠키를 전송한다.<br>
서버는 쿠키를 확인하고 해당 쿠키에 맞는 정보를 전송하고 브라우저에 반영된다.<br>
예를들어 언어 설정이 있다.<br>브라우저에 쿠키가 저장되기에 민감한 정보는 저장하지 않는다.<br><br><br>쿠키를 식별하는데 사용되기 때문에 중복된 키는 존재하지 않는다.<br><br>알파벳과 숫자로 이루어져있으며 대부분 4096바이트로 제한되어있다.<br><br>쿠키가 어떤 서버로 전송되어야 하는지 지정하는 구성요소다.<br><br>명시한 경로와 그 하위 경로에만 쿠키가 전송된다.<br><br>명시된 만료일이 지나면 쿠키는 삭제된다.<br>
지정되지 않았으면 브라우저가 종료될 때 사라지고 이런 쿠키를 세션 쿠키라고 한다.<br><br>사용자가 이용중인 웹사이트 소유자가 직접 생성<br><br>제 3자가 발행한 쿠키<br><br>사이트의 모든 기능을 사용하려면 필요한 쿠키<br><br>사용자의 웹사이트 이용 정보를 수집해<br>
서비스를 효율적으로 개선하는데 사용<br><br>사용자의 언어, 지역에 대한 데이터를 담아<br>
사용자에게 최적화된 서비스를 제공하는데 사용한다.<br><br>사용자에게 광고 콘텐츠를 제공하는데 사용한다.]]></description><link>컴퓨터 공학\인터넷\web\back end\쿠키.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/쿠키.md</guid><pubDate>Mon, 30 Jun 2025 06:15:24 GMT</pubDate></item><item><title><![CDATA[<a data-href="쿠키" href="컴퓨터 공학/인터넷/web/back end/쿠키.html" class="internal-link" target="_self" rel="noopener nofollow">쿠키</a>]]></title><description><![CDATA[ 
 <br><br>사이트를 방문하고 이용할 때 브라우저에 저장하는 데이터<br>
마음대로 변경하면 안되는 값들은 저장하지 않는다.<br><br>접속하면 기한이 짧은 임시 키를 줌<br>
키를 쿠키에 저장해서 쿠키를 서버에 전송하면 사용자를 인식함<br><br>가져오는데 비용이 드는 정보를 한번 가져오면 저장해두는 것]]></description><link>컴퓨터 공학\인터넷\web\back end\쿠키, 세션, 캐시.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/쿠키, 세션, 캐시.md</guid><pubDate>Mon, 30 Jun 2025 06:15:35 GMT</pubDate></item><item><title><![CDATA[Back-End]]></title><description><![CDATA[ 
 <br>사용자에게 보이지 않는 실제 구성 시스템과 서버 사이드의 개발을 한다.<br>
주로 JAVA, Python, Ruby, PHP, SQL등의 언어가 사용된다.]]></description><link>컴퓨터 공학\인터넷\web\back end\Back-End.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/back end/Back-End.md</guid><pubDate>Fri, 06 Jun 2025 02:35:10 GMT</pubDate></item><item><title><![CDATA[테일 윈드 적용]]></title><description><![CDATA[ 
 <br><br>&lt;script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"&gt;&lt;/script&gt;
<br>HTML에 작성하면 된다.<br><br>HTML에 script를 추가해주고<br>
class 명에 css 내용을 넣는 방식이다.<br>
<a data-href="JSX" href="컴퓨터 공학\인터넷\web\front end\react\JSX.html" class="internal-link" target="_self" rel="noopener nofollow">JSX</a>에 넣을 때는 class 대신 className으로 작성해야함<br><br>기본 스타일이 있으면 커스텀하기가 힘들다.<br>
그래서 테일윈드를 <br><br><a data-tooltip-position="top" aria-label="https://tailwindcss.504b.cc/?ref=dailydev" rel="noopener nofollow" class="external-link" href="https://tailwindcss.504b.cc/?ref=dailydev" target="_blank">링크</a><br><br><br>다른 설정과 충돌이 발생해서 우선순위에 밀려서 반영이 안될 경우 !을 앞에 붙여서 강제로 반영시킬 수 있다.]]></description><link>컴퓨터 공학\인터넷\web\front end\테일윈드\테일윈드.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/테일윈드/테일윈드.md</guid><pubDate>Tue, 01 Jul 2025 05:14:33 GMT</pubDate></item><item><title><![CDATA[사용 용도]]></title><description><![CDATA[ 
 <br><br>부모 엘리먼트의 hover를 받아 자식 엘리먼트에 적용시킬 수 있다.<br>
예를 들어 부모 엘리먼트의 hover를 통해 자식 엘리먼트의 display를<br>
hidden에서 block으로 변경하는 경우에 사용한다.<br>
부모 엘리먼트에는 group을 작성하고<br>
자식 엘리먼트는 group-hover를 통해 사용한다.<br><br>부모 엘리먼트에 group을 할 떄 뒤에 /{그룹명}을 작성하여 그룹을 구분 할 수 있다.<br>
자식 엘리먼트에서는 group-hover/{그룹명} 으로 사용한다.]]></description><link>컴퓨터 공학\인터넷\web\front end\테일윈드\테일윈드 Group.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/테일윈드/테일윈드 Group.md</guid><pubDate>Fri, 20 Jun 2025 01:15:14 GMT</pubDate></item><item><title><![CDATA[<a data-href="테일윈드" href="컴퓨터 공학/인터넷/web/front end/테일윈드/테일윈드.html" class="internal-link" target="_self" rel="noopener nofollow">테일윈드</a>]]></title><description><![CDATA[ 
 <br>Cascading Style Sheet<br>
HTML을 꾸며주는 녀석<br>전통방식과 테일윈드방식이 있다.<br>
스타일 시트의 표준이며 현재 CSS3가 사용된다.<br>
문서 작성과 디자인을 분리해서 효율적으로 웹페이지를 개발할 수 있다.<br><br>AI가 더 잘 뽑아준다.<br><br><br>HTML Element에게 폰트를 설정하면 자식에게도 폰트가 설정됨<br>
가변 다이나믹 서브셋을 하면 성능이 좋아짐<br>]]></description><link>컴퓨터 공학\인터넷\web\front end\CSS\CSS.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/CSS/CSS.md</guid><pubDate>Tue, 17 Jun 2025 00:06:12 GMT</pubDate></item><item><title><![CDATA[justify-content]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br><br> <a data-tooltip-position="top" aria-label="https://codepen.io/enxaneta/full/adLPwv/" rel="noopener nofollow" class="external-link" href="https://codepen.io/enxaneta/full/adLPwv/" target="_blank">링크</a>]]></description><link>컴퓨터 공학\인터넷\web\front end\CSS\CSS Flex.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/CSS/CSS Flex.md</guid><pubDate>Tue, 01 Jul 2025 05:29:22 GMT</pubDate></item><item><title><![CDATA[position]]></title><description><![CDATA[ 
 <br><br><br>겹치는게 불가능하다.<br><br>겹치는것이 불가능하다.<br><br>너비가 최소화 된다.<br>
겹치는 것이 가능하다.<br><br>absolute를 붙이기 전 위치에 있는다.<br><br>너비가 최소화 된다.<br>
겹치는 것이 가능하다.]]></description><link>컴퓨터 공학\인터넷\web\front end\CSS\CSS Position.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/CSS/CSS Position.md</guid><pubDate>Fri, 13 Jun 2025 00:43:39 GMT</pubDate></item><item><title><![CDATA[태그로 특정]]></title><description><![CDATA[ 
 <br><br>A {}<br><br>#A로  엘리먼트를 특정한다.<br><br>.A로 엘리먼트를 특정한다.<br>
A.B 처럼 앞에 태그명을 넣을 수 있다.<br><br>A B 로 작성하면  자식 중 해당 조건을 만족하는 엘리먼트를 특정한다.<br>
예시)<br>plate apple
<br>A &gt; B로 바로 다음으로 오는 자식을 선택한다.<br>A:first-child 로 형제 중 첫번째를 선택한다.<br><br>A, B의 방식으로 여러개를 동시에 선택 가능하다.<br><br>'*' 를 통해 모든 엘리먼트 선택이 가능하다<br><br>A+B를 통해 A 다음에 있는 B를 선택한다.<br>A~B를 통해 A 다음에 있는 여러개를 선택한다.]]></description><link>컴퓨터 공학\인터넷\web\front end\CSS\CSS Selector.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/CSS/CSS Selector.md</guid><pubDate>Tue, 17 Jun 2025 00:18:03 GMT</pubDate></item><item><title><![CDATA[Custom Hook]]></title><description><![CDATA[ 
 <br>useState, useRef와 같이 만들 수 있는데 <br>기본 훅을 사용하는 코드를 분리시키려고 할 때 사용한다.<br>use를 함수명 앞부분에 작성하여 React가 이 함수가 Hook이라는 것을 인식하게 한다.]]></description><link>컴퓨터 공학\인터넷\web\front end\react\Custom Hook.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/react/Custom Hook.md</guid><pubDate>Wed, 25 Jun 2025 01:19:00 GMT</pubDate></item><item><title><![CDATA[태그 정의]]></title><description><![CDATA[ 
 <br>리엑트에 HTML코드를 사용할 수 있음<br>
하려면 babel이라는 최신 javascript가 필요<br><br>function element(){
	return &lt;a&gt;element&lt;/a&gt;
}
]]></description><link>컴퓨터 공학\인터넷\web\front end\react\JSX.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/react/JSX.md</guid><pubDate>Wed, 28 May 2025 01:17:28 GMT</pubDate></item><item><title><![CDATA[React 란?]]></title><description><![CDATA[ 
 <br><br><a data-href="DOM" href="컴퓨터 공학\인터넷\web\front end\DOM.html" class="internal-link" target="_self" rel="noopener nofollow">DOM</a>을 만드는 애<br>
<a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>를 통해 HTML을 작성하게 한다.<br><br>함수 안에 HTML을 작성해 직관적으로 변경하려면 <a data-href="JSX" href="컴퓨터 공학\인터넷\web\front end\react\JSX.html" class="internal-link" target="_self" rel="noopener nofollow">JSX</a><br>7react를 통해 나만의 태그를 만들 수 있음<br><br>&lt;&gt;
	내용
&lt;/&gt;
<br>이렇게 작성 가능<br><br>function App(){
	const links =[
		{
			href:...,
			text:...
		}
		...
	];
	return (
		&lt;ul&gt;
			{links.map(
				(link, index) =&gt; (
					&lt;li key={link.text}&gt;
						&lt;a href={link.href}&gt;{index+1} : {link.text}&lt;/a&gt;
				))
			)}
		&lt;/ul&gt;	
	)
}
<br>이런식으로 작성 가능<br>
map으로 만들어지는 엘리먼트의 최상위는 key값으로 unique 해야한다고 함<br>
키에 index를 넣어도 되는데 추천하지는 않고 link.text로도 충분히 unique한 경우 link.text를 쓰는게 좋음<br><br>function text(){
	return &lt;a style={{color:red, display:"inline"}}&gt;테스트&lt;/a&gt;;
}
<br>이런식으로 작성해야 함<br>
중괄호는 기본적으로 있고<br>
객체 표현식으로 값을 넘겨준거임<br>]]></description><link>컴퓨터 공학\인터넷\web\front end\react\React.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/react/React.md</guid><pubDate>Mon, 09 Jun 2025 00:47:41 GMT</pubDate></item><item><title><![CDATA[React 변수]]></title><description><![CDATA[ 
 <br>변수가 변경되어도 이는 바로 반영되지 않는다.<br>
함수의 UI와 관련된 변수가 변경되면 함수를 다시 실행시켜 변경사항을 반영한다.<br>
사용하는 방법은<br>function App(){
	const [number, setNumber] = React.useState(0); // 변수 정의
	setNumber(number+1); // 값 변경
}
<br>이런 식으로 사용이 가능하고 변경이 발생하면<br>
React는 해당 함수를 다시 실행시켜(최적화도 같이 하고) 값의 변경을 반영시킨다.<br><br>function Link(props){
	const {href, text} = props;
}
<br>function Link({href, text}){
	return &lt;a href={href}&gt;{text}&lt;/a&gt;
}
<br>이렇게도 가능<br><br>함수의 매개변수를 통해 중복을 줄일 수 있음<br>function Link(props){
  return (
    &lt;a className="text-red-500 underline hover:text-red-300" href={props.href} target="_blank"&gt;{props.text}&lt;/a&gt;
  );
}
<br>&lt;Link text="네이버" href="https://www.naver.com"/&gt;
<br>이렇게 매개변수로 넘겨 줄 수 있음]]></description><link>컴퓨터 공학\인터넷\web\front end\react\React 변수.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/react/React 변수.md</guid><pubDate>Mon, 09 Jun 2025 00:47:45 GMT</pubDate></item><item><title><![CDATA[Document Object Model]]></title><description><![CDATA[ 
 <br><br>예시로 HTML을 해석하면 DOM이 만들어짐<br>HTML을 트리의 형태로 만듬 이를 DOM이라고 부르고<br>
각 요소를 Node라고 부름<br>
자바스크립트로 이걸 제어할 수 있는데 가능한 이유는 모두 API이기 때문이다.<br><br>브라우저에서 일어날 수 있는 것을 프로그래밍 할 수 있도록 제공한것이고<br><br>DOM과BOM을 합쳐 WEB API라고 부른다.]]></description><link>컴퓨터 공학\인터넷\web\front end\DOM.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/DOM.md</guid><pubDate>Wed, 18 Jun 2025 07:55:31 GMT</pubDate></item><item><title><![CDATA[Front-End]]></title><description><![CDATA[ 
 <br>웹에서 사용자와 직접 접촉하여 상호작용하는 실제 보여지는 웹 페이지를 개발하는 것이다.<br>
간단하게<br>
<a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>로 웹 페이지의 뼈대를 구성하고<br>
<a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>로 웹페이지의 스타일을 구성하고<br>
<a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>로 사용자와 상호작용을 가능하게 하여 동적인 웹 페이지를 구성한다.]]></description><link>컴퓨터 공학\인터넷\web\front end\Front-End.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/front end/Front-End.md</guid><pubDate>Tue, 17 Jun 2025 14:53:24 GMT</pubDate></item><item><title><![CDATA[검색 엔진 최적화란?]]></title><description><![CDATA[ 
 <br><br>크롤링, 인덱신, 랭킹 과정이 원활하게 이루어지도록 웹사이트를 최적화하는 모든 작업<br>웹사이트가 더 많은 사용자에게 노출될 수 있도록 만드는 전략이다.<br><br>크롤링을 통해 데이터를 가져오고<br>
검색 엔진의 알고리즘에 의해 평가한다.<br>
평가 기준은 콘텐츠 품질과 사용자 경험 등이 된다.<br>검색엔진이 웹사이트를 제대로 크롤링 할 수 있도록 사이트 구조와 접근성을 개선한다.<br><br>웹사이트에 있는 페이지, 동영상, 이미지 등의 콘텐츠와 그 관계에 대한 정보를 제공하는 파일이다.<br><br>크롤러가 웹사이트 및 페이지에 접근할 때 콘텐츠를 수집할 수 있도록 허용하거나 제한하는 파일이다.<br><br>사용자가 잘못된 URL을 입력하거나 더 이상 사용할 수 없는 URL을 입력하는 경우 나타난다.<br>
크롤러가 깨진 링크를 발견하면 검색 엔진은 웹사이트의 품질을 낮게 평가한다.<br><br>]]></description><link>컴퓨터 공학\인터넷\web\검색 엔진 최적화.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/검색 엔진 최적화.md</guid><pubDate>Thu, 03 Jul 2025 08:48:44 GMT</pubDate></item><item><title><![CDATA[웹 크롤링]]></title><description><![CDATA[ 
 <br>웹 페이지에 접속해서 데이터를 가져오는 기술을 말한다.]]></description><link>컴퓨터 공학\인터넷\web\웹 크롤링.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/웹 크롤링.md</guid><pubDate>Mon, 30 Jun 2025 07:22:52 GMT</pubDate></item><item><title><![CDATA[정적 웹]]></title><description><![CDATA[ 
 <br><br>프로그래머가 작성한 코드가 그대로 화면에 표시하는 웹<br><br>접속할 때마다 매번 바뀌는 웹<br>
매번 잘 변하지 않는 페이지는 동적 웹에서 정적 웹으로 변환하기도 한다.<br>
동적 웹으로 변환할 때 Jekyll이나 Hugo 같은 툴을 사용한다.]]></description><link>컴퓨터 공학\인터넷\web\정적 웹, 동적 웹.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/web/정적 웹, 동적 웹.md</guid><pubDate>Sun, 08 Jun 2025 13:53:02 GMT</pubDate></item><item><title><![CDATA[WWW]]></title><description><![CDATA[ 
 <br><br>World Wide Web<br>
하이퍼텍스트와 멀티 미디어를 통해 서비스를 이용할 수 있도록 구축되어있다.<br>
사용자끼리 정보를 공유할 수 있다.<br><br><br>클라이언트가 웹 서버에 정보를 요청한 후 서버에서 보낸 정보를 담고 있는 문서<br><br>HTML로 작성된 웹 페이지를 해석하여 사용자에게 보여줌<br>
일종의 컴파일러로 생각 가능, W3C에서 이에 대한 표준을 제공함<br>
Chorme, Internet Explorer, Microsoft Edge, Firfox, Safari, Whale<br><br>World Wide Web Consortium<br>
여러 참여 기관이 협력해 웹 표준을 개발한다.<br><br><a data-href="Back-End" href="컴퓨터 공학\인터넷\web\back end\Back-End.html" class="internal-link" target="_self" rel="noopener nofollow">Back-End</a>와 <a data-href="Front-End" href="컴퓨터 공학\인터넷\web\front end\Front-End.html" class="internal-link" target="_self" rel="noopener nofollow">Front-End</a>가 있다.<br><br>주로 <a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>, <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>, <a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>언어를 사용한다.]]></description><link>컴퓨터 공학\인터넷\웹과 인터넷 개념.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/웹과 인터넷 개념.md</guid><pubDate>Fri, 06 Jun 2025 02:35:45 GMT</pubDate></item><item><title><![CDATA[인터넷의 시작]]></title><description><![CDATA[ 
 <br><br>1960년도에 시작함<br>소련과 미국이 견제하고 있던 때에 국방 프로젝트에서 만들어졌다.<br><br>1990년도에 시작함<br>팀 버너스리가 제작함<br>
정보 소통 방법을 만들려고 함<br>web server, web client, <a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>, <a data-href="HTTP" href="컴퓨터 공학\인터넷\web\back end\서버\HTTP\HTTP.html" class="internal-link" target="_self" rel="noopener nofollow">HTTP</a> 제작함<br><br>웹, 이메일, <a data-href="FTP" href="컴퓨터 공학\프로그램\SSH\FTP.html" class="internal-link" target="_self" rel="noopener nofollow">FTP</a> 등을 포함한다.]]></description><link>컴퓨터 공학\인터넷\인터넷과 웹의 역사.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/인터넷과 웹의 역사.md</guid><pubDate>Fri, 06 Jun 2025 02:19:05 GMT</pubDate></item><item><title><![CDATA[Domain Name System]]></title><description><![CDATA[ 
 <br><br>IP주소는 숫자로 이루어져 있음 그래서 이걸 외우기는 힘드니<br>
알파벳으로 외우기 쉽게 변경함<br>이 도메인 정보를 저장하는 곳이 있는데<br>
일단 내 컴퓨터에 저장이 되어 있고<br>
내 컴퓨터에 없으면 루트 DNS 서버로 접속해 DNS의 정보를 어디서 얻을 수 있는지 알아옴<br>예시를 들면 www.naver.com 이라는 도메인의 주소를 알아오려면 Local을 먼저 확인 후 Root DNS 서버에 접속을 해서 .com 의 위치를 알아온 후 .com에서는 naver.com의 위치를 알아오고 naver.com에서는 www.naver.com의 위치를 알게됨<br><br>다른 사람이 DNS 정보를 가져오려 할 때 다른 사이트의 정보를 줘서 연결 시키는 해킹 수법<br><br><br>도메인과 주소를 바로 연결하는 것<br><br>IP가 유동적으로 변할 경우<br>
그 IP와 일정적으로 연결되는 IP로 연결하는 것]]></description><link>컴퓨터 공학\인터넷\DNS.html</link><guid isPermaLink="false">컴퓨터 공학/인터넷/DNS.md</guid><pubDate>Wed, 04 Jun 2025 14:27:12 GMT</pubDate></item><item><title><![CDATA[리누스 토발즈]]></title><description><![CDATA[ 
 <br><a data-href="리눅스" href="컴퓨터 공학\운영체제\종류\리눅스\리눅스.html" class="internal-link" target="_self" rel="noopener nofollow">리눅스</a>를 만들었다.<br>
<a data-href="Git" href="컴퓨터 공학\프로그램\버전관리\Git\Git.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a>을 만들었다.]]></description><link>컴퓨터 공학\중요한 인물\리누스 토발즈.html</link><guid isPermaLink="false">컴퓨터 공학/중요한 인물/리누스 토발즈.md</guid><pubDate>Thu, 03 Jul 2025 08:17:06 GMT</pubDate></item><item><title><![CDATA[빌 게이츠]]></title><description><![CDATA[ 
 <br>Microsoft의 창업주다.]]></description><link>컴퓨터 공학\중요한 인물\빌 게이츠.html</link><guid isPermaLink="false">컴퓨터 공학/중요한 인물/빌 게이츠.md</guid><pubDate>Thu, 03 Jul 2025 08:16:49 GMT</pubDate></item><item><title><![CDATA[튜링 머신]]></title><description><![CDATA[ 
 <br>컴퓨터과학의 아버지다.<br><br>앨런 튜링이 1936년에 제시한 개념으로 계산하는 기계의 일반적인 개념을 설명하기 위한 가상의 기계며 오토마타의 일종이다.]]></description><link>컴퓨터 공학\중요한 인물\앨런 튜링.html</link><guid isPermaLink="false">컴퓨터 공학/중요한 인물/앨런 튜링.md</guid><pubDate>Thu, 03 Jul 2025 08:25:09 GMT</pubDate></item><item><title><![CDATA[팀 버너스리]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\중요한 인물\팀 버너스리.html</link><guid isPermaLink="false">컴퓨터 공학/중요한 인물/팀 버너스리.md</guid><pubDate>Thu, 03 Jul 2025 08:15:44 GMT</pubDate></item><item><title><![CDATA[폰 노이만 구조]]></title><description><![CDATA[ 
 <br>폰 노이만 구조를 만들었다.<br><br>중앙처리장치, 메모리, 프로그램으로<br>
CPU와 메모리를 분리시켜<br>
실행 코드와 데이터를 메모리에 넣고 실행하는 구조다.<br>그리고 이 구조는 거의 모든 컴퓨터가 따르고 있는 구조다.]]></description><link>컴퓨터 공학\중요한 인물\폰 노이만.html</link><guid isPermaLink="false">컴퓨터 공학/중요한 인물/폰 노이만.md</guid><pubDate>Thu, 03 Jul 2025 08:23:45 GMT</pubDate></item><item><title><![CDATA[논리 회로 구현]]></title><description><![CDATA[ 
 <br><a data-href="AND" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\AND.html" class="internal-link" target="_self" rel="noopener nofollow">AND</a>, <a data-href="OR" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\OR.html" class="internal-link" target="_self" rel="noopener nofollow">OR</a>, <a data-href="NOT" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\NOT.html" class="internal-link" target="_self" rel="noopener nofollow">NOT</a>을 만들면 모든 회로를 만들 수 있습니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\논리 회로 구현.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/논리 회로 구현/논리 회로 구현.md</guid><pubDate>Sun, 22 Jun 2025 05:34:09 GMT</pubDate></item><item><title><![CDATA[AND]]></title><description><![CDATA[ 
 <br>직선을 그어서 두개의 점을 찍고 거기에 반도체를 넣고<br>
(그러니까 직렬로 연결한 모습이죠)<br>
한쪽 끝에는 5V를 연결하고 한쪽에는 저항과 GND를 연결하면<br>
두개의 반도체에 전기를 보내서 반도체가 전기가 흐르게 할 때만 전기가 흐르겠죠?]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\AND.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/논리 회로 구현/AND.md</guid><pubDate>Sun, 22 Jun 2025 05:50:51 GMT</pubDate></item><item><title><![CDATA[NOT]]></title><description><![CDATA[ 
 <br>입력값과 출력값과 5V와 GND가 있을 때<br>
5V와 낮은 저항과 GND를 연결하고<br>
5V와 낮은 저항 사이에 높은 저항과 출력값을 연결하면<br>전기를 안보내면 GND와 연결되지 않아 유일한 출구가 출력값 방향이기에 출력값 방향으로 흐릅니다.<br>
전기를 보내면 GND 방향이 좀더 낮은 저항이기에 전기가 GND 방향으로 흘러서 출력값에는 낮은 전력이 흐릅니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\NOT.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/논리 회로 구현/NOT.md</guid><pubDate>Sun, 22 Jun 2025 06:06:34 GMT</pubDate></item><item><title><![CDATA[OR]]></title><description><![CDATA[ 
 <br>반도체 A,B가 있을 때<br>
5V를 각각 반도체에 연결하고 그걸 하나로 연결하고 그걸 저항과 GND에 연결하면<br>
둘 중 하나의 반도체에 전기를 보내면 전기가 흐르겠죠?]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\논리 회로 구현\OR.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/논리 회로 구현/OR.md</guid><pubDate>Sun, 22 Jun 2025 05:54:20 GMT</pubDate></item><item><title><![CDATA[양자]]></title><description><![CDATA[ 
 <br>양성자와 전자가 서로 다른 극을 띄기에 서로 잡아당기는데 왜 서로 떨어져있을까에서 생각해낸 이론으로<br>세상은 소수의 값으로 이뤄진게 아니라 정수의 값으로 이뤄졌다는 이론입니다.<br>그러니까 현재 양성자와 전자가 가장 가까운 거리가 1이라고 하면 전자가 0.5의 위치로 갈 수가 없다는 거에요.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\전자\양자.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/전자/양자.md</guid><pubDate>Sun, 22 Jun 2025 05:47:47 GMT</pubDate></item><item><title><![CDATA[저항]]></title><description><![CDATA[ 
 <br>전기는 저항이 낮은 곳으로 흐르려는 경향이 있습니다.<br>어떤 원리인지 상상이 안되면<br>
커다란 물통이 있는데 구멍을 두 개를 뚫을 겁니다.<br>하나는 작게, 하나는 크게 구멍을 뚫어봅시다.<br>
어느 구멍으로 빠져나가는 물이 많을까요?<br>
구멍이 큰곳으로 많이 빠져나가겠죠?<br>
구멍이 큰게 저항이 낮은 겁니다.<br><br>저항이 있으면 전기에너지가 열에너지로 바뀌는데<br>
높으면 높을 수록 열에너지로 바뀌는 양이 많습니다.<br>
이걸 사용하면 전구를 만들 수 있습니다.<br>
열에너지가 높으면 빛을 방출하거든요.<br><br>저항의 의미는 전자가 지나가다가 원소와 부딪히는 것을 의미합니다.<br>
그래서 속도가 줄어들면서 교통체증이 발생해 전자들이 밀집하게 되죠.(라고 생각하면 좋아요.)<br>
물체 두 개가 서로 충돌하면 탱탱 볼처럼 충격을 흡수하고 그 충격을 100퍼센트 내보내는 탄성력을 가지지 않는 한 일부만 내보내게 됩니다. 그리고 에너지 보존의 법칙으로 인해 일부는 열에너지로 바뀝니다.<br>
따라서 저항이 있으면 열을 발생합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\전자\저항.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/전자/저항.md</guid><pubDate>Tue, 24 Jun 2025 08:27:57 GMT</pubDate></item><item><title><![CDATA[전류]]></title><description><![CDATA[ 
 <br>전체적으로 얼마의 전기가 흐르는지를 말합니다.<br>전류가 낮은데 아무리 전압을 올려도 위협적이지 않습니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\전자\전류.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/전자/전류.md</guid><pubDate>Sun, 22 Jun 2025 06:05:44 GMT</pubDate></item><item><title><![CDATA[전압]]></title><description><![CDATA[ 
 <br>얼마나 전자가 한번에 많이 흐르는지를 의미합니다.<br>
저항이 높아지면 압축되니까 전압도 올라갑니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\전자\전압.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/전자/전압.md</guid><pubDate>Sun, 22 Jun 2025 06:04:54 GMT</pubDate></item><item><title><![CDATA[전자]]></title><description><![CDATA[ 
 <br>전기는 흐르는 유체입니다.<br>
전기는 도체를 매개로 흐릅니다.<br>도체가 서로 닿아있으면 연결됩니다.<br>전자는 빈 공간으로 이동합니다.<br>
이 빈공간을 양공이라고 부릅니다.<br>전기의 흐름을 이야기 할 때 보통 양공의 움직임 방향을 말합니다.<br>
따라서 전자의 흐름과 반대 방향입니다.<br>전자는 음극을 띄기 때문에 전자끼리는 서로 밀어내는 힘을 가집니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\전자\전자.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/전자/전자.md</guid><pubDate>Fri, 27 Jun 2025 08:19:09 GMT</pubDate></item><item><title><![CDATA[다이오드]]></title><description><![CDATA[ 
 <br><a data-href="반도체" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\반도체.html" class="internal-link" target="_self" rel="noopener nofollow">반도체</a>중 P형 반도체와 N형 반도체를 붙여둔걸 말합니다.<br>그러니 N형 반도체의 자유 전자가 P형 반도체의 빈공간으로 이동하려는 경향을 보이겠죠?<br>
그래서 전자의 흐름을 한 방향으로만 흐르게 하는 겁니다.<br>
흐름을 만든 것이지 역으로 흐르는 것을 완전히 다 막을 수는 없습니다.<br>광전현상이라는 것이 있습니다. 다이오드에 전기를 보내면 빛을 내는 효과를 말하는데<br>
이를 활용한 것이 LED(Light Emit Diod)]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\다이오드.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/다이오드.md</guid><pubDate>Sun, 22 Jun 2025 05:30:02 GMT</pubDate></item><item><title><![CDATA[반도체]]></title><description><![CDATA[ 
 <br>약간 화학의 이야기도 섞어서 이야기할 예정입니다.<br>반도체를 만들 때 Si 규소로 만듭니다.<br>
이 규소를 다르게 부르면 유리입니다.<br>
전기가 흐르려면 자유전자가 이동할 공간이 필요합니다.<br>
하지만 규소는 빈공간 없이 공유 결합되어 있기에 빈 공간을 억지로라도 만들어줘야 전기가 흐를 수 있게 됩니다.<br>그러기에 3족 원소를 넣어 빈공간을 만든게 P형 반도체<br>
5족 원소를 넣어 자유전자를 만든게 N형 반도체라고 합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\반도체.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/반도체.md</guid><pubDate>Sat, 05 Jul 2025 00:22:56 GMT</pubDate></item><item><title><![CDATA[에너지 띠]]></title><description><![CDATA[ 
 <br>도체, 부도체, 반도체에는 에너지 띠를 가지는데<br>
절대 온도0K에서는 고체의 전자들은 가장 낮은 에너지 준위부터 차례대로 채워진다.<br>
에너지 띠가 전자로 완전히채워져 있다면 이 에너지 띠를 원자가 띠라고 한다.<br>
전자가 아예 채워져 있지 않거나 덜 차있는 띠를 전도 띠라고 한다.<br>원자가 띠에서는 전자가 이동하기 힘들다. 전자가 전도띠로 넘어가면 전자는 마음대로 이동할 수 있다.<br>
전도띠로 넘어가려면 충분한 에너지를 주입시켜야 한다.<br>원자가 띠와 전도 띠의 사이의 틈을 띠 틈이라고 한다.<br>도체는 원자가 띠를 다 채우지 않았거나 원자가 띠와 전도 띠가 겹쳐서 전자가 비교적으로 자유롭게 이동할 수 있는 고체를 말한다.<br>부도체는 띠 틈이 너무 넓어서 상온에서는 어떤 전자도 전도띠로 넘어갈 수 없는 고체다.<br>반도체는 도체보다는 띠 틈이 넓고 부도체 보다는 좁아서 상온에서 전자가 전도 띠로 전이할 가능성이 있다.<br>반도체의 예시로는 도핑한 규소이다.<br>
규소 그 자체는 부도체에 가깝다.<br>
하지만 규소에 불순물을 첨가하는 도핑 행위를 통해 반도체가 된다.<br>
<br>n형 반도체:<br>
불순물로 5족 원소(예: 인, 비소)를 주입하여 전자를 다수 운반자로 갖는 반도체입니다.&nbsp;이 때, 불순물 원자의 원자가 전자가 전도띠로 쉽게 전이될 수 있는 에너지 준위(donor level)가 추가됩니다.&nbsp;<br>

<br>p형 반도체:<br>
불순물로 3족 원소(예: 붕소, 알루미늄)를 주입하여 양공(전자가 없는 자리)을 다수 운반자로 갖는 반도체입니다.&nbsp;이 때, 불순물 원자의 원자가 전자가 부족하여 원자가 띠 위쪽에 acceptor level이 추가되고, 이 곳으로 전자가 쉽게 이동하여 양공이 생성됩니다.
<br>출처 <a data-tooltip-position="top" aria-label="https://gooseskin.tistory.com/m/131" rel="noopener nofollow" class="external-link" href="https://gooseskin.tistory.com/m/131" target="_blank">링크</a>]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\에너지 띠.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/에너지 띠.md</guid><pubDate>Sat, 05 Jul 2025 08:50:38 GMT</pubDate></item><item><title><![CDATA[트랜지스터]]></title><description><![CDATA[ 
 <br><a data-href="반도체" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\반도체.html" class="internal-link" target="_self" rel="noopener nofollow">반도체</a>중 P형 반도체와 N형 반도체와 P형 반도체를 샌드위치처럼 연결해두거나<br>
N형, P형, N형의 형태로 연결해둔 것을 말하고<br>세면대를 생각하면 좋습니다.<br>
바닥 부분에 구멍이 있고 벽 부분에 구멍이 하나 더 있는 세면대요.<br>평소에는 바닥의 구멍으로 물이 빠지는데 만약 물이 너무 많아서 바닥의 구멍 만으로 물이 안빠지는 경우 물이 차오르다가 벽 부분의 구멍으로 물이 빠지죠.<br>그런 효과를 만들어냅니다.<br>이걸 사용해 전기를 보내면 전기를 흐르게 하고 전기를 보내지 않으면 전기를 흐르지 않게 하는 것도 가능합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\반도체\트랜지스터.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/반도체/트랜지스터.md</guid><pubDate>Sun, 22 Jun 2025 05:31:14 GMT</pubDate></item><item><title><![CDATA[2의 보수]]></title><description><![CDATA[ 
 <br><a data-href="이진수" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\이진수.html" class="internal-link" target="_self" rel="noopener nofollow">이진수</a>로 음수를 표현할 때 사용하는 방법으로<br>0과 1을 반대로 바꾸고 1을 더한 방법이다.<br>
0010을 바꾸면  1101로 바꾸고 1을 더해 1110이 된다.<br>그럼 -2와 2를 더해보자 그럼 0000이 나오면 된다.<br>
10010이 되는거 아닌가 생각할 수 있는데 초과하는건 무시한다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\2의 보수.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/전가산기/2의 보수.md</guid><pubDate>Sun, 22 Jun 2025 12:24:39 GMT</pubDate></item><item><title><![CDATA[Normalize]]></title><description><![CDATA[ 
 <br>부호부, 지수부, 소수부로 이루어진 구조다.<br>
부호부로 양수인지 음수인지 알 수 있고<br>
지수부는 비교하기 편하기 위해 일정 값을 더한다.<br>
그래서 1~지수부 최대값/2은 음수를 의미하고<br>
지수부 최대값/2+1 ~ 지수부 최대값-1은 양수를 의미한다.<br>
0과 지수부 최대값은 다른 용도가 있다.<br>
이 방식을 통해 엄청 작은 수와 엄청 큰 수를 표현 가능하다.<br>
물론 그 만큼 손실되는 값도 존재한다.<br><br>normalize를 하는 이유는 어차피 정수부에는 1을 둘 것이다.<br>
그러면 굳이 이 1을 저장할 필요가 있을까? 라는 의문에서 시작된 것으로<br>
정수부의 1을 제외시키고 저장을 시킨다.<br>
만약에 정수부가 0이 되는 일이 발생한다면 위에서 말한 지수부에서 0 또는 최대값을 이용해서 표현한다.<br><br>두 개의 부동 소수점의 계산을 하기 위해서 한 부동 소수점의 지수 값을  다른 부동 소수점의 지수 값에 맞추고 계산해야 한다. 그리고 부호에 맞게 계산을 해주고 다시 Normalize 하는 과정을 거치는데<br>
더하기 연산도 이렇게 복잡하다.<br><br>숫자는 2진법으로만 계산이 가능하고 우리가 연산하고자 하는건 10진수 이므로<br>
정수 계산이라면 문제 없이 계산이 가능하지만 소수로 변경하면<br>
대부분 무한히 그 숫자로 다가가는 소수가 만들어진다.<br>
그리고 무한히 반복되는 소수도 컴퓨터에서는 한정적인 메모리 공간을 가지므로 근사값만 저장할 수 있다.<br>
그러니까 예시를 들면<br>
컴퓨터에서 0.1 + 0.2 = 0.3 이 식이 성립하지 않는다.<br>
왜냐하면 0.1, 0.2, 0.3 모두 근사값이기 때문에 일치하지 않는다.<br>
따라서 은행에서 개발자로 일하는데 잔고의 금액을 부동 소수점으로 저장하게 만들면<br>
실제 금액과 조금씩 차이가 발생하면서 큰 문제가 발생할 수 있다.<br>
따라서 이러한 경우에는 정수를 사용하여서 문제가 발생하지 않게 해두는 것이 좋을 것이다.<br><br>부호 비트 하나와 정수부, 소수부 나눈 것<br>
이 경우 큰 수를 표현 못함]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\부동 소수점.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/전가산기/부동 소수점.md</guid><pubDate>Mon, 30 Jun 2025 08:12:49 GMT</pubDate></item><item><title><![CDATA[언더 플로우]]></title><description><![CDATA[ 
 <br>부동 소수점의 숫자가 너무 작아서 지수 값이 범위를 벗어나버리는 현상을 말한다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\언더 플로우.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/전가산기/언더 플로우.md</guid><pubDate>Mon, 30 Jun 2025 08:08:08 GMT</pubDate></item><item><title><![CDATA[오버 플로우]]></title><description><![CDATA[ 
 <br>저장할 수 있는 수의 범위를 초과했을 때 발생한다.<br>
현실에는 무한한 크기의 숫자를 저장할 수 없기에 한계가 존재한다.<br>
예를들어 부호가 있는 1바이트의 경우 128는 범위에 벗어나기에 오버플로우가 발생하면 -127이 된다.<br>
0111 1111에 1을 더하면 1000 0000이 되는데 이는 -128이다.<br>
반대로 -128에서 -1을 해도 127이된다. 이것도 오버플로우라고 한다.<br>언더플로우랑 헷갈릴 수는 있다.<br>
하지만 정수에서 일어나는 것은 정수 언더플로라고 명칭해야한다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\오버 플로우.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/전가산기/오버 플로우.md</guid><pubDate>Mon, 30 Jun 2025 08:03:28 GMT</pubDate></item><item><title><![CDATA[이진수]]></title><description><![CDATA[ 
 <br>사람이 보통 쓰는 숫자 진수는 10진수입니다.<br>
하지만 어느 수학자가 2진수로도 충분히 숫자를 계산하는데 사용할 수 있다는 연구를 하셔서<br>
컴퓨터가 이진수로 계산을 하게되었습니다.<br>10진수를 2진수로 표현하려면 2의 제곱 수를 더해서 해당 수를 만들어 내면 된다.<br>
예를 들어 10을 이진수로 나타내려면 8 + 2로 2^3 + 2^1 = 1010이다.<br>이제 음수를 표현해야하는데 음수를 표현하기 위해 <a data-href="2의 보수" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\2의 보수.html" class="internal-link" target="_self" rel="noopener nofollow">2의 보수</a>를 사용한다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\이진수.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/전가산기/이진수.md</guid><pubDate>Sun, 22 Jun 2025 12:20:45 GMT</pubDate></item><item><title><![CDATA[전가산기]]></title><description><![CDATA[ 
 <br>입력값으로는 Carry, A, B를 받고<br>
출력값으로는 Carry, Sum값을 출력한다.<br>출력값 Carry의 경우 입력값 Carry, A,B 중 2개 이상 1의 신호를 가지면 1의 출력을 가지고 그 외의 경우 0의 값을 가진다.<br>
출력값 Sum의 경우 입력값 Carry, A, B 중 1,3개가 1의 신호를 가지면 1의 출력을 가지고 그 외의 경우 0의 값을 가진다.<br>이 전가산기는 여러 개가 같이 연결되어서 돌아간다.<br>
출력값의 Carry는 다음 전가산기의 입력 Carry의 값으로 들어가면서 숫자 연산이 된다.<br>0번째 입력 Carry에 들어가는 값은 뺄셈을 할 때 사용하는데<br>
뺄 값을 xor을 통해 0과 1을 바꾸고 0번째 입력 Carry에 1을 넣어 <a data-href="2의 보수" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\2의 보수.html" class="internal-link" target="_self" rel="noopener nofollow">2의 보수</a>를 만들어 뺄셈을 한다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\전가산기\전가산기.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/전가산기/전가산기.md</guid><pubDate>Thu, 26 Jun 2025 07:56:54 GMT</pubDate></item><item><title><![CDATA[디지털 논리 회로]]></title><description><![CDATA[ 
 <br>디지털 논리 회로는 컴퓨터의 간단한 회로에 대해서 다룰 생각입니다.<br>5V값과 0.3V값으로 예시를 드는데 각각 true, false를 의미합니다.<br>
High, Low로 부르기도 합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\디지털 논리 회로.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/디지털 논리 회로.md</guid><pubDate>Sun, 22 Jun 2025 06:17:28 GMT</pubDate></item><item><title><![CDATA[D-Flip-Flop]]></title><description><![CDATA[ 
 <br><a data-href="Latch" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\Latch.html" class="internal-link" target="_self" rel="noopener nofollow">Latch</a>에 입력 값을 넣고 클럭을 작동 시키면 출력값에 반영되는 방식이다.<br>
여러가지 Flip-Flop이 있는데<br><br>D-Flip-Flop의 경우 입력값이 D, Clock이고 출력값이 Q, Q' 라고 하면<br>
D가 High고 한 클럭이 지나면 Q의 값이 High가 된다.<br>
D가 Low고 한 클럭이 지나면 Q의 값이 Low가 된다.<br><br>T-Flip-Flop의 경우 입력값이 T, Clock이고 출력값이 Q, Q'면<br>
T가 High고 한 클럭이 지나면 지난 Q의 반대 값이 된다.<br>
T가 Low고 한 클럭이 지나면 결과 값은 변하지 않는다.<br>
T가 의미하는게 Toggle이다.<br>
이건 카운터에 쓰기에 좋다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\Flip-Flop.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/Flip-Flop.md</guid><pubDate>Thu, 26 Jun 2025 08:02:09 GMT</pubDate></item><item><title><![CDATA[Latch]]></title><description><![CDATA[ 
 <br>NAND나 NOR을 두 개를 놓고 출력값을 반대편쪽의 입력값으로 입력시킵니다.<br>그러면 항상 둘 중 하나의 출력값이 High이고 반대는 Low값을 가지게 됩니다.<br>NAND나 NOR 중 하나는 한 입력값에 Low에서 High로 가면 값이 변하거나<br>
High에서 Low로 갈 때 변하기도 합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\Latch.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/디지털 논리 회로/Latch.md</guid><pubDate>Sun, 22 Jun 2025 06:22:07 GMT</pubDate></item><item><title><![CDATA[레지스터]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="Flip-Flop > D-Flip-Flop" data-href="Flip-Flop#D-Flip-Flop" href="컴퓨터 공학\컴퓨터 구조\디지털 논리 회로\Flip-Flop.html#D-Flip-Flop" class="internal-link" target="_self" rel="noopener nofollow">D-Flip-Flop</a>으로 만드는 잠깐 저장하는 기억장치다.<br>연산을 할 때 레지스터에 값을 넣고 ALU에 보내 연산을 합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\메모리\레지스터.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/메모리/레지스터.md</guid><pubDate>Thu, 26 Jun 2025 08:02:29 GMT</pubDate></item><item><title><![CDATA[코드 영역]]></title><description><![CDATA[ 
 <br><br>코드가 저장되는 공간이다.<br>
CPU에서 코드 영역의 저장된 명령을 가져가서 처리한다.<br><br>전역 변수와 정적 변수가 저장되는 공간이다.<br><br>동적으로 프로그래머가 직접 공간을 할당하거나 해제하는 메모리 공간이다.<br>
낮은 주소에서 높은 주소의 방향으로 할당된다.<br><br>프로그램이 자동으로 사용하는 임시 메모리 영역이다.<br>
함수 호출때 생성되는 지역 변수와 매개 변수가 저장되는 곳이고<br>
함수 호출이 완료되면 사라진다.<br>
전역이 아닌 함수 밖의 메모리의 위치를 참조하면 segment fault가 발생한다.(C언어 이상 언어)<br>
메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.<br>
함수나 메서드가 호출될 때 마다 스택 프레임이 쌓인다.<br><a data-href="함수 호출 시 발생하는 것" href="컴퓨터 공학\컴퓨터 구조\함수 호출 시 발생하는 것.html" class="internal-link" target="_self" rel="noopener nofollow">함수 호출 시 발생하는 것</a>이건 스택을 잘 설명하는 구조]]></description><link>컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/메모리/메모리 구조.md</guid><pubDate>Wed, 25 Jun 2025 08:07:31 GMT</pubDate></item><item><title><![CDATA[지역성]]></title><description><![CDATA[ 
 <br>코딩을 하다보면 느낄 수도 있는데 프로그램이 실행이 될 때<br>
실행되는 공간이 모여있다고 생각이 든 적 없나요?<br><br><br>메모리를 사용할 때 메모리끼리 비슷한 공간의 메모리를 사용한다는걸 말합니다.<br>
배열이나 클래스와 같이 데이터를 뭉쳐두고 그 메모리를 자주 사용한다는 거죠.<br><br>한번 사용한 메모리를 빠른 시일내에 다시 사용할 가능성이 높다는 말인데<br>
for문 을 돌릴 떄 N번만큼 변수 i값에 접근하지 않나요? 그런식으로 변수를 자주 사용합니다.<br><br><br>데이터가 필요한데 데이터가 캐시에 있을 때를 말한다.<br>
캐시에서 데이터를 가져온다.<br><br>데이터가 필요한데 데이터가 캐시에 없을 때를 말한다.<br>
캐시에 데이터를 가져온다. 이 때 느려진다.<br><br>L1은 명령어와 데이터를 저장할 공간을 분리해야 하기에 2개로 이루어져있고<br>
L2는 코어마다 한 개씩 있고<br>
L3는 CPU에 하나 있는 방식으로 되어있다.]]></description><link>컴퓨터 공학\컴퓨터 구조\메모리\캐시 메모리.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/메모리/캐시 메모리.md</guid><pubDate>Thu, 26 Jun 2025 08:01:15 GMT</pubDate></item><item><title><![CDATA[SRAM]]></title><description><![CDATA[ 
 <br><br>SRAM이라고 부르는 것은 <a data-href="캐시 메모리" href="컴퓨터 공학\컴퓨터 구조\메모리\캐시 메모리.html" class="internal-link" target="_self" rel="noopener nofollow">캐시 메모리</a>입니다.<br>
캐시 메모리를 도입하게 된 이유는 명령어를 처리 할 때 <a data-href="파이프라이닝" href="컴퓨터 공학\컴퓨터 구조\CPU\파이프라이닝.html" class="internal-link" target="_self" rel="noopener nofollow">파이프라이닝</a>을 구축하기 위함입니다.<br>
<a data-href="파이프라이닝" href="컴퓨터 공학\컴퓨터 구조\CPU\파이프라이닝.html" class="internal-link" target="_self" rel="noopener nofollow">파이프라이닝</a>이 무슨 말이냐면 대충 공장처럼 명령어를 처리하는 과정을 여러 개로 나누어 동시에 여러 작업을 하는 것을 의미하는데 4개의 단위로 나누어서 실행합니다. (동시성이 늘어나는게 아니라 같은 시간 처리량이 늘어나는 구조)<br>
그러다 보면 메모리에 쓰는 작업과 읽는 작업을 동시에 해야하는데 동시에는 불가능하기에 메모리를 2개로 나누어서 하나는 읽고 하나는 쓰는 작업을 할 수 있게 만들었습니다.<br>
DRAM보다 차지하는 용량이 크고 비싼 재료를 사용하기에 조금 만들어서 사용합니다.<br>
D-Flip-Flop으로 만듭니다.<br><br>DRAM이라고 부르는 것은 램을 의미합니다.<br>
읽고 쓰는게 SRAM이랑 비교 하면 오래걸리는데 이유는 DRAM의 저장하는 방식이 Cell에 저장하는 방식이라서 그렇다고 합니다.<br>
Cell을 다르게 말하면 배터리인데 작게 만들 수 있어서 이걸 사용한다고 합니다.<br>
Cell은 배터리다 보니 시간이 지나면 방전되는데 이를 방지하기 위해 주기적으로 Refresh를 해준다고 합니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\메모리\SRAM, DRAM.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/메모리/SRAM, DRAM.md</guid><pubDate>Sun, 22 Jun 2025 08:30:39 GMT</pubDate></item><item><title><![CDATA[단점]]></title><description><![CDATA[ 
 <br><a data-href="양자역학" href="컴퓨터 공학\컴퓨터 구조\양자 컴퓨팅\양자역학.html" class="internal-link" target="_self" rel="noopener nofollow">양자역학</a>에서 두 개의 상태를 동시에 가지는 현상을 사용하면 어떨까라는 생각에서 비롯된 것이고<br>
현재 <a data-href="RSA" href="컴퓨터 공학\프로그래밍\알고리즘\암호화\비대칭키\RSA.html" class="internal-link" target="_self" rel="noopener nofollow">RSA</a> 암호화에서 사용하는 게 소수를 사용해서 풀려면 무작위 대입을 통해서만 풀 수가 있는데<br>
한번에 여러 값을 동시에 대입이 가능하기에 더 압도적으로 빠른 시간에 보안이 뚫리는 것이다.<br>
그러니까 정확히는 무작위 대입에 대해서 이점을 가지는 것이지<br>
CPU의 변수에 값을 대입하고 그 값으로 연산을 하고 그런 작업에 대해서 이점을 가지는 것이 아니다.<br>
따라서 양자 컴퓨터가 상용화가 되어도 보안 용도로 따로 쓰이지 않을까 생각한다.<br><br>현재 양자 컴퓨터를 돌리려면 외부와 차단된 공간을 만들어야 하는데<br>
그러려면 초전도체가 필요하고 현재 상온 초전도체는 만들지 못하기에<br>
액체질소로 냉각해서 초전도체를 만들어서 그 상태로 컴퓨터를 돌리고 있고<br>
오류가 자주 발생하기에 오류를 고치는 방법도 필요해서 아직까지는 상용화가 어려운 것으로 보고 있다.<br><br><a data-tooltip-position="top" aria-label="https://youtu.be/5vnC07bQ0uo?si=S-qcV6N_FYkgbp36" rel="noopener nofollow" class="external-link" href="https://youtu.be/5vnC07bQ0uo?si=S-qcV6N_FYkgbp36" target="_blank">양자 컴퓨터는 정말 10000000000000000000000배 빠를까?</a>]]></description><link>컴퓨터 공학\컴퓨터 구조\양자 컴퓨팅\양자 컴퓨터.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/양자 컴퓨팅/양자 컴퓨터.md</guid><pubDate>Wed, 02 Jul 2025 08:41:30 GMT</pubDate></item><item><title><![CDATA[슈뢰딩거의 고양이]]></title><description><![CDATA[ 
 <br>슈뢰딩거의 고양이로 유명한 이론인데<br>
슈뢰딩거의 고양이가 사실은 비판하기 위한 용도로 만든 말이지만<br>
양자 역학을 상당히 잘 설명하는 말이라서 자주 쓰인다.<br><br>밖에서는 내부를 절대로 볼 수 없는 상자를 준비하고 고양이를 안에 넣고<br>
1시간 후 50퍼센트 확률로 고양이가 죽는 환경을 만든다.<br>
1시간 후 고양이는 죽었을 까? 살았을까?<br>
정답은 상자를 열기 전까지는 고양이는 살아있는 상태와 죽어있는 상태가 공존한다는 것이다.<br>
그리고 상자를 여는 순간 둘 중 하나의 상태로 고정된다는 것이다.<br><br>슈뢰딩거의 고양이는 그럴리가 없다고 생각이 든다면 실제 실험을 가져오겠습니다.<br>
상자에 구멍을 뚫어놓고 입자를 발사하면 반대 벽에는 두 개의 구멍이 보이고<br>
파동을 발사하면 반대편 벽에는 간섭무늬가 표현될거라고 생각을 하고 실험을 했습니다.<br>똑같이 외부에서는 내부를 볼 수 없는 상자고 입자를 발사하니 간섭무늬가 표현되었고<br>
이유를 알아내기 위해 상자 내부에 관찰하기 위한 장치를 두고 다시 실험하니 두 개의 구멍만이 나타났습니다.]]></description><link>컴퓨터 공학\컴퓨터 구조\양자 컴퓨팅\양자역학.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/양자 컴퓨팅/양자역학.md</guid><pubDate>Thu, 26 Jun 2025 08:17:24 GMT</pubDate></item><item><title><![CDATA[ARM]]></title><description><![CDATA[ 
 <br>명령어의 크기가 일정하다.<br>
저전력으로도 좋은 성능을 낸다.]]></description><link>컴퓨터 공학\컴퓨터 구조\CPU\아키텍쳐\ARM.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/CPU/아키텍쳐/ARM.md</guid><pubDate>Tue, 01 Jul 2025 00:06:53 GMT</pubDate></item><item><title><![CDATA[x86]]></title><description><![CDATA[ 
 <br>명령어의 길이가 가변적이다.<br>
전력을 많이 넣으면 성능이 좋다.]]></description><link>컴퓨터 공학\컴퓨터 구조\CPU\아키텍쳐\x86.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/CPU/아키텍쳐/x86.md</guid><pubDate>Tue, 01 Jul 2025 00:06:29 GMT</pubDate></item><item><title><![CDATA[파이프라이닝]]></title><description><![CDATA[ 
 <br>명령어를 처리 할 때 단계를 나눠서 처리하고 중간 과정의 값을 저장하면서 진행하는 방식이다.<br>Branch가 있으면 몇 번의 클럭 동안 명령어 처리를 하지 않는다.<br>
이것도 어느 정도 최적화를 통해 반복하는 경우는 for문에 들어왔을 때와 for문에서 나갈 때를 제외하고 미리 가져오게 만들어 놓는다.]]></description><link>컴퓨터 공학\컴퓨터 구조\CPU\파이프라이닝.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/CPU/파이프라이닝.md</guid><pubDate>Sun, 22 Jun 2025 08:28:59 GMT</pubDate></item><item><title><![CDATA[산술 연산]]></title><description><![CDATA[ 
 <br>Central Processing Unit으로 명령어를 실행하는 연산장치다.<br>CPU 내부에는 여러가지가 있는데<br>
명령어를 저장하는 데이터 공간,<br>
데이터를 저장하는 데이터 공간,<br>
<a data-href="레지스터" href="컴퓨터 공학\컴퓨터 구조\메모리\레지스터.html" class="internal-link" target="_self" rel="noopener nofollow">레지스터</a>,<br>
ALU,<br>
Control가 있다.<br><br><br><br><a data-tooltip-position="top" aria-label="https://youtu.be/Fg00LN30Ezg?si=SxKc6ERL7A-t1q-b" rel="noopener nofollow" class="external-link" href="https://youtu.be/Fg00LN30Ezg?si=SxKc6ERL7A-t1q-b" target="_blank">시각적으로 볼 수 있다.</a>]]></description><link>컴퓨터 공학\컴퓨터 구조\CPU\CPU.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/CPU/CPU.md</guid><pubDate>Wed, 02 Jul 2025 08:38:57 GMT</pubDate></item><item><title><![CDATA[Structural Hazards]]></title><description><![CDATA[ 
 <br><br><br>]]></description><link>컴퓨터 공학\컴퓨터 구조\CPU\Hazards.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/CPU/Hazards.md</guid><pubDate>Fri, 27 Jun 2025 08:22:54 GMT</pubDate></item><item><title><![CDATA[CISC]]></title><description><![CDATA[ 
 <br><br>
li:
	TSL ax, lock
	cmp ax, 0
	jne l1
	; 임계구역
	mov lock, 0
<br>lock 변수에서 값을 읽고 1을 기록하고<br>
만약 성공하면 임계구역으로 들어가고<br>
실패하면 li로 이동해 다시 대기한다.<br>
lock에 0을 넣어 다른 스레드가 임계구역에 들어올 수 있도록 한다.<br><br><br>again:
	lr.d x10, (x20)
	sc.d x11, x23, (x20) ; x11 = status
	bne x11, x0, again ; branch if store failed
	addi x23, x10, 0 ; x10(x20이 지정하는 메모리에서 load한 값 &lt;-&gt; x23을 swap)
<br>x20과 x23을 서로 swap하면서 값을 비교하면서 값이 다르면 접근을 못하고 같으면 swap해서 다른 스레드가 못들어오게 막는다.<br><br>	addi x12, x0, 1 ; copy locked value
again:
	lr.d x10, (x20) ; read lock
	bne x10, x0, again ; check if it is 0 yet
	sc.d x11, x12, (x20) ; attempt to store
	bne x11, x0, again ; branch if fails
	
unlock:
	sd x0, 0(x20) ; free lock
<br>간단하게 말하면 누가 이미 사용 중이면 루프를 계속 돌고 사용 중이 아닐 때 다른 스레드가 접근을 못하게 막는 코드다.]]></description><link>컴퓨터 공학\컴퓨터 구조\원자성 어셈블리 코드.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/원자성 어셈블리 코드.md</guid><pubDate>Fri, 27 Jun 2025 14:41:34 GMT</pubDate></item><item><title><![CDATA[성능]]></title><description><![CDATA[ 
 <br>내가 배운 컴퓨터의 구조는 RISC-V의 구조다.<br>
전반적인 내용은 x86-64나 ARM과 비슷할 것이다.<br>일단 기본적으로 하드웨어에 대해서 설명을 해보고자 한다.<br><br>성능에는 여러가지 요소가 영향을 미치는데<br>클럭 속도를 높이면 대부분 문제가 해결이 됩니다.<br>
그렇게 클럭 속도를 계속 높였는데<br>
4GHz에 가까워지자 발열이 너무 심하게 발생했습니다.<br>
그래서 만들어진게 듀얼 코어였죠.<br>
요즘은 Ryzen ThreadRipper Pro 9995WX 기준 96개의 코어 192개의 스레드를 가지네요.<br>
하지만 멀티 코어로 가면서 바뀐건 처리 속도가 아니라 처리량의 증가입니다.<br>
이 점 기억해 두세요.<br>]]></description><link>컴퓨터 공학\컴퓨터 구조\컴퓨터 구조.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/컴퓨터 구조.md</guid><pubDate>Tue, 24 Jun 2025 08:30:47 GMT</pubDate></item><item><title><![CDATA[참고할 것]]></title><description><![CDATA[ 
 <br><br>이건 정말 로우 레벨(어셈블리어)로 내려가서 설명할 거라 이해 못할 수도 있어요.<br>
컴퓨터 공학 전공에서 가르치는 어려운 내용입니다.<br>
관심 있으면 확인하면 좋을 거 같아요.<br>
그리고 기준은 x86 32비트 아키텍쳐 Windows 기준입니다.<br><br>간단한 C언어 코드를 예제로 사용할 겁니다.<br>#include &lt;stdio.h&gt;

void function(int a, int b, int c){
	printf("a = %d, b = %d, c = %d\n", a,b,c);
	return;
}

int main(){
	int a = 1;
	int b = 2;
	int c = 3;
	function(a,b,c);
	return 0;
}
<br><br>코드를 실행파일로 만들면 0과 1로 이루어진 기계어의 연속으로 되어있는데<br>
컴퓨터는 이 기계어를 하나씩 실행시킵니다.<br>
그래서 기계어의 위치 번호를 PC(Program Counter)라고 하는데<br>
기계어를 하나 실행하고 PC에 +1하고 하나 실행하고 PC에 +1하고를 반복합니다.<br>
근데 조건문, 반복문, 함수 호출시에는 PC + (이동할 상대적인 위치)를 해서 뛰어 넘어가기도 합니다.<br>메모리 구조에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로<br>
코드 영역 부터 스택 영역까지 0부터 메모리 공간의 끝까지 존재합니다.<br>
여기에서 힙은 데이터 영역 끝에서 스택 영역 방향으로 커지고<br>
스택은 메모리 공간의 끝에서 힙의 방향으로 커집니다.<br>
그러니까 스택과 힙의 사이 공간은 비어있습니다.<br>
그러니까 스택 영역의 시작은 메모리의 끝 번호입니다.<br>스택 영역의 끝을 가리키는 건 SP입니다.<br><br>메모리의 최대 크기는 컴퓨터의 CPU의 비트 수를 알면 알 수 있어요.<br>
32비트 CPU를 쓰시는 분은 없을 거라 생각하지만<br>
만약에 32비트 CPU를 쓰신다면 2^32 그러니까 4기가 바이트죠.<br>
64비트 CPU를 쓰시면 2^64 니까 16엑사 바이트네요.<br><br>어라? 내 컴퓨터는 그정도의 메모리를 가지고 있지 않다고요?<br>
운영체제에서는 당신의 컴퓨터에 있는 메모리를 일정 간격으로 쪼개서<br>
필요할 때마다 떼어서 사용해도 된다고 허락해줍니다.<br>
프로그램에서 0번을 가리키는 메모리의 주소가<br>
실제로 물리적으로 메모리의 0번째 주소를 가리키지 않아요.<br>
그냥 운영체제가 넘겨준 메모리 공간의 첫번째일 뿐이죠.<br>
그래서 프로그램의 메모리 공간를 가상 메모리 공간이라고 불러요.<br>
가상 메모리랑은 좀 다른 개념이니까 유의하고<br>
운영체제에게 가상 메모리 공간의 주소를 주면서 값을 달라고 하면<br>
해당 프로그램에게 할당된 물리 메모리 공간에 접근해서 가져와요.<br>
그러니까 모든 프로그램의 메모리의 첫번째 메모리 주소는 0번째이고<br>
각각 모든 프로그램의 첫번째 메모리 주소의 실제 메모리의 주소는 다 달라요.<br>
이렇게 해둔 이유는 여러가지 이유가 있긴 한데 한 프로그램에서<br>
다른 프로그램의 변수 값을 조작하면 안되기 때문이에요.<br><br>매개변수를 오른쪽에서 왼쪽 방향으로 스택 메모리에 넣습니다.<br>
위의 예시대로면 c, b, a의 순서대로 스택 메모리에 넣는거죠.<br>
작동하는 건<br>
SP에 -4를 더하고 c를 여기에 넣고<br>
SP에 -4를 더하고 b를 여기에 넣고<br>
SP에 -4를 더하고 a를 여기에 넣고<br>
이런식으로 넣는거죠.<br>왜 +4를 하지 않을까요?<br>
왜냐하면 메모리 공간의 끝에 +4를 하면 메모리 공간을 넘어가버리기 때문이에요.<br>반대로 -4를 해야 비어있는 공간에 접근이 가능한거죠.<br>그러면 이제 함수를 호출하기 전 준비는 되었군요. 그럼 이제 함수를 호출해 볼까요?<br><br><br>함수를 호출한 위치 바로 다음 위치를 스택 메모리에 저장합니다.<br>
이유는 함수가 종료되면 어디로 다시 돌아와야 할지 알아둬야 돌아올 수 있기 때문이에요.<br>
위의 예제에서 다음 위치를 저장하지 않으면 함수가 종료되면 다음으로 실행할 명령어는 int a;가 되겠죠.<br>이제 함수로 들어왔습니다.<br>근데 SP의 값은 항상 변하잖아요? 지역변수를 만들면 그 때마다 다시 지역변수의 상대적인 위치를 구하기는 힘드니까<br>
BP에 함수를 호출할 당시의 SP를 저장하도록 하겠습니다.<br>
근데 이전 함수에서 BP에 값을 넣었을 수도 있으니까 이전 함수에서의 BP값을 스택에 넣어줍시다.<br>
그리고 BP에 현재 SP값을 넣으면 됩니다.<br>이제 현재 함수 안에서 지역 변수가 있다면 그것도 스택 메모리에 넣도록 합시다.<br><br>할일 다 하면 지역 변수가 스택에 있잖아요?<br>
다시 돌려줘야죠.<br>
돌려주는건 간단합니다. 지역 변수를 스택에 저장한 순서 반대로<br>
가장 마지막에 저장한 변수부터 가장 처음에 저장한 변수 순서대로<br>
해당 변수의 크기 만큼 SP에 더해주면 됩니다.<br>
만약에 한번에 가능하면 한번에 해주면 좋죠.<br>그리고 이전 함수에서 사용되었던 BP의 값을 돌려줍시다.<br>이제 return을 통해 함수를 호출한 위치로 돌아갑니다.<br><br>매개변수들도 반환을 해줘야겠죠?<br>
위에서 지역변수들에게 해준 것 처럼 해주면<br>
함수가 완벽하게 종료되었습니다.<br>참고로 이렇게 복잡한 과정은 C로 올라가기만 해도 자동으로 해주는 것이니까<br>
이런 과정을 통해 함수가 작동하는구나 만 알아두시면 좋을 거 같아요.<br><br>void function(){
	function();
}

int main(){
	function();
	return 0;
}
<br>이걸 실행시키는 것과<br>int main(){
	while(true){}
	return 0;
}
<br>이것의 차이가 뭘까요?<br><br>첫번째꺼는 스택 메모리 사용량이 8바이트씩 계속 올라가다가 메모리 부족으로 종료된다.<br>
두번째꺼는 스택 메모리 사용량이 그대로라 직접 종료시키지 않는 한 계속 돌아간다.<br><br>SASM 프로그램을 통해 실행을 확인했습니다.<br>
';' 이 문자 뒤에 있는 글은 주석입니다.<br>
위에 있는 c언어 코드를 그대로 번역한 코드입니다.<br>%include "io.inc"

section .data

	function_str db "a = %d, b = %d, c = %d", 10, 0; 전역변수 문자열


extern printf ; printf 불러오기

section .text

global CMAIN

CMAIN:

	push ebp ; 현재 스택 포인터를 저장하기 위해 기존 ebp 보존
	
	mov ebp, esp ; ebp에 현재 스택 포인터 저장
	
	push dword 1 ; int a = 1;
	
	push dword 2 ; int b = 2;
	
	push dword 3 ; int c = 3;
	
	push dword [ebp - 12] ; function 매개변수 c로 지역변수 c 입력
	
	push dword [ebp - 8] ; function 매개변수 b로 지역변수 b 입력
	
	push dword [ebp - 4] ; function 매개변수 a로 지역변수 a 입력
	
	  
	
	call function ; function 함수 호출
	
	add esp, dword 4 ; 매개변수 a 스택 포인터 반환
	
	add esp, dword 4 ; 매개변수 b 스택 포인터 반환
	
	add esp, dword 4 ; 매개변수 c 스택 포인터 반환
	
	  
	
	add esp, dword 4 ; 지역변수 c 스택 포인터 반환
	
	add esp, dword 4 ; 지역변수 b 스택 포인터 반환
	
	add esp, dword 4 ; 지역변수 a 스택 포인터 반환
	
	pop ebp ; 이 함수 호출하기전 ebp값으로 돌려놓
	
	xor eax, eax ; 반환값 0
	
	ret ; 함수 종료

function:

	push ebp ; 현재 스택 포인터를 저장하기 위해 기존 ebp 보존
	
	mov ebp, esp ; ebp에 현재 스택 포인터 저장
	
	push dword [ebp + 16] ; printf의 매개변수 c 입력
	
	push dword [ebp + 12] ; printf의 매개변수 b 입력
	
	push dword [ebp + 8] ; printf의 매개변수 a 입력
	
	push dword function_str ; printf의 매개변수 문자열 입력
	
	call printf ; printf 함수 호출
	
	add esp, 4 ; 매개변수 문자열의 스택 포인터 반환
	
	add esp, 4 ; 매개변수 a의 스택포인터 반환
	
	add esp, 4 ; 매개변수 b의 스택포인터 반환
	
	add esp, 4 ; 매개변수 c의 스택포인터 반환
	
	pop ebp ; 함수 호출하기 전 ebp 값으로 돌려놓기
	
	ret ; 함수 종료
<br>어셈블리어 기준으로 보면<br>
함수, if, for, while, class, struct 죄다 슈가 코드입니다.<br>
이걸 보면 알게될건데 지역변수 몇 백 개를 만들어도 처음에 만든 지역변수 찾으려고 살펴보지 않고<br>
언제 만들었든 위치 값을 한번 연산한 후 그 위치에 있는 값을 가져옴]]></description><link>컴퓨터 공학\컴퓨터 구조\함수 호출 시 발생하는 것.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/함수 호출 시 발생하는 것.md</guid><pubDate>Sat, 21 Jun 2025 14:25:33 GMT</pubDate></item><item><title><![CDATA[CPU 성능]]></title><description><![CDATA[ 
 <br>CPUTime = Instruction Count / Program * Clock cycles / Instruction Count * Seconds / Clock cycles이다.<br>자세한 설명은 생략하고 싶게 복잡한 이론이다.]]></description><link>컴퓨터 공학\컴퓨터 구조\CPU 성능.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 구조/CPU 성능.md</guid><pubDate>Mon, 30 Jun 2025 07:55:59 GMT</pubDate></item><item><title><![CDATA[HDD 가격]]></title><description><![CDATA[ 
 <br>장치 안에 CD 여러 개를 넣은 상태고 헤더를 통해 물리적으로 CD를 읽는 방식이기에<br>
물리적인 충격에 약하다.<br><a data-tooltip-position="top" aria-label="SSD 가격" data-href="SSD 가격" href="컴퓨터 공학\컴퓨터 조립\메모리\보조기억장치\SSD 가격.html" class="internal-link" target="_self" rel="noopener nofollow">SSD</a>보다는 가격이 저렴하다.<br>고장이 날 경우 데이터를 일부를 제외하고 대부분을 복원할 수 있다.]]></description><link>컴퓨터 공학\컴퓨터 조립\메모리\보조기억장치\HDD 가격.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/메모리/보조기억장치/HDD 가격.md</guid><pubDate>Thu, 03 Jul 2025 02:10:47 GMT</pubDate></item><item><title><![CDATA[SSD 가격]]></title><description><![CDATA[ 
 <br>전자식으로 데이터를 저장하는 방식이라 물리적인 충격에 강하다.<br>고장이 날 경우 복원이 어렵다.<br>비싼 편에 속한다.]]></description><link>컴퓨터 공학\컴퓨터 조립\메모리\보조기억장치\SSD 가격.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/메모리/보조기억장치/SSD 가격.md</guid><pubDate>Thu, 03 Jul 2025 02:11:06 GMT</pubDate></item><item><title><![CDATA[RAM 가격]]></title><description><![CDATA[ 
 <br>성능은 클럭 속도가 높을 수록 좋고<br>
DDR 숫자에 따라 클럭 속도의 제한이 다르다.<br>
DDR4의 경우 3200가 최대였는데(오버클럭을 제외하고)<br>
DDR5는 DDR4보다 온도는 높아지지만 3200보다 높은 클럭을 가진다.]]></description><link>컴퓨터 공학\컴퓨터 조립\메모리\주기억장치\RAM 가격.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/메모리/주기억장치/RAM 가격.md</guid><pubDate>Thu, 03 Jul 2025 02:13:42 GMT</pubDate></item><item><title><![CDATA[메인보드]]></title><description><![CDATA[ 
 <br>메인보드를 사려면 CPU가 호환되는지 부터 확인해야한다.]]></description><link>컴퓨터 공학\컴퓨터 조립\CPU\메인보드.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/CPU/메인보드.md</guid><pubDate>Thu, 03 Jul 2025 08:19:50 GMT</pubDate></item><item><title><![CDATA[Apple사 가격]]></title><description><![CDATA[ 
 <br>Apple사에서는 과거에 Intel에서 만든 CPU를 사용했지만 독자적으로 CPU를 설계해서 제작하기 시작했다.<br>
M시리즈가 그것인데<br>
M1, 2, 3, 4로 숫자가 올라가며<br>
고급형은 pro, max가 있다.<br>
고급형은 더 많은 램을 장착할 수 있으며<br>
ARM 구조로 만들어져서 저전력으로 돌아가는 칩을 만들었다.<br>최적화를 위해 여러가지 부품을 조립하지 않고 전부 하나의 보드에 올려서 부품을 교체할 수가 없다.<br>
일부는 가능한 것으로 알고 있다.]]></description><link>컴퓨터 공학\컴퓨터 조립\CPU\Apple사 가격.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/CPU/Apple사 가격.md</guid><pubDate>Thu, 03 Jul 2025 02:18:47 GMT</pubDate></item><item><title><![CDATA[Intel사 가격]]></title><description><![CDATA[ 
 <br>CPU를 만드는 회사였지만 GPU도 생산하기 시작했다.<br>
역대 CEO중 한 명이 Intel이 사실상 독점을 하게 되니까 성능에는 신경쓰지 않고<br>
절약 하려고만 해서 품질이 떨어지는 제품을 만들게 되었다.<br>
특정 게임에서는 다른 회사 제품보다 뛰어난 성능을 보이긴 한다.<br>하지만 오랜시간동안 14나노에서 발전하지 못해 Ryzen CPU에게 밀리는 일이 발생했다.<br>성능으로는 두 회사가 비슷하게 표현한다.<br>
3,5,7,9로 숫자를 붙이는데<br>
3은 사무용이다.<br>
5는 저렴한 CPU고 일반 게임에서는 문제 없다.<br>
7은 좀 더 비사고 성능이 좋은 CPU다.<br>
9는 편집처럼 CPU를 많이 돌려야하는 경우 사용할 정도만 사용하는게 좋을 것이다.<br>
성능은 좋고 비싸다.<br>CPU 내부에 내장 그래픽이 있는 경우가 있는데<br>
편집하기 위한 용도면 있는 게 좋다고 한다.<br>세대를 표현하는데 앞의 숫자가 세대를 표현하고<br>
뒤의 숫자는 성능이나 기능을 표현한다.]]></description><link>컴퓨터 공학\컴퓨터 조립\CPU\Intel사 가격.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/CPU/Intel사 가격.md</guid><pubDate>Thu, 03 Jul 2025 02:40:09 GMT</pubDate></item><item><title><![CDATA[Ryzen]]></title><description><![CDATA[ 
 <br>AMD사에서 만든 CPU다.<br>
Intel에 밀려서 적자를 반복하던 중 리사 수 CEO가 등장하면서<br>
Ryzen의 위상이 변화하기 시작했다.<br>
성능이 좋아졌고 Intel을 이긴 신기술이 등장했는데<br>
3D 캐시 기술이었다.<br>성능으로는<br>
3은 사무용으로 사용하기 좋은 성능이다.<br>
5부터 게임으로 쓸만한 성능이고<br>
7은 고사양 게임할 때 사용할만한 성능이다.<br>
9는 편집용으로 사용하기 좋은 성능이다.<br>3D 캐시 기능이 들어간 CPU는 게임 성능에 좋은 영향을 미친다.<br>
3D 캐시 기능이 들어가면서 캐시 크기가 늘었다.<br>
그래서 리소스를 많이 쓰는 게임의 성능이 높아지는 것이다.<br>CPU 내부에 내장 그래픽이 포함된 제품도 있다.<br>
하지만 외장 그래픽을 달 거면 절대로 내장 그래픽으로 모니터를 연결하지 말아야 할 것이다.<br>세대를 표현하는데 앞의 숫자가 세대를 표현하고<br>
뒤의 숫자는 성능이나 기능을 표현한다.]]></description><link>컴퓨터 공학\컴퓨터 조립\CPU\Ryzen.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/CPU/Ryzen.md</guid><pubDate>Thu, 03 Jul 2025 02:40:15 GMT</pubDate></item><item><title><![CDATA[아크]]></title><description><![CDATA[ 
 <br>Intel 사에서 만든 GPU다.<br>
사용하는 사람이 적다.]]></description><link>컴퓨터 공학\컴퓨터 조립\GPU\아크.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/GPU/아크.md</guid><pubDate>Thu, 03 Jul 2025 02:37:36 GMT</pubDate></item><item><title><![CDATA[Apple사 가격]]></title><description><![CDATA[ 
 <br>CPU에 부착이 되어서 나온다.]]></description><link>컴퓨터 공학\컴퓨터 조립\GPU\Apple사 가격.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/GPU/Apple사 가격.md</guid><pubDate>Thu, 03 Jul 2025 02:33:38 GMT</pubDate></item><item><title><![CDATA[Nvidia]]></title><description><![CDATA[ 
 <br>이 그래픽 카드는 전기를 잡아먹는 그래픽 카드다.<br>
노트북에 이 그래픽 카드가 달려있으면 배터리 사용 시간이 확 줄어든다.<br>
그래픽 카드를 사용하지 않아도 전기를 잡아먹는다.<br>성능<br>
성능은 좋은 편이다.<br>
성능에 한계를 느꼈는지 DLSS를 통해 AI로 프레임을 생성하는 기술을 만들어서<br>
게임 성능을 배로 증가시킨다.<br>
DLSS는 Nvidia 그래픽 카드만 사용이 가능하고<br>
그래픽 세대에 따라 사용할 수 있는 버전이 따로 존재한다.<br>인공지능용 GPU를 판매하는데<br>
돈을 쓸어담 듯이 벌고 있다.<br>
인공지능 라이브러리들이 다 Nvidia를 기준으로 제작이 되어서<br>
정확히는 CUDA를 기준으로 제작이 되어서<br>
인공지능을 돌리려면 왠만하면 Nvidia를 선택하는게 좋은 선택이다.<br>레이트레이싱 기술을 지원한다.]]></description><link>컴퓨터 공학\컴퓨터 조립\GPU\Nvidia.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/GPU/Nvidia.md</guid><pubDate>Thu, 03 Jul 2025 07:30:25 GMT</pubDate></item><item><title><![CDATA[Radeon]]></title><description><![CDATA[ 
 <br>AMD 사에서 만든 GPU다.<br>성능으로는<br>
Nvidia와 비교가능할 정도지만<br>
인공지능에서는 확실하게 밀리고 있다.<br>AFMF를 통해 AI로 프레임을 생성해내는 기능을 지원하며<br>
어느 그래픽 카드를 사용하던간에 게임에서 지원하면 사용할 수 있고<br>
모든 게임에 대해서는 라데온 그래픽 카드를 사용할 때만 가능하다.]]></description><link>컴퓨터 공학\컴퓨터 조립\GPU\Radeon.html</link><guid isPermaLink="false">컴퓨터 공학/컴퓨터 조립/GPU/Radeon.md</guid><pubDate>Thu, 03 Jul 2025 07:31:28 GMT</pubDate></item><item><title><![CDATA[Flutter]]></title><description><![CDATA[ 
 <br><a data-href="Dart" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Dart\Dart.html" class="internal-link" target="_self" rel="noopener nofollow">Dart</a>를 사용하는 크로스 플랫폼 프레임워크다.]]></description><link>컴퓨터 공학\프레임워크\앱 프레임워크\Flutter\Flutter.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/앱 프레임워크/Flutter/Flutter.md</guid><pubDate>Thu, 26 Jun 2025 08:46:55 GMT</pubDate></item><item><title><![CDATA[React Native]]></title><description><![CDATA[ 
 <br>React의 문법으로 안드로이드, Ios 앱을 개발할 수 있는 앱 프레임워크다.]]></description><link>컴퓨터 공학\프레임워크\앱 프레임워크\React Native\React Native.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/앱 프레임워크/React Native/React Native.md</guid><pubDate>Thu, 26 Jun 2025 08:48:53 GMT</pubDate></item><item><title><![CDATA[@Lazy]]></title><description><![CDATA[ 
 <br><a data-href="Proxy Pattern" href="컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Proxy Pattern.html" class="internal-link" target="_self" rel="noopener nofollow">Proxy Pattern</a>을 사용해서 만든 빈이다.<br><br>지연 로딩을 위해 프록시 생성<br><br>메서드 파라미터 검증을 위해 프록시 생성<br><br>트랜잭선 관리를 위해 프록시 생성<br>
스프링 부트는 @Transactional 어노테이션이 들어간 메소드가 발견되면<br>
스프링은 해당 객체를 만들 때 Transaction 기능을 담은 프록시로 만든다.<br>그리고 @Transactional 어노테이션이 있는 메소드를 실행하기전 Transaction을 시작하고<br>
메소드가 종료되면 Transaction을 종료한다. <br>이 프록시에서 메소드를 실행하지 않고 객체에서 메소드를 실행하면 Transaction기능이 작동하지 않는다.<br>그리고 안에서는 어떤일이 일어나냐면 <a data-href="JPA Transaction" href="컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\JPA\JPA Transaction.html" class="internal-link" target="_self" rel="noopener nofollow">JPA Transaction</a><br><br>캐싱 기능을 위해 프록시 생성<br><br>비동기 처리를 위해 프록시 생성<br><br>이벤트 처리를 위해 프록시 생성<br><br>스케줄링을 위해 프록시 생성<br><br>생명주기 관리를 위해 프록시 생성<br><br>
<br>AOP 기능 사용 가능
<br>트랜잭션, 검증 등 추가 기능 제공
<br>기능 확장이 용이함
<br><br>
<br>메모리 사용량이 약간 많음
<br>성능 오버헤드 존재
<br>디버깅이 복잡할 수 있다.
]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\어노테이션\스프링 부트 프록시 경유 빈.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/어노테이션/스프링 부트 프록시 경유 빈.md</guid><pubDate>Mon, 23 Jun 2025 01:58:53 GMT</pubDate></item><item><title><![CDATA[스프링부트 ModelAttribute]]></title><description><![CDATA[ 
 <br>Controller에서 HTML에 데이터를 넣을 때 Model을 가져와 넣는 방법이 있는데<br>
그것 외에도 메서드 매개변수에 넣는 Form같은 클래스는 기본적으로 ModelAttribute 어노테이션이 들어간다고 한다.<br>@bean처럼 사용도 가능한데<br>
메서드를 만들고 내용을 반환하게 하면 HTML에서 가져와서 대입한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\어노테이션\스프링부트 ModelAttribute.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/어노테이션/스프링부트 ModelAttribute.md</guid><pubDate>Mon, 23 Jun 2025 05:42:14 GMT</pubDate></item><item><title><![CDATA[스프링부트 _method 파라미터]]></title><description><![CDATA[ 
 <br>실제로는 POST 요청을 하지만 스프링에서는 PUT으로 인식하게 만들 수 있다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\타임리프\스프링부트 _method 파라미터.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/타임리프/스프링부트 _method 파라미터.md</guid><pubDate>Tue, 24 Jun 2025 06:36:09 GMT</pubDate></item><item><title><![CDATA[자바에서 가져오기]]></title><description><![CDATA[ 
 <br><br>${variable}를 통해 가져올 수 있고<br>
만약 길어지면 ||로 감싸줘야 한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\타임리프\스프링부트 타임리프.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/타임리프/스프링부트 타임리프.md</guid><pubDate>Wed, 25 Jun 2025 02:09:21 GMT</pubDate></item><item><title><![CDATA[JPA]]></title><description><![CDATA[ 
 <br>우리는 개발자 =&gt; Srping Data JPA =&gt; JPA =&gt; 하이버네이트 =&gt; JDBC =&gt; MySQL의 형태로 사용할 예정<br>JPA를 설치하면 DB에 연결하지 않으면 실행이 안되는데 H2를 같이 깔면 H2가 메모리 모드로 작동시켜 실행할 수 있다.<br>자동 생성되는 ID값은 Reflections으로 final이어도 값을 넣어줌<br>
<a data-href="ORM" href="컴퓨터 공학\프로그램\데이터 베이스\ORM.html" class="internal-link" target="_self" rel="noopener nofollow">ORM</a>을 지원한다.<br><br>엔티티 객체를 생성할 때 Reflection을 사용하는데 기본 생성자가 필요하다.<br>
기본 생성자가 <br><br><br>JPA는 메소드를 만들어두면 자동으로 메소드를 만들어준다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\JPA\JPA.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/JPA/JPA.md</guid><pubDate>Mon, 23 Jun 2025 01:27:11 GMT</pubDate></item><item><title><![CDATA[JPA 명명 규칙]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\JPA\JPA 명명 규칙.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/JPA/JPA 명명 규칙.md</guid><pubDate>Tue, 17 Jun 2025 06:22:37 GMT</pubDate></item><item><title><![CDATA[JPA 세팅]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\JPA\JPA 세팅.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/JPA/JPA 세팅.md</guid><pubDate>Wed, 11 Jun 2025 05:15:23 GMT</pubDate></item><item><title><![CDATA[JPA Orphan]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\JPA\JPA Orphan.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/JPA/JPA Orphan.md</guid><pubDate>Tue, 24 Jun 2025 06:13:58 GMT</pubDate></item><item><title><![CDATA[트랜잭션 = 영속성 컨텍스트]]></title><description><![CDATA[ 
 <br><br><br>트랜잭션 안에서 값을 수정하고 나서 save를 하지 않아도 변경을 눈치채서 save를 해줌<br><br>Transactional 어노테이션을 하면 런타임 에러의 경우 Rollback을 하지만<br>
그 외의 오류에는 Rollback을 하지 않음 그래서 Rollback 어노테이션을 통해 항상 rollback되게 함<br><br>자동으로 Rollback을 붙인다.(main 폴더 내에서는 작동 안함)<br><br>Transaction을 시작할 때 auto commit 을 끄는 과정을 거치는데<br>
auto commit을 끄는 설정을 해두면 불필요한 쿼리가 사라진다.<br>
Application.yml에서 수정가능<br><br>트랜잭션이 끝난 후 수행되어야 하는 더티체킹 및 여러가지 작업을 수행한다.<br>
rollback을 하면 취소된다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\JPA\JPA Transaction.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/JPA/JPA Transaction.md</guid><pubDate>Mon, 30 Jun 2025 05:07:35 GMT</pubDate></item><item><title><![CDATA[예시]]></title><description><![CDATA[ 
 <br><br>Controller가 ResponseEntity를 반환하게 만들지 않으면서 상태코드를 수정하고 싶을 때<br>
<a data-href="Python" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python.html" class="internal-link" target="_self" rel="noopener nofollow">Python</a>의 <a data-tooltip-position="top" aria-label="Python Decorator" data-href="Python Decorator" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python Decorator.html" class="internal-link" target="_self" rel="noopener nofollow">Decorator</a>와 비슷한 구현방법인 것 같다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\REST\스프링부트 AOP.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/REST/스프링부트 AOP.md</guid><pubDate>Thu, 26 Jun 2025 07:28:40 GMT</pubDate></item><item><title><![CDATA[스프링부트 DTO]]></title><description><![CDATA[ 
 <br>프론트 엔드로 데이터를 보내기 위한 레이어를 추가한 것이다.<br>
최소한의 데이터를 가지는 것이 좋고 더 많은 데이터를 포함시켜야 하면<br>
새로 더 만들어서 사용하면 된다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\REST\스프링부트 DTO.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/REST/스프링부트 DTO.md</guid><pubDate>Thu, 26 Jun 2025 05:34:22 GMT</pubDate></item><item><title><![CDATA[스프링]]></title><description><![CDATA[ 
 <br><a data-href="Java" href="컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java.html" class="internal-link" target="_self" rel="noopener nofollow">Java</a>기반의 웹 프레임워크]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링.md</guid><pubDate>Tue, 24 Jun 2025 07:40:10 GMT</pubDate></item><item><title><![CDATA[빈]]></title><description><![CDATA[ 
 <br><a data-href="스프링" href="컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링.html" class="internal-link" target="_self" rel="noopener nofollow">스프링</a>의 복잡한 설정 과정을 간소화 시킨 것<br><br>@Component, @Service, @Repository, @Controller등의 어노테이션을 붙이면 빈으로 등록되고<br>
스프링 컨테이너에 의해 생성되고 다른 빈에 주입이 가능하다.<br>
빈은 싱글톤으로 관리되고 애플리케이션 전체에서 하나의 인스턴스로만 사용된다.<br><br>Spring Data JPA가 제공하는 인터페이스로 CRUD 작업을 위한 메서드를 포함한다.<br><br>이걸 통해 만들면 복잡한 객체를 만들 수 있고 여러 개를 만들 수 있다.<br><br>로 만들면 한개만 만들어지고 단순한 생성법어어야 한다.<br><br><br>스프링부트 어플리케이션이 시작될 때 자동으로 실행된다.<br>
run(ApplicationArguments args) 메서드를 구현해야한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링 부트.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링 부트.md</guid><pubDate>Mon, 23 Jun 2025 01:48:22 GMT</pubDate></item><item><title><![CDATA[스프링부트 세팅]]></title><description><![CDATA[ 
 <br>컴파일 옵션에 "-parameters" 옵션을 추가한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링부트 세팅.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링부트 세팅.md</guid><pubDate>Mon, 23 Jun 2025 01:49:30 GMT</pubDate></item><item><title><![CDATA[스프링부트 흐름]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링부트 흐름.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링부트 흐름.md</guid><pubDate>Fri, 04 Jul 2025 03:43:57 GMT</pubDate></item><item><title><![CDATA[스프링부트 HTML 이동]]></title><description><![CDATA[ 
 <br>Contorller 메소드에서 문자열을 반환하면 해당 경로의 HTML로 연결된다.<br>예를 들어 POST 매핑하는 메소드에서 <a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>을 이동하면 해당 경로의 POST 요청을 하게된다.<br>
그래서 새로고침을 하면 같은 POST 요청을 날리기도 하고<br>
다른 곳에 갔다가 뒤로가기를 통해서도 POST 요청을 날린다.<br>
그래서 redirect:를 붙여 302 <a data-href="상태 코드" href="컴퓨터 공학\인터넷\web\back end\상태 코드.html" class="internal-link" target="_self" rel="noopener nofollow">상태 코드</a>를 가지게 한다.<br>
그러면 POST 요청에서 바로 GET 요청으로 해당 HTML로 이동한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링부트 HTML 이동.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링부트 HTML 이동.md</guid><pubDate>Thu, 03 Jul 2025 08:34:07 GMT</pubDate></item><item><title><![CDATA[스프링부트 TDD]]></title><description><![CDATA[ 
 <br>Service, Repository를 만들 때 TDD로 만들지 않아도 된다.<br>Controller는 꼭 TDD로 만들어야 한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링부트 TDD.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링부트 TDD.md</guid><pubDate>Thu, 26 Jun 2025 06:05:07 GMT</pubDate></item><item><title><![CDATA[REST API]]></title><description><![CDATA[ 
 <br>controller의 매개변수에 어노테이션을 넣어 조건을 만족하는지 확인한다.<br>
클래스에 @Validated를 적어야 한다.<br>
만약 class를 만들어 Form을 만들면 @Validated를 없애도 된다.<br><br>아이디와 비밀번호를 서버에 전송해서 해당 유저에 맞는 서비스를 제공하는 방식도 있고<br>
로그인을 하면 API 키를 제공해서 API키를 통해 유저에 맞는 서비스를 제공하게 하는 방식도 있다.<br>
API 키의 경우 경로에 같이 넣어서 사용할 수는 있지만 보안상 문제가 발생할 가능성이 있기에<br>
헤더에 넣어서 요청을 한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링부트 Validation.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/스프링 부트/스프링부트 Validation.md</guid><pubDate>Fri, 04 Jul 2025 08:54:55 GMT</pubDate></item><item><title><![CDATA[Flask]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\Flask\Flask.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/Flask/Flask.md</guid><pubDate>Mon, 30 Jun 2025 08:13:23 GMT</pubDate></item><item><title><![CDATA[생성]]></title><description><![CDATA[ 
 <br>React 컴포넌트를 통한 클라이언트 기능과 API 기능 및 서버 컴포넌트를 통한 서버 기능을 가진 프레임워크다.<br>기본적으로 사용하는 포트는 3000이다.<br><br>npx create-next-app@latest
<br><br><br><br><br><br>npm run dev
<br>로 실행이 가능하다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\Next.js\Next.js.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/Next.js/Next.js.md</guid><pubDate>Thu, 03 Jul 2025 00:05:54 GMT</pubDate></item><item><title><![CDATA[Next.js 라우터]]></title><description><![CDATA[ 
 <br>라우터를 통해 다른 페이지로 이동시킬 수 있다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\Next.js\Next.js 라우터.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/Next.js/Next.js 라우터.md</guid><pubDate>Wed, 02 Jul 2025 08:44:52 GMT</pubDate></item><item><title><![CDATA[Next.js 파일 분리]]></title><description><![CDATA[ 
 <br>폴더로 분리하면 된다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\Next.js\Next.js 파일 분리.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/Next.js/Next.js 파일 분리.md</guid><pubDate>Tue, 01 Jul 2025 07:16:58 GMT</pubDate></item><item><title><![CDATA[Next.js env]]></title><description><![CDATA[ 
 <br>프로젝트 폴더에 .env 파일을 만들고<br>
NEXTPUBLIC를 앞에 붙이고 변수처럼 만들어 두면<br>
소스코드에서 process.env.NextPUBLIC... 로 불러 올 수 있다.<br>
선언할 때 " 안붙여도 된다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\Next.js\Next.js env.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/Next.js/Next.js env.md</guid><pubDate>Wed, 02 Jul 2025 00:43:33 GMT</pubDate></item><item><title><![CDATA[멱등성]]></title><description><![CDATA[ 
 <br>같은 작업을 여러 번 해도 결과가 달라지지 않는 성질<br>GET, PUT, DELETE는 멱등성이 있고<br>
POST는 멱등성이 없다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\멱등성.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/멱등성.md</guid><pubDate>Mon, 23 Jun 2025 01:14:45 GMT</pubDate></item><item><title><![CDATA[Model]]></title><description><![CDATA[ 
 <br>Model, View, Controller의 형태로 나눈 것이다.<br><br>데이터를 저장하는 공간이다.<br><br><a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>, <a data-href="CSS" href="컴퓨터 공학\인터넷\web\front end\CSS\CSS.html" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>를 통해 표현하는 부분이다.<br><br>Model의 데이터를 View에 연결해서 사용자가 상호작용을 할 수 있게 제어하는 파트<br><br>Spring<br>
Lalabel<br>
Django<br>
Ruby on Rails<br>
Play<br>
Angular]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\MVC 웹 프레임워크.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/MVC 웹 프레임워크.md</guid><pubDate>Wed, 18 Jun 2025 07:30:49 GMT</pubDate></item><item><title><![CDATA[인터페이스]]></title><description><![CDATA[ 
 <br><br>서로 소통하기 위한 도구<br><br>앱 간 소통하기 위한 도구<br><br>각 요청이 어떤 동작이나 정보를 위한 것인지를 유추 가능하다.<br><br>예를 들어 책의 경우<br>
URI 뒤에 /books를 붙이고<br>
그 뒤에 /id 값을 통해 어느 값에 대한 API인지 알 수 있다.<br><br>Hypermedia<br>
As<br>
The<br>
Engine<br>
Of<br>
Application State<br>
로 각 요청의 응답에 가용한 다른 요청들의 정보를 포함시키는 것을 말한다.<br><br>클라이언트의 상태 정보가 서버에 저장되지 않는다.<br><br>클라이언트가 같은 요청을 몇 번을 보내든 언제나 같은 답이 돌아와야 한다.<br><br>한번 얻어낸 데이터를 또 쓸 수 있도록 저장해 두는 것 = 캐싱<br><br>
<br>


<br>


<br>


<br>

를 의미한다.
<br><br>get, delete, post, put, patch를 사용하는데<br>
post, put, patch는 body가 있어서 데이터를 더 많이 그리고 감춰서 보낼 수 있다.<br>
post로 CRUD를 만들 수 있지만 <a data-href="REST  API" href="REST  API" class="internal-link" target="_self" rel="noopener nofollow">REST  API</a>는 다 사용한다.<br><br>Read 조회할 때 사용함<br>
query parameter로 필터링 기능을 쓸 수 있음<br>
필터링 없으면 너무 많기에 페이지 기능을 사용한다.<br>ID값이 있다면 하나를 의미함<br><br>Create 새로운 정보를 추가하는데 사용함<br>
데이터를 추가하면 자동으로 추가되는 값도 함께 돌려준다.<br><br>데이터를 전부 수정할 때 사용한다.<br>
데이터를 보낼때 모든 값을 같이 보낸다.<br>
결과로는 해당 요청의 실행 성공 여부를 보낼 수 있다.<br>
아니면 수정된 결과 전체를 보여주기도 한다.<br><br>데이터의 일부를 수정할 때 사용한다.<br>
데이터를 보낼때 일부만 보낸다.<br>
결과로는 해당 요청의 실행 성공 여부를 보낼 수 있다.<br>
아니면 수정된 결과 전체를 보여주기도 한다.<br><br>데이터를 삭제할 때 사용한다.<br><br>꼭 구현해야하는 건 아니다.<br><br>매핑을 /api/v1/posts 처럼 작성하고<br>
만약에 변경하면 /api/v2/posts로 작성하고 프론트 팀에게 선택권을 주고<br>
프론트에서 다 옮겼다고 판단하면 v1을 없애는 식으로 사용가능하다.<br><br>데이터 이름을 수정하는데 엔티티 클래스를 수정하면 이것 저것에 수정해야하는 것이 많다.<br>
따라서 DTO도입을 해서 하나의 레이어를 추가해줘야 한다.]]></description><link>컴퓨터 공학\프레임워크\웹 프레임워크\REST API.html</link><guid isPermaLink="false">컴퓨터 공학/프레임워크/웹 프레임워크/REST API.md</guid><pubDate>Wed, 25 Jun 2025 05:46:24 GMT</pubDate></item><item><title><![CDATA[<a data-href="Abstract-factory Pattern" href="컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Abstract-factory Pattern.html" class="internal-link" target="_self" rel="noopener nofollow">Abstract-factory Pattern</a>]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>이런 방식이 있다. 학문적으로 외우지만 말고 머리 속에 넣고 다니다가 무의식적으로 사용하게 되는 일이 오면 좋다.]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\디자인패턴.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/디자인패턴.md</guid><pubDate>Thu, 19 Jun 2025 07:40:34 GMT</pubDate></item><item><title><![CDATA[Abstract-factory Pattern]]></title><description><![CDATA[ 
 <br><a data-href="Factory-method Pattern" href="컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Factory-method Pattern.html" class="internal-link" target="_self" rel="noopener nofollow">Factory-method Pattern</a> 또한 묶어서 한 메소드에서 팩토리 여러개를 하나로 추상화 함]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Abstract-factory Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Abstract-factory Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:35:44 GMT</pubDate></item><item><title><![CDATA[Adapter Pattern]]></title><description><![CDATA[ 
 <br>다른 곳에서 짠 코드를 가져올 때 호환이 되지 않을 경우 호환되게 클래스를 만들어 주는 방식]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Adapter Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Adapter Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:35:57 GMT</pubDate></item><item><title><![CDATA[Command Pattern]]></title><description><![CDATA[ 
 <br>여러 개의 다양한 동작을 하나의 메소드로 실행하게 해두고<br>
각각의 동작을 클래스로 만들어 배열에 넣어서 하나하나 실행하게 함]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Command Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Command Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:36:02 GMT</pubDate></item><item><title><![CDATA[Composite Pattern]]></title><description><![CDATA[ 
 <br>파일과 폴더를 하나로 묶어서 구현한다고 보면 됨<br>
그렇게 하나의 폴더의 사이즈를 구하면 자식의 것도 같이 구해서 가져오는 방식]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Composite Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Composite Pattern.md</guid><pubDate>Thu, 19 Jun 2025 03:24:34 GMT</pubDate></item><item><title><![CDATA[Decorator Pattern]]></title><description><![CDATA[ 
 <br>한 클래스를 상속해 데코레이터를 만들고 생성자로 그 클래스를 받는 다면<br>
데코레이터 안에 데코레이터를 넣을 수 있고 각 데코레이터가 자기만의 메소드를 가지고 있고 부모 클래스의 메소드를 실행한 후 자기의 메소드를 실행하게 하면<br>
재귀적으로 그 메소드를 실행하게 할 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Decorator Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Decorator Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:36:10 GMT</pubDate></item><item><title><![CDATA[Facade Pattern]]></title><description><![CDATA[ 
 <br>여러 객체들의 상호작용을 사용자가 몰라도 되게 함수 하나 실행하면 되게 하는 방법<br>
일반적으로 사용하는 방법]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Facade Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Facade Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:36:27 GMT</pubDate></item><item><title><![CDATA[Factory-method Pattern]]></title><description><![CDATA[ 
 <br>객체를 생성하는 곳을 한 메소드에서 반환하게 만드는 방식]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Factory-method Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Factory-method Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:36:58 GMT</pubDate></item><item><title><![CDATA[Mediator Pattern]]></title><description><![CDATA[ 
 <br>상태가 변할 때 상태를 전달할 클래스를 두는 것]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Mediator Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Mediator Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:37:03 GMT</pubDate></item><item><title><![CDATA[Proxy Pattern]]></title><description><![CDATA[ 
 <br>예를 들어 가벼운 작업과 무거운 작업이 있을 때 가벼운 작업은 바로 실행하고 무거운 작업을 실행하려고 하면 그 때 무거운 작업을 실행하는 클래스를 가져오는 방식<br>
한번에 여러 개의 무거운 작업을 하지 않고 필요할 때만 무거운 작업을 하는 방식임]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Proxy Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Proxy Pattern.md</guid><pubDate>Thu, 19 Jun 2025 03:20:51 GMT</pubDate></item><item><title><![CDATA[Singletone Pattern]]></title><description><![CDATA[ 
 <br>static한 공간에 인스턴스를 두고 객체를 요청할 때마다 같은 객체를 제공하는 방식<br>
여러 공간에서 같은 객체가 필요할 경우 사용한다.<br>
하지만 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>에서 문제가 발생할 수 있어 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a> 사용시를 대비해야한다.]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Singletone Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Singletone Pattern.md</guid><pubDate>Thu, 19 Jun 2025 08:35:55 GMT</pubDate></item><item><title><![CDATA[State Pattern]]></title><description><![CDATA[ 
 <br>메소드가 실행되면 다른 객체로 변환됨]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\State Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/State Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:37:37 GMT</pubDate></item><item><title><![CDATA[Strategy Pattern]]></title><description><![CDATA[ 
 <br>필요한 기능을 인터페이스로 해두고 실행 동작은 여러 클래스가 상속해서 구현을 하고<br>
실행할 때 실행할 클래스를 갈아 끼우는 방식]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Strategy Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Strategy Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:37:21 GMT</pubDate></item><item><title><![CDATA[Template-method Pattern]]></title><description><![CDATA[ 
 <br>부모 클래스는 특정 메소드를 추상 메소드들로 실행을 하는데 자식 클래스는 이 추상메소드를 오버라이드를 해서 특정 메소드의 실행을 변경함<br>
특정 절차가 있을 때 사용하는 방식]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\Template-method Pattern.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/디자인패턴/Template-method Pattern.md</guid><pubDate>Thu, 19 Jun 2025 07:36:38 GMT</pubDate></item><item><title><![CDATA[객체]]></title><description><![CDATA[ 
 <br><br>상태가 있고 행동을 하는 실체<br>
인스턴스라고 부름<br><br>어떠한 속성이 있고 어떻게 행동하는지를 기술한 설계도]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\객체와 클래스.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/객체와 클래스.md</guid><pubDate>Sat, 07 Jun 2025 06:36:28 GMT</pubDate></item><item><title><![CDATA[은닉성]]></title><description><![CDATA[ 
 <br>코드를 좀 더 간단하게 하기 위한 프로그래밍 방법이다.<br>객체들의 상호작용으로 프로그램이 돌아간다.<br><br>외부에 공개를 하지 않아도 되는 내용은 감추고<br>
공개해도 되는 것만 공개를 하는 것<br>
외부에서 갑자기 수정했다가 다른 작업 중 발생하는 오류를 없앨 수 있다.<br><br>클래스의 비슷한 부분을 묶어서 세부사항은 다르지만 하나의 메소드를 동작시킬 수 있음<br>
클래스들을 묶어서 한 클래스에 넣을 수도 있다.<br><br>클래스에서 비슷한 부분을 묶어 추상 클래스를 만들 수 있고<br>
추상 클래스를 상속하는 자식 클래스는 메소드를 수정할 수 있다. 이를 오버라이딩이라고 한다.<br><br>이를 활용할 때 팁으로써 제공되는 패턴들이 있다.<br>
<a data-href="디자인패턴" href="컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\디자인패턴\디자인패턴.html" class="internal-link" target="_self" rel="noopener nofollow">디자인패턴</a>이 그것이다.]]></description><link>컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\객체지향 프로그래밍.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/객체지향 프로그래밍/객체지향 프로그래밍.md</guid><pubDate>Sat, 21 Jun 2025 14:17:37 GMT</pubDate></item><item><title><![CDATA[동기 프로그래밍]]></title><description><![CDATA[ 
 <br><br>연산 없이 기다려야 하는 상황에 기다림<br><br>연산 없이 기다려야 하는 상황에 다른 일을 함<br>
그러니까 보통 <a data-href="IO 작업" href="컴퓨터 공학\운영체제\IO 작업.html" class="internal-link" target="_self" rel="noopener nofollow">IO 작업</a>을 기다려야 할 때 사용한다.<br>
callback 함수를 통해 다 기다린 후 실행할 동작을 넣을 수도 있다.<br>
callback함수안에 callback 함수 안에 하는 반복되는 것은 callback 지옥이라고 불리는데<br>
너무 복잡하다.<br>
자바 스크립트에서는 Promise를 사용하기도 함<br>
async/await을 통해 더 간단하게 만들기도 함]]></description><link>컴퓨터 공학\프로그래밍\방법론\비동기 프로그래밍.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/비동기 프로그래밍.md</guid><pubDate>Wed, 02 Jul 2025 07:32:22 GMT</pubDate></item><item><title><![CDATA[절차지향 프로그래밍]]></title><description><![CDATA[ 
 <br>C언어의 방식이다.]]></description><link>컴퓨터 공학\프로그래밍\방법론\절차지향 프로그래밍.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/절차지향 프로그래밍.md</guid><pubDate>Sun, 22 Jun 2025 05:02:01 GMT</pubDate></item><item><title><![CDATA[함수형 프로그래밍]]></title><description><![CDATA[ 
 <br>절차지향 프로그래밍은 각 함수를 만들어 놓고 각 함수의 순서를 지정해서 각각 실행시킨다.<br>하지만 함수형 프로그래밍은 입력 값과 출력 값을 각 함수에 맞게 연결 시키고 실행시킨다.<br>
외부 요인에 영향을 받지 않는다.<br>함수형 프로그래밍은 실행되는 중에 외부에서 값을 변경하지 않으니까 문제가 발생하지 않는다.<br>
외부로부터 입력을 받고 실행하는 경우에도 사본을 만들고 실행하니까 문제가 발생하지 않는다.<br><br>A는 B다 라고 선언한다.<br>
결과 값이 항상 예측이 가능하다.<br><br>함수를 값처럼 사용할 수 있다.<br>함수에 함수를 매개 변수로 넣을 수 있음<br>
함수가 함수를 반환할 수 있다.<br><br>여러 인자를 받는 함수에 일부 인자만 넣어서 나머지 인자를 받는 다른 함수를 만들어 낼 수 있음<br>예시<br>def add_curry(num1:Int)(num2:Int): Int = num1 + num2
add_curry(2)(3)
val add2 = add_curry(2)(_)
add2(9)
<br><br>배열, 리스트 같은 여러 값을 담는 변수에 사용함<br>
filter, map 같은 함수로 보다 간략하게 표현한다.]]></description><link>컴퓨터 공학\프로그래밍\방법론\함수형 프로그래밍.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/방법론/함수형 프로그래밍.md</guid><pubDate>Sun, 08 Jun 2025 14:26:22 GMT</pubDate></item><item><title><![CDATA[대칭키]]></title><description><![CDATA[ 
 <br>대칭키는 암호화를 하는 키와 복호화를 하는 키가 같은 경우를 말한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\암호화\대칭키\대칭키.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/암호화/대칭키/대칭키.md</guid><pubDate>Mon, 30 Jun 2025 07:23:25 GMT</pubDate></item><item><title><![CDATA[AES]]></title><description><![CDATA[ 
 <br>대칭형, 블럭 암호화 알고리즘이다.<br>암호화 키는 128, 192, 256의 세 가지 중 하나가 될 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\암호화\대칭키\AES.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/암호화/대칭키/AES.md</guid><pubDate>Mon, 30 Jun 2025 07:35:26 GMT</pubDate></item><item><title><![CDATA[비대칭키]]></title><description><![CDATA[ 
 <br>암호화키와 복호화키가 다른 암호화 방식이다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\암호화\비대칭키\비대칭키.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/암호화/비대칭키/비대칭키.md</guid><pubDate>Mon, 30 Jun 2025 07:33:22 GMT</pubDate></item><item><title><![CDATA[RSA]]></title><description><![CDATA[ 
 <br>두 개의 소수를 곱하는 과정은 쉽지만 곱해진 수에서<br>
어느 소수가 곱해져 있는 지 파악하는 건 어렵다는 이유로 만들어진 암호화 방법이다.<br>그래서 풀려면 무작위 대입을 해야하는데 그 당시 컴퓨터 중 평생을 써도 못 풀어낼 정도의 시간이 걸리게 만든다.<br>
그리고 공개키와 개인 키를 분리해서 서버와 클라이언트의 구조인 웹 보안에 쓰기 좋다.<br>
하지만 암호화와 복호화 시간이 오래 걸리기 때문에 서로의 신원을 확인하면 AES로 암호화 복호화를 하며 데이터를 주고 받는다.<br>서로의 신원을 확인하는게 전자서명이다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\암호화\비대칭키\RSA.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/암호화/비대칭키/RSA.md</guid><pubDate>Thu, 26 Jun 2025 08:24:05 GMT</pubDate></item><item><title><![CDATA[암호화]]></title><description><![CDATA[ 
 <br>크게 <a data-href="대칭키" href="컴퓨터 공학\프로그래밍\알고리즘\암호화\대칭키\대칭키.html" class="internal-link" target="_self" rel="noopener nofollow">대칭키</a>와 <a data-href="비대칭키" href="컴퓨터 공학\프로그래밍\알고리즘\암호화\비대칭키\비대칭키.html" class="internal-link" target="_self" rel="noopener nofollow">비대칭키</a>로 이루어져 있다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\암호화\암호화.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/암호화/암호화.md</guid><pubDate>Mon, 30 Jun 2025 06:19:49 GMT</pubDate></item><item><title><![CDATA[salt]]></title><description><![CDATA[ 
 <br>단반향으로 암호화를 하는 것이다.<br>
그러니까 한번 암호화를 하고 원래 어느 문자열이었는지를 확인을 못하게 만들었다.<br>
이걸 어디에 사용하냐면<br>
비밀번호를 저장할 때 사용한다.<br>
왜냐하면 원래의 값을 저장할 필요가 없다.<br>
비밀번호를 입력하면 그 비밀번호 문자열을 암호화해서 비교하면 되니까<br>
그래서 만약에 서버에 저장된 비밀번호가 털린다고 해도 원래의 문자열이 무엇이었는지는 모르기에<br>
무작위 대입만이 가능하다.<br><br>hash 암호화 만으로는 완전한 건 아닌데 사람들이 주로 사용하는 약한 비밀번호에 대해서는 이미 해커들이 hash된 값으로 가지고 있다.<br>
따라서 salt를 추가해서 위의 사례를 무력화시킨다.<br>
간단하게 평문 비밀번호를 받으면 거기에 랜덤으로 salt 문자열을 추가해서 해시 함수를 돌리고<br>
암호화된 비밀번호와 salt 값을 같이 저장하는 것이다.<br>
조금의 차이가 발생해도 해시 함수를 돌리면 급격하게 차이가 난다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\암호화\해시 암호화.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/암호화/해시 암호화.md</guid><pubDate>Mon, 30 Jun 2025 07:47:12 GMT</pubDate></item><item><title><![CDATA[CNN]]></title><description><![CDATA[ 
 <br>이미지의 패턴을 찾는 것을 잘하는 모델이고<br>이미지를 Convolution을 통해 크기를 줄인다.<br>
크기를 줄인 것을 학습해서 <a data-href="분류" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\활용\분류\분류.html" class="internal-link" target="_self" rel="noopener nofollow">분류</a>를 한다.<br>그러니까 예를 들어 강아지와 고양이를 구분할 때 사용한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\CNN.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/모델/CNN.md</guid><pubDate>Mon, 30 Jun 2025 08:19:08 GMT</pubDate></item><item><title><![CDATA[GAN]]></title><description><![CDATA[ 
 <br>랜덤으로 노이즈를 만들고 그 노이즈를 복원시키는 방식이다.<br>
그리고 복원시킨 그림이 실제 사진인지 판별을 시켜서 점점 실제와 비슷하게 그리게 한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\GAN.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/모델/GAN.md</guid><pubDate>Mon, 30 Jun 2025 08:25:47 GMT</pubDate></item><item><title><![CDATA[LSTM]]></title><description><![CDATA[ 
 <br>Long Short Term Memory의 약자로<br><a data-href="RNN" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\RNN.html" class="internal-link" target="_self" rel="noopener nofollow">RNN</a>에서는 기억이 쉽게 사라지는 문제가 있어서<br>
오래 기억해야하는 기억과 짧게 기억해야하는 기억을 구분해서 기억해서<br>
<a data-href="RNN" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\RNN.html" class="internal-link" target="_self" rel="noopener nofollow">RNN</a>의 문제를 해결한 모델이다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\LSTM.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/모델/LSTM.md</guid><pubDate>Mon, 30 Jun 2025 08:22:42 GMT</pubDate></item><item><title><![CDATA[RNN]]></title><description><![CDATA[ 
 <br>Recurrent Neural Network 순환 신경망을 의미하며<br>순차적 정보가 담긴 데이터에서 규칙적인 패턴을 인식하고 추상화된 정보를 추출한다.<br>이전에 입력된 값을 기억해서 학습하는 구조다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\RNN.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/모델/RNN.md</guid><pubDate>Mon, 30 Jun 2025 08:21:11 GMT</pubDate></item><item><title><![CDATA[Transformer]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\모델\Transformer.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/모델/Transformer.md</guid><pubDate>Mon, 30 Jun 2025 08:16:17 GMT</pubDate></item><item><title><![CDATA[딥러닝]]></title><description><![CDATA[ 
 <br><a data-href="Multi-Layer Perceptron" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\Multi-Layer Perceptron.html" class="internal-link" target="_self" rel="noopener nofollow">Multi-Layer Perceptron</a>에 <a data-href="활성화 함수" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\활성화 함수.html" class="internal-link" target="_self" rel="noopener nofollow">활성화 함수</a>를 추가하며<br>
비선형적으로 바뀌어 층을 나누어 구분한 것이 의미가 생기는 방식이다.<br>
간단하게 말하면 함수 안에 if문을 추가한 것으로 생각하면 좋다.<br><a data-href="XOR 문제" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\인공지능 문제\XOR 문제.html" class="internal-link" target="_self" rel="noopener nofollow">XOR 문제</a>를 풀 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\딥러닝.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/딥러닝.md</guid><pubDate>Sat, 21 Jun 2025 13:12:34 GMT</pubDate></item><item><title><![CDATA[역전파 알고리즘]]></title><description><![CDATA[ 
 <br>입력층에서 부터 출력층까지 순서로 최적화 알고리즘을 적용시키면 순전파 알고리즘이라고 하는데<br>
반대로 출력층에서 입력층 순서로 최적화 알고리즘을 적용시키는 것을 역전파 알고리즘이라고 한다.<br>순전파 알고리즘의 경우 최적화 하는 과정에서 값이 너무 많이 튀는데 간단하게 생각하면<br>
활을 쏘는데 목적지에 맞지 않아서 떨어진 위치를 보고 목적지에 맞게  조금 각도를 수정해서 쏴보고 또 안맞으면 각도를 수정해서 쏴보고 하는 것인데<br>
만약에 한번 쏴보고 떨어진 위치로 가서 목적지와 얼마나 떨어졌는지 확인하고 각도를 조절하는데 활 쏘는 곳에서의 각도는 어떨지를 계산하는 것이다.<br>
그러면 전보다는 잘 맞을 것이다.<br>간단하게 설명하느라 약간의 오류가 있긴 하지만 순전파 알고리즘은 값을 수정하면 입력층에서의 나비효과로 결과에 영향이 커서 학습에 시간이 많이 걸린다는 것이고<br>
역전파 알고리즘은 답을 맞춰놓고 입력층까지의 층에 최적화를 진행하여 시간이 줄어든다는 것이다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\역전파 알고리즘.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/역전파 알고리즘.md</guid><pubDate>Fri, 27 Jun 2025 08:36:31 GMT</pubDate></item><item><title><![CDATA[활성화 함수]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\딥러닝\활성화 함수.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/딥러닝/활성화 함수.md</guid><pubDate>Sat, 21 Jun 2025 12:59:15 GMT</pubDate></item><item><title><![CDATA[최적화 알고리즘]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\최적화 알고리즘\최적화 알고리즘.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/최적화 알고리즘/최적화 알고리즘.md</guid><pubDate>Fri, 27 Jun 2025 08:26:05 GMT</pubDate></item><item><title><![CDATA[머신러닝]]></title><description><![CDATA[ 
 <br>말 그대로 기계가 학습하는 것을 말한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\머신러닝.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/머신러닝.md</guid><pubDate>Sun, 22 Jun 2025 08:04:22 GMT</pubDate></item><item><title><![CDATA[Multi-Layer Perceptron]]></title><description><![CDATA[ 
 <br>입력을 받는 부분 내부적으로 연산하는 부분 출력하는 부분을 나눠서 만든 <a data-href="Perceptron" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\Perceptron.html" class="internal-link" target="_self" rel="noopener nofollow">Perceptron</a>입니다.<br>
층을 여러개로 나눴다고 해서 Multi-Layer입니다.<br>
역시 선형적인 문제를 해결합니다.<br>
사실상 일반 <a data-href="Perceptron" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\Perceptron.html" class="internal-link" target="_self" rel="noopener nofollow">Perceptron</a>과 차이는 없습니다.<br>
다시 한 개의 층으로 변환이 가능하거든요.<br>
일차 방정식인데 기본 Perceptron 방정식에 함수를 넣은 겁니다.<br>
f(x,y,z) = ax + by + cz(a,b,c는 상수)<br>
k(i) = qi(q는 상수)<br>
g(x) = d * f(e, f, g) + h(p) (d, e,f,g,p 는 상수)<br><a data-href="XOR 문제" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\인공지능 문제\XOR 문제.html" class="internal-link" target="_self" rel="noopener nofollow">XOR 문제</a>를 해결하지 못한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\Multi-Layer Perceptron.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/Multi-Layer Perceptron.md</guid><pubDate>Sun, 22 Jun 2025 08:04:56 GMT</pubDate></item><item><title><![CDATA[Perceptron]]></title><description><![CDATA[ 
 <br>다수의 입력으로 결과를 내는 방식이다.<br>
선형적인 결과를 내는데<br>
일차 방정식을 생각하면 된다. 근데 미지수가 여러개인걸 생각하면 됩니다.<br>
f(x)= ax + by + cz + d (a,b,c,d 는 상수)<br>여기서 a,b,c,d의 값을 편미분을 통해 이전 값과 비교해 얼마나 예측의 값으로부터 가까워졌는지 확인해 값에 어느 +,- 중 어느 방향으로 더하면 예측 값에 더 가까워지는지 판단한다.<br><a data-href="XOR 문제" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\인공지능 문제\XOR 문제.html" class="internal-link" target="_self" rel="noopener nofollow">XOR 문제</a>를 해결하지 못한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\머신러닝\Perceptron.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/머신러닝/Perceptron.md</guid><pubDate>Sat, 21 Jun 2025 13:12:44 GMT</pubDate></item><item><title><![CDATA[어려운 이유]]></title><description><![CDATA[ 
 <br>직선 두 개를 평행하게 긋고<br>
직선 사이를 A 영역이라고 부르고<br>
직선 바깥쪽을 B영역이라고 부를 때<br>
각 위치가 어느 영역인지 인공지능에게 분리 시킬 때<br>
성공적으로 분리하는지?<br><br>선형적으로 풀려면 선을 하나를 그어서 구분을 해야한다.<br>
하지만 선 하나로는 구분이 되지 않는다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\인공지능 문제\XOR 문제.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/인공지능 문제/XOR 문제.md</guid><pubDate>Sat, 28 Jun 2025 06:10:22 GMT</pubDate></item><item><title><![CDATA[유전자 알고리즘]]></title><description><![CDATA[ 
 <br>딥러닝 방식이지만 딥러닝은 결과 값에 근접하게 값을 수정하지만<br>
유전자 알고리즘은 랜덤으로 값을 변경한다.<br>
결과적으로는 딥러닝과 유사한 결과를 얻을 수는 있을 거지만 효율이 낮다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\유전자 알고리즘.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/유전자 알고리즘.md</guid><pubDate>Sat, 21 Jun 2025 13:04:33 GMT</pubDate></item><item><title><![CDATA[인공지능]]></title><description><![CDATA[ 
 <br>인공지능의 기준은 계속 바뀌어 왔다.<br>개발자가 전부 다 코딩하여 상황에 맞게 판단하는 것도 인공지능의 경지였다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\인공지능\인공지능.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/인공지능/인공지능.md</guid><pubDate>Sat, 21 Jun 2025 13:02:37 GMT</pubDate></item><item><title><![CDATA[Heap Sort]]></title><description><![CDATA[ 
 <br>우선순위가 있는 <a data-href="Heap" href="컴퓨터 공학\프로그래밍\자료 구조\Heap.html" class="internal-link" target="_self" rel="noopener nofollow">Heap</a>자료구조에 데이터를 넣고 뺀다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(NlogN)\Heap Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(NlogN)/Heap Sort.md</guid><pubDate>Sat, 21 Jun 2025 03:59:34 GMT</pubDate></item><item><title><![CDATA[Merge Sort]]></title><description><![CDATA[ 
 <br>2개씩 재귀적으로 나누어 합칠 때 순서에 맞게 합쳐 정렬한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(NlogN)\Merge Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(NlogN)/Merge Sort.md</guid><pubDate>Sat, 21 Jun 2025 03:59:00 GMT</pubDate></item><item><title><![CDATA[Quick Sort]]></title><description><![CDATA[ 
 <br>특정 기준으로 비교할 요소를 선택하고 그 요소를 기준으로 왼쪽 오른쪽으로 나누고 왼쪽 오른쪽에 Quick Sort를 진행해 재귀적으로 나누고<br>
합치면서 순서에 맞게 합쳐 정렬한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(NlogN)\Quick Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(NlogN)/Quick Sort.md</guid><pubDate>Sat, 21 Jun 2025 04:00:49 GMT</pubDate></item><item><title><![CDATA[Tim sort]]></title><description><![CDATA[ 
 <br>Timsort란 2002년 소프트웨어 엔지니어 Tim Peters에 의하여 만들어진 알고리즘으로, 앞에서 언급했던&nbsp;Insert sort와 Merge sort를 결합하여 만든 Hybrid stable sorting 알고리즘입니다.<br>이 알고리즘은&nbsp;미리 어느 정도 정렬된 부분이 존재하는&nbsp;실생활 데이터의 특성을 고려하여 더 빠르게 작동하도록 고안된 알고리즘으로, 최선의 시간복잡도는&nbsp;O(n), 평균은&nbsp;O(nlogn), 최악은&nbsp;O(nlogn)의 시간복잡도를 보여줍니다.<br>
<a data-tooltip-position="top" aria-label="https://yuja-kong.tistory.com/183" rel="noopener nofollow" class="external-link" href="https://yuja-kong.tistory.com/183" target="_blank">출처 링크</a>]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(NlogN)\Tim sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(NlogN)/Tim sort.md</guid><pubDate>Sat, 21 Jun 2025 14:24:08 GMT</pubDate></item><item><title><![CDATA[Bubble Sort]]></title><description><![CDATA[ 
 <br>0번 부터 n-1번까지 두 개씩 n번 비교해 정렬한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(square(N))\Bubble Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(square(N))/Bubble Sort.md</guid><pubDate>Fri, 20 Jun 2025 10:14:18 GMT</pubDate></item><item><title><![CDATA[Insert Sort]]></title><description><![CDATA[ 
 <br>정렬된 배열과 기존 배열이 있으면 정렬된 배열에 기존 배열로부터 하나씩 데이터를 넣어가면서 정렬하는 방식이다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(square(N))\Insert Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(square(N))/Insert Sort.md</guid><pubDate>Sat, 21 Jun 2025 04:02:45 GMT</pubDate></item><item><title><![CDATA[Select Sort]]></title><description><![CDATA[ 
 <br>n번 순회하면서 정렬이 안된 요소 중 가장 우선순위가 높은 요소를 찾아 정렬한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\O(square(N))\Select Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/O(square(N))/Select Sort.md</guid><pubDate>Sat, 21 Jun 2025 03:58:02 GMT</pubDate></item><item><title><![CDATA[O(n^2)]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br><br><br>같은 시간 복잡도를 가졌다고 해서 속도가 같은 것은 아니다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\정렬.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/정렬.md</guid><pubDate>Wed, 25 Jun 2025 01:09:50 GMT</pubDate></item><item><title><![CDATA[Radix Sort]]></title><description><![CDATA[ 
 <br>기수 정렬로 불리며<br>
숫자를 정렬할 때 사용하고<br>
처음에는 0~9까지의 배열이 있을 때<br>
1의 자리에 해당되는 데이터를 넣고<br>
다넣고 나서 원래의 배열에 넣고<br>
10의 자리에 해당되는 데이터를 넣고 빼고<br>
하는 방식으로 정렬한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\정렬\Radix Sort.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/정렬/Radix Sort.md</guid><pubDate>Sat, 21 Jun 2025 04:06:04 GMT</pubDate></item><item><title><![CDATA[점근적 분석]]></title><description><![CDATA[ 
 <br><br>임의의 함수가 N-&gt; 무한 일 때<br>
어떤 함수 형태에 근접해지는 분석<br><br>함수의 실행 시간으 표현하는 것<br>
주로 점근적 분석을 통해 실행시간을 단순하게 표현하며<br>
이 때 점근적 표기법으로 표현함<br><br><br>빅 오메가와 빅 오가 같을 때 같은 값을 가짐<br>
tight한 bound를 묘사하는데 사용<br><br>하한선을 의미한다.<br>
최고의 결과를 상정한다.<br><br>상한선을 의미한다.<br>
최악의 결과를 상정한다.<br><br><br>최단 시간 실행<br><br>최장 시간 실행<br><br>일반적인 실행<br><br>log2(N)이지만 표기를 할 때 O(logN)으로 표현한다.<br><br>두 개를 각각 하나하나 검색할 경우<br>
실제로는 max(N,M)이지만 표기할 때 O(N+M)이다.<br>만약 N안에 M의 루프를 돌릴 경우<br>
O(N*M)으로 표기한다.<br><br>O(1) &lt; O(logN) &lt; O(N) &lt; O(N*logN) &lt; O(N^2) &lt; O(2^N) &lt; O(N!)<br>
순서다.<br><br>Upper bound를 알아도 충분함]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\시간 복잡도.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/시간 복잡도.md</guid><pubDate>Tue, 24 Jun 2025 07:56:03 GMT</pubDate></item><item><title><![CDATA[해시]]></title><description><![CDATA[ 
 <br>임의의 크기를 가진 데이터를 일정 고전된 크기로 변환시키는 것을 말한다.]]></description><link>컴퓨터 공학\프로그래밍\알고리즘\해시.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/알고리즘/해시.md</guid><pubDate>Fri, 27 Jun 2025 06:13:58 GMT</pubDate></item><item><title><![CDATA[레지스터]]></title><description><![CDATA[ 
 <br><br>al, ah, ax, eax, rax처럼 크기에 따라 다르게 부른다.<br>
참고로 크기에 따라 다르게 부르지만 이 집합은 같은 공간을 공유한다.<br>
여기에서 a는 레지스터 이름이고 뒤와 앞에 붙은 것은 크기를 구분한다.<br>
C언어의 Union과 비슷하다고 보면 된다.<br><br>al, ah를 말한다. 2바이트를 반으로 나눴을 때 숫자가 큰 방향이 ah, 숫자가 작은 방향에 있는 레지스터가 al이다.<br><br>ax를 말한다.<br><br>eax를 말한다.<br><br>rax를 말한다.<br><br><br>초기화가 된 데이터를 설정할 때 사용한다.<br><br>초기화가 되지않은 데이터를 설정할 때 사용한다.<br><br>자주 쓰이는 부분의 코드를 <br><br>byte는 1바이트를 말한다.<br>
word는 2바이트를 말한다.<br>
double word는 4바이트를 말한다.<br>
quard word는 8바이트를 말한다.<br>
<a data-href="RISC-V 어셈블리" href="컴퓨터 공학\프로그래밍\언어\어셈블리\RISC\RISC-V 어셈블리.html" class="internal-link" target="_self" rel="noopener nofollow">RISC-V 어셈블리</a>와는 다른 크기를 말하니까 조심해야한다.<br><br>4바이트 변수까지만 사용할 수 있다.<br><br>8바이트 변수까지만 사용할 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\언어\어셈블리\CISC\X86 어셈블리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/어셈블리/CISC/X86 어셈블리.md</guid><pubDate>Tue, 01 Jul 2025 00:54:12 GMT</pubDate></item><item><title><![CDATA[ARM 어셈블리]]></title><description><![CDATA[ 
 <br>필자는 잘 모른다.<br>하지만 ARM은 Arcorn RISC Machine이라서 어느정도 공통점을 가지고는 있을 거 같지만<br>
명령어가 다르다.<br>64비트짜리 32개의 레지스터를 가지고 있을 거다.]]></description><link>컴퓨터 공학\프로그래밍\언어\어셈블리\RISC\ARM 어셈블리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/어셈블리/RISC/ARM 어셈블리.md</guid><pubDate>Tue, 24 Jun 2025 07:37:03 GMT</pubDate></item><item><title><![CDATA[레지스터]]></title><description><![CDATA[ 
 <br>64비트의 레지스터 32개를 가졌다.<br><br>0번 레지스터는 항상 0의 값을 가지고 값을 쓰는게 허용되지 않는다.<br>
1번 레지스터는 주소 값을 가지고 있다. 수정하지 말 것<br>
2번 레지스터는 스택 포인터를 가지고 있다. 필요에 따라 수정하면 된다.<br>
3번 레지스터는 전역 포인터를 가지고 있다.<br>
4번 레지스터는 스레드 포인터를 가지고 있다.<br>
5~7번 레지스터는 임시 값을 가질 때 사용한다.<br>
8~9번 레지스터는 Saved 값을 가질 때 사용한다.<br>
10~17번 레지스터는 매개변수값, 결과값을 가질때 사용한다.<br>
18~27번 레지스터는 Saved 값을 가질 때 사용한다.<br>
28~31번 레지스터는 임시 값을 가질 때 사용한다.<br><br>0~4번 레지스터<br><br>그 외 전부<br>
위는 관례 상으로 저렇게 쓰라는 거지 마음대로 써도 문제는 없다.<br><br>byte는 1바이트를 말하고<br>
halfword는 2바이트를 말하고<br>
word는 4바이트를 말하고<br>
doubleword는 8바이트를 말한다.<br>
<a data-href="X86 어셈블리" href="컴퓨터 공학\프로그래밍\언어\어셈블리\CISC\X86 어셈블리.html" class="internal-link" target="_self" rel="noopener nofollow">X86 어셈블리</a>와는 다른 크기를 말하니까 조심해야한다.<br><br><br>mov가 없다.<br>
따라서 예를들어 10번 레지스터에 값을 넣으려면<br>
add x10, x0<br>
를 통해 값을 대입한다.<br><br>두 개의 레지스터로 부터 더한 값을 한 레지스터로 넣는 작업을 한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\어셈블리\RISC\RISC-V 어셈블리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/어셈블리/RISC/RISC-V 어셈블리.md</guid><pubDate>Thu, 26 Jun 2025 08:39:15 GMT</pubDate></item><item><title><![CDATA[어셈블리어]]></title><description><![CDATA[ 
 <br>운영체제나 CPU 아키텍쳐에 따라 코딩이 달라진다.<br>그래서 어셈블리어롤 프로그램을 만드려면 해당 플랫폼에 종속되고<br>
다른 플랫폼에서도 지원하게 하려면 처음부터 다시 코딩을 해야한다.<br>그래서 만든게 <a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>다.]]></description><link>컴퓨터 공학\프로그래밍\언어\어셈블리\어셈블리어.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/어셈블리/어셈블리어.md</guid><pubDate>Thu, 26 Jun 2025 08:40:10 GMT</pubDate></item><item><title><![CDATA[Dart]]></title><description><![CDATA[ 
 <br>Flutter를 사용할 때 사용하는 언어다.<br>
<a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>와 비슷한 점이 있다.<br>
하지만 타입을 검사하는 언어라서 <a data-href="TypeScript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\TypeScript.html" class="internal-link" target="_self" rel="noopener nofollow">TypeScript</a>에 가깝다.<br>
<a data-href="객체지향 프로그래밍" href="컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\객체지향 프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">객체지향 프로그래밍</a>이다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Dart\Dart.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Dart/Dart.md</guid><pubDate>Fri, 27 Jun 2025 06:09:13 GMT</pubDate></item><item><title><![CDATA[async await]]></title><description><![CDATA[ 
 <br><br>함수에 async를 적으면 비동기 함수라는 것을 알려준다.<br>
그리고 반환 값으로는 항상 Future가 있어야 한다.<br>
await을 통해 <a data-href="IO 작업" href="컴퓨터 공학\운영체제\IO 작업.html" class="internal-link" target="_self" rel="noopener nofollow">IO 작업</a>을 통해 시간이 걸리는 작업을 기다리고 다음 줄을 실행하게 할 수 있다.<br>
자바 스크립트와 ]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Dart\Dart 비동기.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Dart/Dart 비동기.md</guid><pubDate>Tue, 01 Jul 2025 07:39:01 GMT</pubDate></item><item><title><![CDATA[<a data-href="Javascript 변수" href="컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript 변수.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript 변수</a>]]></title><description><![CDATA[ 
 <br>정적인 HTML에 동적인 면을 추가해주는 녀석<br>
객체 기반의 <a data-href="인터프리터 언어" href="컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\인터프리터 언어.html" class="internal-link" target="_self" rel="noopener nofollow">인터프리터 언어</a>다.<br>
구조적 프로그래밍과 <a data-href="함수형 프로그래밍" href="컴퓨터 공학\프로그래밍\방법론\함수형 프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">함수형 프로그래밍</a>을 지원한다.<br><br><br>function plus(a,b){
	return a+b;
}
<br>리턴 타입이랑 매개변수에 타입을 붙이지 않음<br>함수는 변수에 넣을 수 있음<br>const plus = function(a, b) {return a+b;}
<br>익명함수는<br>const plus = (a,b) =&gt; {
	return a+b;
}
<br>이렇게 가능<br>const plus = (a, b) =&gt; a+b;
<br>이렇게 줄이는거 가능<br><br><br>급한 일을 먼저 실행한 후 매개변수의 함수를 실행한다.<br>
따라서 HTML 중간에 넣어두면 HTML을 다 load하고 실행한다.<br><br>export를 통해 다른 자바 스크립트에서 사용할 수 있게 한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript.md</guid><pubDate>Wed, 02 Jul 2025 00:19:26 GMT</pubDate></item><item><title><![CDATA[Javascript 객체 요소 순회]]></title><description><![CDATA[ 
 <br>Object.entries()함수를 사용해야 한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript 객체 요소 순회.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript 객체 요소 순회.md</guid><pubDate>Fri, 27 Jun 2025 01:48:09 GMT</pubDate></item><item><title><![CDATA[var]]></title><description><![CDATA[ 
 <br>var let const로 나뉘어진다.<br><br>중복 선언과 재할당이 가능하다.<br>
선언이 되면 선언 전에도 참조가 가능한데 undefined가 뜨면서 에러가 발생하지 않는다.<br>
문제가 많으니 let을 사용하도록<br><br>중복 선언을 허용시키지 않으며 에러를 발생시킨다.<br>
재할당은 가능하다.<br><br>중복 선언과 재할당을 허용시키지 않는다.<br><br>number = 1;
console.log(`number = ${number}`);
<br>이런식으로 문자열에 변수를 넣을 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript 변수.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript 변수.md</guid><pubDate>Mon, 09 Jun 2025 00:22:53 GMT</pubDate></item><item><title><![CDATA[<a data-href="Javascript" href="컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a> 런타임 환경]]></title><description><![CDATA[ 
 <br><br>브라우저의 내부 구성도는 <br>
<br>자바스크립트 엔진
<br>Web API
<br>이벤트 루프
<br>태스크 큐<br>
가 있다.
<br><br>자바스크립트 엔진 내부에 존재한다.<br>
함수 호출과 관련된 정보를 관리하는 스택이다.<br>
함수가 호출되는 순서대로 쌓이고<br>
종료되는 순서대로 꺼낸다.<br>스택이 하나이기에 다른 일을 동시에 할 수 없다.<br><br>자바스크립트가 실행되는 런타임 환경에 존재하는 별도의 API<br>
브라우저 내에서 멀티 스레드로 동작<br>
비동기 동작을 수행하기 때문에 메인 스레드가 멈추는 것을 방지<br>
DOM, AJAX, Fetch, Timer, Promise, 이벤트 핸들러, 웹 워커 등으로 구성된다.<br><br>비동기 작업이 완료되면 실행되는 함수들이 대기하는 공간<br><br>우선순위가 높은 비동기 작업의 콜백을 담당한다.<br><br>일반적인 비동기 작업할 때 사용한다.<br><br>콜 스택과 태스크 큐를 모니터링하는 감시자다.<br>콜 스택이 비어있고<br>
태스크 큐에 작업이 있다는 것을 감지하고<br>
자바스크립트 엔진에게 알린다.<br>
자바스크립트 엔진이 태스크 큐에서 가장 오래된 콜백 함수를 콜 스택으로 이동한다.<br>마이크로 태스크 큐의 모든 작업을 먼저 처리한 후<br>
매크로 태스크 큐에서는 한번에 하나의 작업을 처리하고<br>
반복한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript 비동기 작동원리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript 비동기 작동원리.md</guid><pubDate>Tue, 01 Jul 2025 08:03:10 GMT</pubDate></item><item><title><![CDATA[사용법]]></title><description><![CDATA[ 
 <br><a data-href="비동기 프로그래밍" href="컴퓨터 공학\프로그래밍\방법론\비동기 프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">비동기 프로그래밍</a> 방식이며<br>
<a data-href="Javascript 비동기 작동원리" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript 비동기 작동원리.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript 비동기 작동원리</a>에 따라 동작한다.<br>
명확하게 하고 싶다.<br>
이거는 병렬 처리 방법이 아니기에<br>
Promise에 연산 작업을 준다고 해서 실행시간이 줄어드는 게 아니다.<br>
그저 <a data-href="IO 작업" href="컴퓨터 공학\운영체제\IO 작업.html" class="internal-link" target="_self" rel="noopener nofollow">IO 작업</a>을 기다리는 시간에 다른 연산을 할 수 있는 것 뿐이다.<br><br>비동기 처리를 수행할 익명 함수를 인수로 전달 받는다.<br>
해당 익명 함수는 성공할 경우의 콜백 함수와 실패할 경우의 콜백 함수를 입력 받는 익명 함수다.<br>Promise를 생성하면 해당 익명 함수를 실행한다.<br>const promise = new Promise((res, rej) =&gt; { 
	console.log('promise');
});
<br>이렇게 사용한다.<br><br><br>초기 상태를 말한다.<br><br>성공적으로 완료된 상태를 말한다.<br><br>실패 상태를 말한다.<br><br>const promise = new Promise((resolve, reject) =&gt; {
	console.log("hello");
});

// 1.

promise.then(
	function (result) {},
	function (error) {}
);

// 2.

promise.then(
	function (result) {}
).catch(
	function (error) {}
).finally(
	() =&gt; {}
);
<br>이렇게 두 가지로 사용할 수 있다.<br>then의 경우 성공했을 때 실행하고<br>
catch의 경우 실패했을 때<br>
finally의 경우 무조건 실행하게 된다.<br><br><br>Promise.all(Promise 배열)로 사용하고 모든 작업이 끝나면 실행한다.<br>순서대로 실행되지만 앞의 함수를 기다리지 않는다.<br>
처리 순서가 보장된다.<br>
에러가 나면 그 즉시 에러를 반환한다.<br><br>Promise.race(Promise 배열)로 사용하고 가장 짧은 작업이 끝나면 실행한다.<br>동시에 트리거가 된다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript Promise.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript Promise.md</guid><pubDate>Wed, 02 Jul 2025 07:50:32 GMT</pubDate></item><item><title><![CDATA[filter]]></title><description><![CDATA[ 
 <br><br>const arr = [1,2,3];
arr.filter((e)=&gt;e&gt;=2);
<br>이런식으로 필터링 가능<br><br>const arr = [1,2,3];
arr.map((e)=&gt;e+1);
<br>매핑 가능]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript stream.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/Javascript stream.md</guid><pubDate>Mon, 02 Jun 2025 00:30:16 GMT</pubDate></item><item><title><![CDATA[type]]></title><description><![CDATA[ 
 <br><a data-href="Javascript" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript</a>에 타입을 넣은 언어로 타임의 차이로 인한 오류를 방지하고자 만들어낸 것이다.<br>
유지 보수성을 높여준다.<br>
하지만 Javascript로 변환과정을 거친다.<br><br>type을 지정할 수 있다.<br>export type PostDto = {
	id: number;
	title: string;
};
<br>이 방식으로 작성이 가능하고<br>import type {PostDto} from "@/type/post"
<br>이 방식으로 불러올 수 있다.<br><br><br>export type PostWithContentDto = {
	id: number;
	title: string;
	content: string;
}

export type PostDto = Omit&lt;PostWithContentDto, "title"|"content"&gt;;
<br><br>export type PostDto = {
	id: number;
	title: string;
}

export type PostDtoWithContent =  "content" &amp; PostDto
<br><br>type과 같이 사용가능한데 상속도 가능하다.<br>
그래서 중복된 코드를 줄일 수 있다.<br>]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\TypeScript.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Javascript/TypeScript.md</guid><pubDate>Thu, 03 Jul 2025 00:00:51 GMT</pubDate></item><item><title><![CDATA[openCV]]></title><description><![CDATA[ 
 <br>이미지 처리를 할 때 사용하는 라이브러리입니다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python 라이브러리\openCV\openCV.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python 라이브러리/openCV/openCV.md</guid><pubDate>Thu, 03 Jul 2025 02:46:46 GMT</pubDate></item><item><title><![CDATA[PyQt]]></title><description><![CDATA[ 
 <br>Python에서 Qt를 사용할 때 사용하는 라이브러리입니다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python 라이브러리\PyQt\PyQt.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python 라이브러리/PyQt/PyQt.md</guid><pubDate>Thu, 03 Jul 2025 02:47:04 GMT</pubDate></item><item><title><![CDATA[Tensorflow]]></title><description><![CDATA[ 
 <br>인공지능을 개발할 때 사용하는 라이브러리입니다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python 라이브러리\TensorFlow\Tensorflow.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python 라이브러리/TensorFlow/Tensorflow.md</guid><pubDate>Thu, 03 Jul 2025 02:47:36 GMT</pubDate></item><item><title><![CDATA[GIL]]></title><description><![CDATA[ 
 <br>개발자가 심심해서 만들어본 언어로<br>
<a data-href="인터프리터 언어" href="컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\인터프리터 언어.html" class="internal-link" target="_self" rel="noopener nofollow">인터프리터 언어</a>이다.<br>
쉘 스크립트로 쓰기 좋고<br>
여기저기 사용하기 좋아서 사용하는 사람이 많다.<br><br>Global Interpreter Lock으로<br>
Interpreter가 하나라서 멀티 스레딩 코드를 작성해도 항상 한개의 스레드에서만 돌아간다.<br><br><a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>/<a data-href="C++" href="컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++.html" class="internal-link" target="_self" rel="noopener nofollow">C++</a>로 만든 언어라서 C언어와의 호환성을 가지고 있다.<br>
C언어로 빌드한 파일을 가져와 함수를 실행할 수 있다.<br>
이걸 활용하여 여러가지 C로 작성된 라이브러리를 사용한다.<br>
그러니까 파이썬을 쓸 거면 C를 공부하는 게 좋을 것이다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python.md</guid><pubDate>Thu, 26 Jun 2025 07:28:48 GMT</pubDate></item><item><title><![CDATA[Python 매개변수]]></title><description><![CDATA[ 
 <br>파이썬에서는 함수를 정의할 때 매개변수를 여러 개를 작성할 수 있는데 기본 값을 정할 때는 기본 값이 없는 매개변수 이후에 작성해야 한다.<br>그리고 호출 할 때는 위치에 따라 작성하는 값 다음에 키워드를 통해 작성하는 값을 작성해야하고<br>파이썬에서는 매개변수를 여러 개를 받을 수 있다.<br>import sys
def function(*args, **kwargs):
	print(*args, **kwargs)

function("test", file=sys.stderr)
<br>이러면 에러로 test가 표시될 것이다.<br>
*args는 위치에 따라 입력 받는 매개변수고<br>
**kwargs는 키워드를 통해 입력 받는 매개변수다.<br>
그대로 함수에 넣으면 입력 받을 때와 똑같이 입력을 시킬 수 있다.<br>
그러니까 저기 함수에서는<br>
print("test", file=sys.stderr)로 호출이 되었다는 것이다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python 매개변수.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python 매개변수.md</guid><pubDate>Fri, 04 Jul 2025 08:48:29 GMT</pubDate></item><item><title><![CDATA[Python 문법]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python 문법.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python 문법.md</guid><pubDate>Thu, 26 Jun 2025 07:28:53 GMT</pubDate></item><item><title><![CDATA[Python 타입 어노테이션]]></title><description><![CDATA[ 
 <br>파이썬은 타입을 명시할 수 있다.<br>
그렇다고 타입 체크를 하지는 않는다.<br>a:int = 10
<br>이런 방식으로 작성이 가능하고 IDE에서는 이를 확인해서 경고까지는 띄우지만 실행할 때 에러를 발생시키지는 않는다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python 타입 어노테이션.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python 타입 어노테이션.md</guid><pubDate>Thu, 26 Jun 2025 07:30:47 GMT</pubDate></item><item><title><![CDATA[Python Decorator]]></title><description><![CDATA[ 
 <br>함수를 함수로 감싸서 실행하기 위한 방법이다.<br>
간단하게 예시를 보여주자면<br>import time
def timer(func):
	count = 0
	def inner(*args, **kwargs):
		nonlocal count
		start = time.time()
		result = func(*args, **kwargs)
		elapsed_time = time.time() - start
		print(f"[{count}] elapsed time : {elapsed_time:.02f}")
		count+=1
		return result
	return inner

@timer
def test():
	print("test")

test()
<br>이런식으로 함수가 실행하기 전, 함수가 실행 한 후에 기능을 더할 수도 있고<br>
데코레이터 함수에 변수를 둬서 함수를 몇 번 실행시키냐에 따라 출력값이 다르게 할 수도 있다.<br>import time

def timer(*arg):
	def decorator(func):
		count = 0
		def inner(*args, **kwargs):
			nonlocal count
			start = time.time()
			result = func(*args, **kwargs)
			elapsed_time = time.time() - start
			print(f"[{count}] elapsed time : {elapsed_time:.02f}")
			count+=1
			return result
		return inner
	return decorator

@timer("test")
def test():
	print("test")

test()
<br>이런식으로 매개변수를 넣을 수도 있다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python Decorator.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python Decorator.md</guid><pubDate>Fri, 04 Jul 2025 08:37:00 GMT</pubDate></item><item><title><![CDATA[Python Generator]]></title><description><![CDATA[ 
 <br>def simple_generator():
	yeild 1
	yeild 2
	yeild 3
gen = simple_generator()
print(next(gen))
print(next(gen))
print(next(gen))
<br>함수를 진행하다가 멈춰서 값을 반환한다.<br>
for each로 반복문을 실행할 수 있다.<br>
메모리 사용 절약이 목적이다.<br>출처 <a data-tooltip-position="top" aria-label="https://hyeonql.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%AC-Yield-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%98%88%EC%A0%9C%EC%99%80-%ED%95%A8%EA%BB%98-%EC%83%81%EC%84%B8-%EA%B0%80%EC%9D%B4%EB%93%9C" rel="noopener nofollow" class="external-link" href="https://hyeonql.tistory.com/entry/%ED%8C%8C%EC%9D%B4%EC%8D%AC-Yield-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%98%88%EC%A0%9C%EC%99%80-%ED%95%A8%EA%BB%98-%EC%83%81%EC%84%B8-%EA%B0%80%EC%9D%B4%EB%93%9C" target="_blank">링크</a>]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python Generator.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python Generator.md</guid><pubDate>Fri, 04 Jul 2025 08:40:59 GMT</pubDate></item><item><title><![CDATA[int]]></title><description><![CDATA[ 
 <br>litteral 빼고 전부 다 객체로 되어 있다고 보면 된다.<br><br>정수를 저장하는 자료형이다.<br>
크기가 제한되지 않는다.<br><br>문자열을 저장하는 자료형이다.<br><br>소수를 저장하는 자료형이다.<br><br>여러 값을 저장하는 <a data-href="List" href="컴퓨터 공학\프로그래밍\자료 구조\List.html" class="internal-link" target="_self" rel="noopener nofollow">List</a>다.<br><br><a data-href="Hash Table" href="컴퓨터 공학\프로그래밍\자료 구조\Hash Table.html" class="internal-link" target="_self" rel="noopener nofollow">Hash Table</a>구조의 딕셔너리다.<br><br>동일한 요소를 허용시키지 않는 Hash set이다.]]></description><link>컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python types.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/인터프리터 언어/Python/Python types.md</guid><pubDate>Fri, 04 Jul 2025 08:37:51 GMT</pubDate></item><item><title><![CDATA[cmake]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\빌드\cmake.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/빌드/cmake.md</guid><pubDate>Tue, 01 Jul 2025 02:39:16 GMT</pubDate></item><item><title><![CDATA[ninja]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\빌드\ninja.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/빌드/ninja.md</guid><pubDate>Tue, 01 Jul 2025 02:39:21 GMT</pubDate></item><item><title><![CDATA[C]]></title><description><![CDATA[ 
 <br><a data-href="어셈블리어" href="컴퓨터 공학\프로그래밍\언어\어셈블리\어셈블리어.html" class="internal-link" target="_self" rel="noopener nofollow">어셈블리어</a>를 쓰기 힘들어서 만들어낸 언어다.<br>
UNIX 운영체제를 구현하기 위해서 개발했다.<br>문법으로는 Pointer, 함수, struct, #define 같은 전처리 기능, include를 통해 헤더 파일을 가져오는 것도 가능하고 이정도 인 것 같다.<br>
Pointer가 어려운 언어라 사람들이 기피하는 언어다.<br>
하지만 C가 은근히 많이 쓰인다.<br>동적 메모리를 직접 관리해야한다.<br><br>논리를 따로 지원하지는 않는다.<br>
그래서 #include &lt;stdbool.h&gt;로 0과 1 이상을 false, true로 사용해야한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C/C.md</guid><pubDate>Fri, 04 Jul 2025 11:41:44 GMT</pubDate></item><item><title><![CDATA[C 예외처리]]></title><description><![CDATA[ 
 <br><a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>에서는 에러가 발생한 경우 종료시키지 않는다.<br>
함수에서 반환 값으로 에러코드를 확인해야한다.<br>
그리고 에러 메시지를 파악하려면 errno 라이브러리를 사용해야한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C\C 예외처리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C/C 예외처리.md</guid><pubDate>Mon, 30 Jun 2025 08:29:15 GMT</pubDate></item><item><title><![CDATA[크기]]></title><description><![CDATA[ 
 <br>여러 개의 타입의 변수를 담을 수 있는 구조체다.<br><br>실제의 크기는 struct 안의 자료형 중 가장 큰 자료형의 크기의 배수로 정해집니다.<br>
그러니까 예를들어<br>struct Student{
	int a;
	char b[6];
	int c;
}
<br>에서 4, 1*6, 4 크기로 14 바이트가 나와야 할 거 같지만 16바이트가 나온다는 겁니다.<br>빈공간은 비워둡니다.<br>
이유는 제가 추정하기엔 내부 단편화를 막기 위함이 아닐까 생각합니다.]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C\C Struct.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C/C Struct.md</guid><pubDate>Tue, 24 Jun 2025 07:25:24 GMT</pubDate></item><item><title><![CDATA[C-Sharp]]></title><description><![CDATA[ 
 <br>이름에 #이 들어가지 않아서 이렇게 작성했다.<br>
<a data-href="C++" href="컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++.html" class="internal-link" target="_self" rel="noopener nofollow">C++</a>에 Garbage Collector를 넣어 메모리 상으로 안전하게 만들었다.<br>
<a data-href="객체지향 프로그래밍" href="컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\객체지향 프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">객체지향 프로그래밍</a>을 잘 구현했다.]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C#\C-Sharp.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C#/C-Sharp.md</guid><pubDate>Fri, 20 Jun 2025 08:41:15 GMT</pubDate></item><item><title><![CDATA[C++]]></title><description><![CDATA[ 
 <br><a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>언어에 <a data-href="객체지향 프로그래밍" href="컴퓨터 공학\프로그래밍\방법론\객체지향 프로그래밍\객체지향 프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">객체지향 프로그래밍</a>을 추가한 언어다.<br>
Struct와 Class에 멤버함수를 넣을 수 있고 Struct와 class의 차이는 멤버 변수가 기본적으로 public 이냐 private이냐 차이다.<br>생성자와 소멸자가 존재한다.<br>동적 메모리를 직접 관리해야한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C++/C++.md</guid><pubDate>Thu, 19 Jun 2025 08:15:23 GMT</pubDate></item><item><title><![CDATA[C++ 펑터]]></title><description><![CDATA[ 
 <br>함수처럼 쓸 수 있는 클래스다.<br>C++에서 클래스를 정의할 때<br>#include &lt;iostream&gt;
class Money{
private:
	int _Money = 0;
public:
	Money(int money):_Money(money){}

	int operator()(){
		return this-&gt;_Money;
	}
}
<br>이런 식으로 가능하고<br>int main(){
	
}
]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++ 펑터.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C++/C++ 펑터.md</guid><pubDate>Thu, 03 Jul 2025 07:26:46 GMT</pubDate></item><item><title><![CDATA[C++ template]]></title><description><![CDATA[ 
 <br>컴파일 타임에 연산을 할 수 있다.<br>
재귀적으로 사용해서 연산을 한다.<br>
엄청 자유로워서 피보나치 연산도 가능하다.<br>제네릭을 구현할 때도 쓰고<br>
가변 매개변수를 받을 때도 사용한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++ template.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/C++/C++ template.md</guid><pubDate>Mon, 23 Jun 2025 07:59:03 GMT</pubDate></item><item><title><![CDATA[포인터]]></title><description><![CDATA[ 
 <br>변수를 가리키는 주소를 저장한다.<br>배열처럼 여러 개의 변수가 같이 있는 경우<br>
포인터 변수에 값을 더해 다음 위치에 있는 변수에 접근할 수 있다.<br>
예를들어<br>#include &lt;stdio.h&gt;
int main(){
	int[] arr = {1,2,3};
	int *a = arr;
	printf("%d\n", *(a+1));
}
<br>의 경우 2가 출력이 된다.<br>
그러니까 포인터 변수에 값을 더하면 주소 + 값 * (자료형의 크기)를 하여서 더하고 그 위치에 있는 값을 가져온다.<br>그러면 만약에 void*가 있다면 어떻게 될까?<br>
연산이 불가능하다.<br><br> 예를 들어<br>#include &lt;stdio.h&gt;
struct A{
	int a;
}

int main(){
	struct A a = {1};
	struct A* b = &amp;a;
	printf("%d\n", *(b).a);
}
<br>구조체 포인터가 있으면 이런식으로 접근해야한다.<br>
하지만 이게 불편할 수 있는데]]></description><link>컴퓨터 공학\프로그래밍\언어\C 계열\포인터.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/C 계열/포인터.md</guid><pubDate>Wed, 02 Jul 2025 06:32:58 GMT</pubDate></item><item><title><![CDATA[전체적인 흐름]]></title><description><![CDATA[ 
 <br>내가 보기엔 함수형 프로그래밍 방식을 채택한 것으로 보임<br>
파이썬의 range와 listcomprehension과 비슷한 것으로 보인다.<br><br>stream을 통해 열고<br>
filter를 통해 거르고<br>
map을 통해 매핑 시켜서<br>
collect를 통해 완성품을 만들어냄<br><br>IntStream.rangeClosed(1, 10).forEach(
	new IntConsumer(){
		@Override
		public void accept(int value){
		System.out.println(value);
		}
	}
);

<br>이걸 극단적으로 줄이면<br>IntStream.rangeClosed(1, 10)
                .forEach(System.out::println);
<br>가 된다.<br><br>조건문을 통해 걸러내는 것이다.<br>IntStream.rangeClosed(1, 10)
	.filter(e -&gt; e % 2 != 0)
	.forEach(e -&gt; {
		System.out.println(e);
});
<br>이렇게<br><br>객체로 만듬<br><br>int 배열로 만듬<br>
이걸 해두면 sum, average 가능<br><br>각각 key와 value에 값을 넣어 Map을 만들어낸다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 라이브러리\Java 스트림.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 라이브러리/Java 스트림.md</guid><pubDate>Wed, 28 May 2025 08:04:55 GMT</pubDate></item><item><title><![CDATA[Array]]></title><description><![CDATA[ 
 <br><br>배열을 저장<br><br>Key, Value의 방식으로 저장하는 구조<br>
메모리를 많이 먹는 구조로<br>
접근하는데 거의 O(1)의 속도로 접근하지만<br>
정렬이 되어있지도 않어서 특정 상황에만 사용할 것<br><br>입력해야할 요소의 개수를 모를 경우 사용하기 좋다.<br><br>간단하게는 중복 요소 제거하기엔 좋음]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 라이브러리\Java Collection.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 라이브러리/Java Collection.md</guid><pubDate>Thu, 29 May 2025 08:31:09 GMT</pubDate></item><item><title><![CDATA[@AllArgsConstructor]]></title><description><![CDATA[ 
 <br>어노테이션을 사용해서 생성자, getter, setter 등 귀찮은 코드를 줄여주는 라이브러리다.<br><br>모든 속성이 포함된 생성자를 만들어준다.<br><br>매개변수가 없는 생성자를 만들어준다.<br><br>필수로 들어가야 하는 속성을 포함한 생성자를 만들어 준다.<br><br>Getter를 만들어 준다.<br>
클래스에 두면 모든 속성에 Getter를 만들어준다.<br>
각각 속성에 따로 해두면 따로 가능하다.<br><br>Setter를 만들어 준다.<br>
클래스에 두면 모든 속성에 Setter를 만들어준다.<br>
각각 속성에 따로 해두면 따로 가능하다.<br><br>ToString를 만들어 준다.<br>
클래스에 두면 모든 속성에 ToString를 만들어준다.<br>
각각 속성에 따로 해두면 따로 가능하다.<br><br>try catch를 하지 않아도 컴파일 에러를 발생시키지 않게 한다.<br>
예외를 발생시키지 않는다고 믿을 수 있을 때 사용하는 것이 좋아보인다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 라이브러리\Java Lombok.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 라이브러리/Java Lombok.md</guid><pubDate>Mon, 30 Jun 2025 08:51:43 GMT</pubDate></item><item><title><![CDATA[Java Reflections]]></title><description><![CDATA[ 
 <br>클래스의 어노테이션이나 필드나 메서드를 조회할 수 있다.<br>입력으로는 패키지 주소를 받는다.<br><a data-href="스프링 부트" href="컴퓨터 공학\프레임워크\웹 프레임워크\스프링 부트\스프링 부트.html" class="internal-link" target="_self" rel="noopener nofollow">스프링 부트</a>에서 자주 사용한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 라이브러리\Java Reflections.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 라이브러리/Java Reflections.md</guid><pubDate>Thu, 26 Jun 2025 08:40:50 GMT</pubDate></item><item><title><![CDATA[출력]]></title><description><![CDATA[ 
 <br><br>System.out.println(String text);<br>
를 통해 출력함<br><br><br>
<br>boolean
<br>char
<br>byte
<br>short
<br>int
<br>long
<br>float
<br>double<br>
이 있음<br>
String은 참조형 변수<br>
모든 참조형은 8바이트<br>
이유는 64비트 컴퓨터에선 주소가 64비트니까
<br><br>]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 기본 문법.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 기본 문법.md</guid><pubDate>Tue, 24 Jun 2025 07:15:07 GMT</pubDate></item><item><title><![CDATA[Java 래퍼와 비래퍼]]></title><description><![CDATA[ 
 <br>여기서 예시를 int와 Integer로 표현하자면<br>int는 기본 자료형이고<br>
Integer은 래퍼 클래스임<br>그러니까 int는 스택에 저장되고 Integer은 힙에 저장됨<br>그렇기에 int는 null의 값을 가지는게 불가능하고<br>
Integer은 null의 값을 가지는게 가능함<br>
그런데 그러면 new를 통해 Interger를 만들어야 하는거 아닌가 생각할 수 있는데<br>
자동으로 해준다고 하네 그래서 new를 쓸 필요 없고 new를 쓰면 메모리 낭비라고 하네<br>C++ 방식으로 생각하면<br>
int는 그냥 int값이고<br>
Integer은 int*임]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 래퍼와 비래퍼.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 래퍼와 비래퍼.md</guid><pubDate>Thu, 26 Jun 2025 01:43:50 GMT</pubDate></item><item><title><![CDATA[Java 상속]]></title><description><![CDATA[ 
 <br>상속의 이유는 중복을 없애기 위해<br>클래스 여러 개 둘러보다 같은 내용이 반복되면 상속을 통해 줄여주는 거임<br>부모 클래스 포인터에 자식 클래스를 넣을 수 있다.<br>
이건 업 캐스팅이라고 불리고 업캐스팅이 되면 자식 클래스만 가지고 있는 것을 사용할 수 없음<br>
하려면 다운 캐스팅을 해야하는데 잘 확인해서 다운 캐스팅을 해야 오류가 발생하지 않음<br>중복을 상속만으로는 모두 없앨 수 없다.<br><br>동일한 구조의 메소드를 묶어서 추상 메소드를 만들 수 있다.<br>
추상 메소드를 만드려면 메소드 앞에 abstract를 추가해줘야 한다.<br>
부모 클래스에 추상 메소드가 있으면 구현을 해야한다.<br>
추상 메소드가 하나라도 있으면 추상 클래스가 된다.<br>
추상 클래스로 만드려면 class 앞에 abstract를 붙여야 한다.<br>추상 클래스를 상속한 자식 클래스들을 모아서 추상 메소드를 실행시키면 구현되어있으니 실행이 된다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 상속.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 상속.md</guid><pubDate>Wed, 04 Jun 2025 02:01:01 GMT</pubDate></item><item><title><![CDATA[Java 연산자]]></title><description><![CDATA[ 
 <br>
<br>

<br>


<br>

<br>


<br>*
<br>/
<br>&amp;&amp;
<br>||
<br>&lt;&lt;
<br>





<br>



<br>

=


<br>&lt;
<br>&lt;=
<br>++
<br>--
<br>+=<br>
등이 있음
]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 연산자.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 연산자.md</guid><pubDate>Wed, 28 May 2025 07:02:40 GMT</pubDate></item><item><title><![CDATA[Error]]></title><description><![CDATA[ 
 <br>메서드에서 어느 예외를 던지는 지도 명시할 수 있고<br>
명시를 하면 해당 메소드는 예외를 던질거니까 예외처리를 해야한다.<br>
컴파일 타임에 예외처리를 안했는지 확인이 가능해 좀 더 안전하게 코딩을 할 수 있다.<br><br>복구가 어려운 상황에 발생한다.<br>
보통 <a data-tooltip-position="top" aria-label="JVM, JRE, JDK > JVM" data-href="JVM, JRE, JDK#JVM" href="컴퓨터 공학\프로그래밍\언어\Java 계열\Java\JVM\JVM, JRE, JDK.html#JVM" class="internal-link" target="_self" rel="noopener nofollow">JVM</a>에서 실행시키기 때문에 대응하기 어렵다.<br>Throwable을 상속한다.<br><br>논리적 허점에서 발생한다.<br>
개발자가 처리가 가능하다.<br>Throwable을 상속한다.<br><br>처리를 하지 않고 실행을 하면 결과물이 이상한 값을 가질 수 있다.<br><br><br>컴파일 시점에 발생한다.<br>
예외 처리는 필수로 해야한다.<br>
실수로 예외를 무시하는 것을 방지할 수 있다.<br>
불필요한 예외 처리 코드가 증가할 수 있다.<br><br>런타임 시점에 발생한다.<br>
예외 처리를 하지 않아도 된다.<br>
예외 처리 코드가 간결하다.<br>
실수로 예외를 놓칠 수 있다.<br><br>앞에 throw를 적으면 된다.<br><br><br>함수 뒤에 throws를 사용하여 이 함수를 호출한 함수에서 처리하게 하는 방법도 있고<br><br>try-catch를 통해 처리할 수도 있다.<br><br>finally는 무조건 실행한다.<br>
자원 반환하는 용도로 자주 사용한다.<br><br>try (Scanner scanner = new Scanner(System.in)){
}catch(Exception e){
}
<br>처럼 자원 반환하는 경우 자동으로 해주는 경우도 있다.<br><br>Exception을 상속하는 Exception 클래스는 Checked Exception이고<br>
RuntimeException을 상속하는 Exception 클래스는 Unchecked Exception이다.<br><br>커스텀 예외를 통해 어떤 상황에 대한 예외인지 파악이 가능하다.<br>
예외 클래스를 과도하게 정의될 수 있고 예외 처리 코드가 많아질 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 예외처리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 예외처리.md</guid><pubDate>Tue, 01 Jul 2025 08:44:28 GMT</pubDate></item><item><title><![CDATA[Java 제너릭]]></title><description><![CDATA[ 
 <br>클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다.<br>
객체별로 다른 타입의 자료가 저장될 수 있게 한다.<br>메소드에서도 사용이 가능하다.<br>원리는 간단하다. 해당 타입을 사용하는 클래스를 더 만드는 것이다.<br>
하지만 이건 런타임에 만들어지는 것이 아닌 컴파일 타임에 만들어지기에 성능에 영향을 주지는 않는다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 제너릭.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 제너릭.md</guid><pubDate>Thu, 26 Jun 2025 01:45:10 GMT</pubDate></item><item><title><![CDATA[Java 클래스]]></title><description><![CDATA[ 
 <br>속성과 메소드로 이루어져있다.<br>
앞에 private, protected, public을 넣어 제어 접근을 제어할 수 있다.<br>속성에 final을 붙이면 생성자에서 초기화를 시켜줘야 하고<br>
한번 초기화를 하면 값이 더 이상 변하지 않는다.<br>
그렇기에 생성자에서도 초기화를 하지 않으면 에러를 발생시킨다.<br>속성에 static을 붙이면 <br><br>이러한 클래스를 하나의 공통점만을 묶어 코드 수를 줄이기 위한 방법]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java 클래스.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 클래스.md</guid><pubDate>Tue, 24 Jun 2025 07:14:56 GMT</pubDate></item><item><title><![CDATA[Java Record]]></title><description><![CDATA[ 
 <br>Java 14에서 나왔다.<br>데이터 전달용 클래스(DTO)로 사용한다.<br>
<a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>의 struct]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java 문법\Java Record.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java Record.md</guid><pubDate>Tue, 01 Jul 2025 08:45:48 GMT</pubDate></item><item><title><![CDATA[<a data-tooltip-position="top" aria-label="JVM, JRE, JDK > JVM" data-href="JVM, JRE, JDK#JVM" href="컴퓨터 공학/프로그래밍/언어/Java 계열/Java/JVM/JVM, JRE, JDK.html#JVM" class="internal-link" target="_self" rel="noopener nofollow">JVM</a>]]></title><description><![CDATA[ 
 <br><br>컴파일 플랫폼과 타겟 플랫폼이 다르면 프로그램이 동작하지 않음<br>
자바 바이트코드는 타겟 플랫폼에 상관 없이 JVM 위에서 동작한다.<br>
JVM은 타겟 플랫폼에 의존한다.<br><br>네트워크에 연결된 모든 디바이스에서 작동하는 것이 목적이었다.<br><br>Lexical Analyzer, Syntax Analyzer, Sementic Analyzer, Intermediate Code Generator, Code Optimizer, Code Generator<br><br><br>Method area와 Heap은 모든 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>가 공유한다.<br><br>클래스 정보, 정적 데이터가 저장된다.<br>
<a data-href="메모리 구조" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html" class="internal-link" target="_self" rel="noopener nofollow">메모리 구조</a>의 <a data-tooltip-position="top" aria-label="메모리 구조 > 데이터 영역" data-href="메모리 구조#데이터 영역" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html#데이터_영역" class="internal-link" target="_self" rel="noopener nofollow">데이터 영역</a>에 해당한다.<br><br>런타임 때 생성한 모든 객체를 저장한다.<br>
<a data-href="메모리 구조" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html" class="internal-link" target="_self" rel="noopener nofollow">메모리 구조</a>의 <a data-tooltip-position="top" aria-label="메모리 구조 > 힙 영역" data-href="메모리 구조#힙 영역" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html#힙_영역" class="internal-link" target="_self" rel="noopener nofollow">힙 영역</a>에 해당한다.<br><br><a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a> 마다 존재하는 공간<br><br>각 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>는 메서드를 실행하고 PC는 몇 번째 줄을 실행하는지 나타낸다.<br><br><a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a> 별 1개씩 존재한다.<br>
스택 프레임은 메서드가 호출될 때마다 생성되고<br>
메서드 실행이 끝나면 스택 프레임은 pop되어 스택에서 제거된다.<br>
<a data-href="메모리 구조" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html" class="internal-link" target="_self" rel="noopener nofollow">메모리 구조</a>의 <a data-tooltip-position="top" aria-label="메모리 구조 > 스택 영역" data-href="메모리 구조#스택 영역" href="컴퓨터 공학\컴퓨터 구조\메모리\메모리 구조.html#스택_영역" class="internal-link" target="_self" rel="noopener nofollow">스택 영역</a>에 해당한다.<br><br><br>지역 변수가 저장된다.<br><br>연산할 때 필요한 값을 임시적으로 저장하는 공간<br><br>Constant Pool, 이전 스택 프레임에 대한 정보, 현재 메서드가 속한 클래스/객체에 대한 참조 등의 정보를 갖는다.<br><br>Java Bytecode가 아닌 다른 언어로 작성된 메서드인 Native Method를 사용할 때 사용된다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\JVM\JVM Stack &amp; Heap.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/JVM/JVM Stack &amp; Heap.md</guid><pubDate>Tue, 24 Jun 2025 07:45:31 GMT</pubDate></item><item><title><![CDATA[JVM]]></title><description><![CDATA[ 
 <br><br>자바 바이트 코드를 읽어서 실행하는 녀석<br>
아키텍쳐와 운영체제에 맞게 각각 만들어져 있고<br>
자바 바이트 코드가 들어가면 아키텍쳐와 운영체제에 상관없이 똑같이 실행되게 만든 것이다.<br><br>Just In Time으로<br>
바이트 코드를 기계어로 컴파일한다.<br><br>Java Runtime Environment의 약자<br>
자바 바이트 코드를 실행시켜주기 위한 녀석<br>
요즘은 프로그램 배포할 때 파일에 포함시켜서 배포하기 때문에 다운받을 필요가 없다.<br><br>Java Development Kit<br>
여러가지 버전이 있지만 상업적인 목적으로 사용하면 유로다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\JVM\JVM, JRE, JDK.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/JVM/JVM, JRE, JDK.md</guid><pubDate>Fri, 06 Jun 2025 17:41:12 GMT</pubDate></item><item><title><![CDATA[<a data-href="Java 기본 문법" href="컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java 문법/Java 기본 문법.html" class="internal-link" target="_self" rel="noopener nofollow">Java 기본 문법</a>]]></title><description><![CDATA[ 
 <br>어느 컴퓨터에서든 돌아가게 만든 언어로<br>
아키텍쳐나 운영체제에 맞게 JVM을 만들어 놔서<br>
코드를 바이트 코드로 컴파일 한 것을 어느 곳에서든지 실행할 수 있다.<br>
요즘은 앱을 출시할 때 JVM도 같이 전송해서 따로 JVM을 설치하지 않아도 되게 한다고 한다.<br><br>]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Java/Java.md</guid><pubDate>Fri, 20 Jun 2025 08:43:02 GMT</pubDate></item><item><title><![CDATA[Kotlin]]></title><description><![CDATA[ 
 <br>Null 체크를 한다.<br><a data-href="Java" href="컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java.html" class="internal-link" target="_self" rel="noopener nofollow">Java</a>와 같은 <a data-tooltip-position="top" aria-label="JVM, JRE, JDK > JVM" data-href="JVM, JRE, JDK#JVM" href="컴퓨터 공학\프로그래밍\언어\Java 계열\Java\JVM\JVM, JRE, JDK.html#JVM" class="internal-link" target="_self" rel="noopener nofollow">JVM</a>에서 돌아가는 언어로 Java 코드와 호환한다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Java 계열\Kotlin\Kotlin.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Java 계열/Kotlin/Kotlin.md</guid><pubDate>Tue, 24 Jun 2025 07:41:23 GMT</pubDate></item><item><title><![CDATA[#]]></title><description><![CDATA[ 
 <br>현재 사용하는 문서를 기술하는 언어<br><br>개수가 늘어나면 크키가 작아짐]]></description><link>컴퓨터 공학\프로그래밍\언어\Mark 언어\Markdown Language\Markdown Language.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Mark 언어/Markdown Language/Markdown Language.md</guid><pubDate>Fri, 13 Jun 2025 03:33:04 GMT</pubDate></item><item><title><![CDATA[Markup Language]]></title><description><![CDATA[ 
 <br>태그 기호 &lt;&gt;등을 이용하여 문서나 데이터를 기술하는 언어<br><a data-href="HTML" href="컴퓨터 공학\인터넷\web\데이터양식\HTML\HTML.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>이 포함된다.]]></description><link>컴퓨터 공학\프로그래밍\언어\Mark 언어\Markup Language\Markup Language.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Mark 언어/Markup Language/Markup Language.md</guid><pubDate>Thu, 19 Jun 2025 08:12:40 GMT</pubDate></item><item><title><![CDATA[변수]]></title><description><![CDATA[ 
 <br>대부분의 에러의 원인이 메모리에서 나온다는 것을 해결하기 위해<br>
메모리를 자동으로 정리하지만 메모리를 해제할 때 해제할 메모리를 찾는 오버헤드를 피하기 위해<br>
만들어낸 언어다.<br>
그러니까 메모리는 어디에서 해제될지 컴파일 타임에 알게 된다.<br><br>변수를 생성하면 기본적으로는 수정 불가다.<br>
mut을 붙여야만 수정이 가능하다.<br>같은 스코프에서 같은 이름의 변수를 생성 가능하다.<br><br>rust는 Null을 만들지 않았다.<br>
왜냐하면 토니 호어라는 과학자가 말했다시피<br>
Null을 만든 걸 수십억 달러짜리 실수라고 말하며 후회했다고 할정도니까<br>
그래서 Optio&lt;T&gt;를 만들어 null을 대신했다.<br><br>]]></description><link>컴퓨터 공학\프로그래밍\언어\Rust\Rust.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Rust/Rust.md</guid><pubDate>Tue, 01 Jul 2025 02:46:07 GMT</pubDate></item><item><title><![CDATA[Garbage Collector]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\언어\Garbage Collector.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/언어/Garbage Collector.md</guid><pubDate>Fri, 04 Jul 2025 11:42:23 GMT</pubDate></item><item><title><![CDATA[B-Tree]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Tree\B-Tree.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Tree/B-Tree.md</guid><pubDate>Fri, 20 Jun 2025 05:03:13 GMT</pubDate></item><item><title><![CDATA[B+Tree]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Tree\B+Tree.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Tree/B+Tree.md</guid><pubDate>Fri, 20 Jun 2025 05:04:36 GMT</pubDate></item><item><title><![CDATA[Binary Tree]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Tree\Binary Tree.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Tree/Binary Tree.md</guid><pubDate>Fri, 20 Jun 2025 05:05:23 GMT</pubDate></item><item><title><![CDATA[Array]]></title><description><![CDATA[ 
 <br>여러 개의 값을 저장할 수 있는 자료 구조로 몇 개를 저장할 지를 미리 정해두고 생성한다.<br>
한번 생성되면 개수를 변경할 수 없다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Array.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Array.md</guid><pubDate>Sat, 21 Jun 2025 14:31:59 GMT</pubDate></item><item><title><![CDATA[Graph]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Graph.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Graph.md</guid><pubDate>Fri, 20 Jun 2025 01:29:44 GMT</pubDate></item><item><title><![CDATA[Hash Table]]></title><description><![CDATA[ 
 <br>해시 함수를 통해 정수가 아닌 값으로도 O(1)의 시간 복잡도로 데이터를 가져올 수 있는 자료구조다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Hash Table.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Hash Table.md</guid><pubDate>Mon, 30 Jun 2025 08:43:35 GMT</pubDate></item><item><title><![CDATA[Linked List]]></title><description><![CDATA[ 
 <br>노드를 만들고 노드들 끼리 연결시켜 놓은 구조다.<br>random access가 불가능하다 항상 head 부터 tail까지 순회를 해서 찾아야 한다.<br>중간에 값을 삽입 시키거나 삭제시키는 것이 유연하다.<br><a data-href="List" href="컴퓨터 공학\프로그래밍\자료 구조\List.html" class="internal-link" target="_self" rel="noopener nofollow">List</a>보다 더 많은 메모리 공간을 필요로 한다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Linked List.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Linked List.md</guid><pubDate>Mon, 30 Jun 2025 08:47:19 GMT</pubDate></item><item><title><![CDATA[vector]]></title><description><![CDATA[ 
 <br>값을 몇 개 저장할지 미리 알려주지 않더라도 자동으로 용량을 늘려가며 값을 저장하는 방식이다.<br>
만약에 추가할 때 현재 사이즈를 초과할 거 같으면 이보다 더 큰 사이즈의 배열을 동적 할당하고<br>
거기에 값을 옮겨 적고 데이터를 추가한다.<br>
따라서 가끔씩 성능 저하가 발생한다.<br><br><a data-href="C++" href="컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++.html" class="internal-link" target="_self" rel="noopener nofollow">C++</a>에서 사용하는 List다.<br><br><a data-href="Python" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Python\Python.html" class="internal-link" target="_self" rel="noopener nofollow">Python</a>에서 사용하는 List다.<br><br><a data-href="Java" href="컴퓨터 공학\프로그래밍\언어\Java 계열\Java\Java.html" class="internal-link" target="_self" rel="noopener nofollow">Java</a>에서 사용하는 List다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\List.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/List.md</guid><pubDate>Tue, 24 Jun 2025 07:40:10 GMT</pubDate></item><item><title><![CDATA[Queue]]></title><description><![CDATA[ 
 <br>FIFO로 식당 대기 줄과 같은 형태다.<br>
일반적으로 enqueue 함수와 dequeue 함수로 구현한다.<br>
순서대로 값을 넣고 순서대로 값을 꺼내야 할 때 사용한다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Queue.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Queue.md</guid><pubDate>Sat, 21 Jun 2025 14:35:22 GMT</pubDate></item><item><title><![CDATA[Set]]></title><description><![CDATA[ 
 <br>중복된 값을 허용하지 않는 자료구조다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Set.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Set.md</guid><pubDate>Mon, 30 Jun 2025 08:47:49 GMT</pubDate></item><item><title><![CDATA[Stack]]></title><description><![CDATA[ 
 <br>FILO 방식으로 접시를 쌓는 것과 같은 느낌이다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Stack.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Stack.md</guid><pubDate>Sat, 21 Jun 2025 14:33:56 GMT</pubDate></item><item><title><![CDATA[Tuple]]></title><description><![CDATA[ 
 <br>배열과 같이 정해진 크기이지만<br>
수정을 할 수 없고 다양한 타입을 가진다.]]></description><link>컴퓨터 공학\프로그래밍\자료 구조\Tuple.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료 구조/Tuple.md</guid><pubDate>Wed, 02 Jul 2025 08:17:56 GMT</pubDate></item><item><title><![CDATA[문자 인코딩]]></title><description><![CDATA[ 
 <br><br>문자는 바이너리 코드로 컴퓨터에 들어간다.<br>
문자 인코딩은 여러가지가 있음<br><br>처음에는 문자 인코딩은 ASCII가 있었지만 알파벳만 가능하기에<br>
다른 언어를 넣기 위해 인코딩을 만들었지만 각 언어마다 인코딩을 만들어서<br>
통일되지 않아서 언어가 바뀌면 파일을 읽을 수 없게되는 문제가 발생했음<br>
그래서 유니코드를 만들어냄<br>UTF-8이 가장 널리 쓰임<br><br>Url 뒤에 매개변수를 넣거나 하면 한글 같은건 %??의 형태로 변경됨<br>
Url에서는 ASCII만 들어갈 수 있기에 인코딩을 해주는 것임]]></description><link>컴퓨터 공학\프로그래밍\자료형\문자 인코딩, 유니코드.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료형/문자 인코딩, 유니코드.md</guid><pubDate>Sat, 07 Jun 2025 02:18:28 GMT</pubDate></item><item><title><![CDATA[문자열]]></title><description><![CDATA[ 
 <br>문자 여러 개를 저장하는 자료형이다.<br>
문자열의 마지막에는 항상 '\0'이 있어야 한다.<br>
왜냐하면 출력할 때는 '\0'을 찾을 때까지 출력하기 때문이다.<br>
그런데 문자열을 저장하는 배열의 경우 <a data-href="List" href="컴퓨터 공학\프로그래밍\자료 구조\List.html" class="internal-link" target="_self" rel="noopener nofollow">List</a>방식일 건데 실제 크기와 문자열의 크기가 달라질 수 있다.<br>
그래서 크기를 구할 때는 항상 함수로 구한다.]]></description><link>컴퓨터 공학\프로그래밍\자료형\문자열.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료형/문자열.md</guid><pubDate>Mon, 30 Jun 2025 08:42:55 GMT</pubDate></item><item><title><![CDATA[비트]]></title><description><![CDATA[ 
 <br><br>0과 1로 이루어짐<br>
2진수를 가리킴<br>n개의 bit으로 2^n 개의 값을 저장함<br><br>비트를 8개로 묶은거<br><br>인코딩을 통해 매핑함<br>
아스키는 영어까지만 가능하기에 유니코드를 씀<br><br>1 바이트에서 8바이트의 크기를 가지는 변수를 사용함<br>
Rust는 16바이트<br><br>
<br>킬로
<br>메가
<br>기가
<br>테라
<br>페타<br>
하드디스크의 용량차이는<br>
이 바이트의 기준을 1000으로 잡느냐 1024로 잡느냐 차이인데<br>
이러한 모호함을 없애기 위해<br>
bi를 붙여서 
<br>키비
<br>메비
<br>기비
<br>테비<br>
의 방식으로 표현한다고 함
<br><br>UTF-8가 나오면서 인코딩이 달라서 발생하는 문제를 해결함<br>
아스키부터 유니코드까지 다 호환 가능해서 사용함<br>
UTF-8은 가변 길이 유니코드 인코딩 방식이다.<br>
가장 첫 바이트의 1이 얼마나 연속적으로 있는 개수가 한 글자의 바이트 수를 나타낸다.<br>
10이면 2바이트<br>
110이면 3바이트 이런식<br>
UTF-16는 비효율적이라 UTF-8이 주로 쓰인다.]]></description><link>컴퓨터 공학\프로그래밍\자료형\비트와 바이트 문자인코딩.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료형/비트와 바이트 문자인코딩.md</guid><pubDate>Sat, 07 Jun 2025 02:10:43 GMT</pubDate></item><item><title><![CDATA[정적 타입]]></title><description><![CDATA[ 
 <br>데이터를 저장할 때 적당한 공간에 맞게 저장할 수 있음<br><br>보통 <a data-href="컴파일 언어" href="컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\컴파일 언어.html" class="internal-link" target="_self" rel="noopener nofollow">컴파일 언어</a>가 정적 타입을 가짐<br>
변수 등에 지정된 자료형을 바꿀 수 없음<br><br>보통 <a data-href="인터프리터 언어" href="컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\인터프리터 언어.html" class="internal-link" target="_self" rel="noopener nofollow">인터프리터 언어</a>가 동적 타입을 가짐<br>
변수에 언제든 다른 자료형을 넣을 수 있음<br>
문제가 발생하기 쉬움<br>
실행 시간에 발견이 가능해서 오류 예방하기도 힘듬]]></description><link>컴퓨터 공학\프로그래밍\자료형\정적 타입 동적 타입.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료형/정적 타입 동적 타입.md</guid><pubDate>Sat, 07 Jun 2025 05:17:36 GMT</pubDate></item><item><title><![CDATA[컴파일 타임]]></title><description><![CDATA[ 
 <br><br>컴파일 타임 때는 모든 것이 정적이다.<br>
그러니까 변수의 경우 크기가 정해져 있다.<br>
변수의 경우 지역변수, 매개변수등이 해당한다.<br>
그러니 스택 메모리에 저장된다.<br><br>런타임 때는 크기를 미리 예측하는 건 불가능하다.<br>
그렇기에 힙 메모리에 저장한다.<br>
런타임에 에러가 발생하는 경우가 있는데 이건 컴파일 타임에 발생하는 에러보다 찾기 힘들다.<br>
특정 조건에 발생하는 경우에는 더 그렇다.]]></description><link>컴퓨터 공학\프로그래밍\자료형\컴파일 타임과 런타임.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/자료형/컴파일 타임과 런타임.md</guid><pubDate>Tue, 17 Jun 2025 14:57:27 GMT</pubDate></item><item><title><![CDATA[Test Driven Development]]></title><description><![CDATA[ 
 <br><br><br>
<br>구현하고자 하는 기능에 대한 테스트 코드를 먼저 작성
<br>이 단계에서는 테스트가 실패하는 것이 정상
<br><br>
<br>테스트를 통과시키기 위한 최소한의 코드만 작성
<br>코드 품질이나 최적화는 이 단계에서 고려하지 않음
<br><br>
<br>테스트가 통과하는 상태를 유지하면서 코드를 개선
<br>중복 제거, 가독성 향상, 성능 최적화 등을 수행
]]></description><link>컴퓨터 공학\프로그래밍\테스트\TDD.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/테스트/TDD.md</guid><pubDate>Thu, 29 May 2025 06:07:47 GMT</pubDate></item><item><title><![CDATA[TDD]]></title><description><![CDATA[ 
 <br><br>Test-Driven Development<br>
테스트 코드를 먼저 만들고, 실제 프로덕션 코드를 나중에 만드는 개발 방법을 말한다.<br><br>
<br>실패하는 테스트를 구현한다.
<br>테스트가 성공하도록 프로덕션 코드를 구현한다.
<br>프로덕션 코드와 테스트 코드를 리팩토링한다.
<br><br>변화에 대한 두려움을 줄여준다. (리팩토링이 편하다.)<br>
디버깅 시간을 줄여준다.<br>
동작하는 문서 역할을 한다.<br>
<br>TDD를 하면 자연스레 테스트 커버리지가 높아진다.
<br>오버엔지니어링 금지
<br>설계에 대한 피드백이 빠르다.
<br><br>높은 응집을 유도하지 않음<br>
단일 책임 원칙과 인터페이스 분리 원칙 위배에 어떤 신호도 주지 않는다.<br>
인터페이스 일관성을 도출하지 않는다.<br>
리팩토링 단계는 좋은 구조를 안내하거나 좋은 구조를 갖도록 강제하지 않는다.<br><br>코드가 이루고자 하는 가치나 기능을 테스트하기보다 그 기능을 어떻게 구현하고 있는지를 테스트한다.<br>
테스트 케이스들이 구현체와 결합도가 높아진다.<br>
구현체들을 리팩토링하면 결합되어있는 테스트 케이스들이 모두 깨져버린다.<br>따라서 우리는 구현체가 아닌 인터페이스를 테스트해야한다.<br><br>인수, 부하, 기능, 통합, 단위로 나눠지고 왼쪽이 가장 큰 개념 오른쪽이 가장 작은 개념이고 왼쪽이 오른쪽을 포함함<br><br>여러 작업 단위가 연계된 워크플로우를 테스트하기 위한 수단<br><br>공개된 API의 가장 바깥쪽에 해당하는 코드 검사<br><br>주어진 단위 시간 동안 어플리케이션이 얼마나 많은 요청을 처리할 수 있는지 검사<br><br>고객 또는 대리인이 정의되어진 모든 목적에 부합되는지 확인해보고자 하는 검사<br><br>가장 작은 단위의 테스트<br>
일반적으로 메서드 레벨이다.<br>
검증이 필요한 코드에 대해 테스트 케이스를 작성하는 절차 또는 프로세스다.<br>
테스트 코드가 목적 코드의 완전성을 입증해주기 때문에, 테스트 코드 그 자체만으로 주요한 가치가 있다.<br><br>
<br>문제 발견
<br>쉬운 변경
<br>품질 향상
<br>코드의 문서화
<br><br>F.I.R.S.T 법칙<br>
Fast (빠르게)<br>
Independent(독립적으로)<br>
Repeatable(반복 가능하게)<br>
Self-Validating(자가 검증하는)<br>
Timely(적시에)]]></description><link>컴퓨터 공학\프로그래밍\테스트\TDD와 단위 테스트.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/테스트/TDD와 단위 테스트.md</guid><pubDate>Thu, 19 Jun 2025 08:38:02 GMT</pubDate></item><item><title><![CDATA[<a data-href="컴파일 언어와 인터프리터 언어" href="컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일 언어와 인터프리터 언어/컴파일 언어와 인터프리터 언어.html" class="internal-link" target="_self" rel="noopener nofollow">컴파일 언어와 인터프리터 언어</a>]]></title><description><![CDATA[ 
 <br>문법에 맞지않게 작성하면 컴파일 에러를 발생시킨다.<br>
실행하던 중에 문제가 발생하면 런타임 에러가 발생한다.<br>
개발자의 의도와 다르게 작동하는 건 논리 오류<br><br>컴파일 언어는 컴파일 단계에서 문법 오류를 발견 할 수 있음 컴파일 언어도 실행단계에서야 논리 오류를 발견 할 수 있음<br>
인터프리터 언어는 실행 단계에서야 문법 오류나 논리 오류를 발견함]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\에러\에러.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/에러/에러.md</guid><pubDate>Sat, 07 Jun 2025 03:42:02 GMT</pubDate></item><item><title><![CDATA[try]]></title><description><![CDATA[ 
 <br><a data-href="에러" href="컴퓨터 공학\프로그래밍\프로그래밍 언어론\에러\에러.html" class="internal-link" target="_self" rel="noopener nofollow">에러</a>가 발생했을 때 프로그램 전체가 멈추지 않고 에러에 대처하기 위한 기능이다.<br><br>에러가 발생할 수 있는 코드를 넣는 공간이다.<br><br>에러가 발생하면 실행되어야하는 코드를 넣는 공간이다.<br><br>에러가 발생하든 발생하지 않든 실행되어야 하는 코드를 넣는 공간이다.<br>
return이 발생해도 무조건 실행된다.<br><br>에러를 발생시키는 코드다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\에러\예외 처리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/에러/예외 처리.md</guid><pubDate>Tue, 24 Jun 2025 08:11:08 GMT</pubDate></item><item><title><![CDATA[인터프리터 언어]]></title><description><![CDATA[ 
 <br>명령어를 한 줄씩 읽어 인터프리터가 실행하는 구조의 언어입니다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\인터프리터 언어.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일 언어와 인터프리터 언어/인터프리터 언어.md</guid><pubDate>Sun, 22 Jun 2025 13:56:20 GMT</pubDate></item><item><title><![CDATA[컴파일 언어]]></title><description><![CDATA[ 
 <br>컴파일 언어는 실행시키기 코드를 전 해당 컴퓨터 아키텍쳐, 운영체제에 맞게 명령어를 짜서<br>
프로그램을 완성시키는 언어]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\컴파일 언어.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일 언어와 인터프리터 언어/컴파일 언어.md</guid><pubDate>Sat, 07 Jun 2025 05:10:09 GMT</pubDate></item><item><title><![CDATA[<a data-href="컴파일 언어" href="컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일 언어와 인터프리터 언어/컴파일 언어.html" class="internal-link" target="_self" rel="noopener nofollow">컴파일 언어</a>]]></title><description><![CDATA[ 
 <br><br>]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일 언어와 인터프리터 언어\컴파일 언어와 인터프리터 언어.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일 언어와 인터프리터 언어/컴파일 언어와 인터프리터 언어.md</guid><pubDate>Sat, 07 Jun 2025 05:15:47 GMT</pubDate></item><item><title><![CDATA[Abstract Syntax Tree]]></title><description><![CDATA[ 
 <br>추상 구문 트리는 프로그래밍 언어로 쓰여진 소스코드를 컴퓨터가 이해할 수 있도록 분리한 토큰으로 만든 트리다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\구문 분석\Abstract Syntax Tree.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일러 이론/구문 분석/Abstract Syntax Tree.md</guid><pubDate>Thu, 19 Jun 2025 08:27:11 GMT</pubDate></item><item><title><![CDATA[Lexer]]></title><description><![CDATA[ 
 <br>Tokenizer로 인해 쪼개진 토큰들의 의미를 분석하는 역할이다.<br>
println("Hello world")라는 코드를 어휘 분석 하면 우선&nbsp;println,&nbsp;(,&nbsp;"Hello world",&nbsp;)&nbsp;이런 토큰들로 쪼갤 수 있다. 쪼갠 토큰들의 의미를 분석하는것이 Lexer의 역할이다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\구문 분석\Lexer.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일러 이론/구문 분석/Lexer.md</guid><pubDate>Thu, 19 Jun 2025 08:26:08 GMT</pubDate></item><item><title><![CDATA[Parser]]></title><description><![CDATA[ 
 <br>토큰을 구조적으로 나타낸다. 데이터가 올바른지 검증하기도 하고<br>
문법 구조를 따라 트리 형식으로 표현하는 추상 구문 트리를 생성한다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\구문 분석\Parser.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일러 이론/구문 분석/Parser.md</guid><pubDate>Thu, 19 Jun 2025 08:26:45 GMT</pubDate></item><item><title><![CDATA[Tokenizer]]></title><description><![CDATA[ 
 <br>소스 코드 구문을 토큰화 하는 역할을 한다.<br>일반적으로 프로그래밍 언어에서 사용하는 토큰의 종류는<br>
<br>identifier : 식별하기 위한 이름
<br>keyword : 미리 지정한 예약어
<br>separator : 글자를 구분하는 문자
<br>operator : 연산을 위한 심볼
<br>literal : 숫자, 논리, 문자
<br>comment : 줄 또는 블록 코멘터리
]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\구문 분석\Tokenizer.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일러 이론/구문 분석/Tokenizer.md</guid><pubDate>Thu, 19 Jun 2025 08:25:15 GMT</pubDate></item><item><title><![CDATA[부트 스트래핑]]></title><description><![CDATA[ 
 <br>프로그래밍 언어 A를 만들고 A를 사용해 A를 컴파일 하는 <a data-href="컴파일러" href="컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\컴파일러.html" class="internal-link" target="_self" rel="noopener nofollow">컴파일러</a>를 만들어서<br>
A로 만든 컴파일러로 A를 컴파일을 시키는 방식을 말한다.<br>
스스로가 스스로를 컴파일하는 신기한 현상이지만 프로그래밍 언어를 만드는 사람들에게는 흔히 일어나는 일이다.<br><a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>를 예시로 들면 C제작자는 C를 제작할 때 어셈블리어로 제작을 했는데 함수이름을 인식하는 기능을 만드는게 너무 어려워서 앞자리 5글자만 구분하게 만들어 놓고 C 컴파일러를 만들고<br>
C를 이용해서 C를 만들었는데 이후에는 함수 이름 전체를 구분할 수 있게 되었다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\부트 스트래핑.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일러 이론/부트 스트래핑.md</guid><pubDate>Mon, 30 Jun 2025 06:18:52 GMT</pubDate></item><item><title><![CDATA[컴파일러 동작 과정]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br>]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\컴파일러 이론\컴파일러.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/컴파일러 이론/컴파일러.md</guid><pubDate>Thu, 19 Jun 2025 08:27:49 GMT</pubDate></item><item><title><![CDATA[메모리 누수]]></title><description><![CDATA[ 
 <br>동적으로 할당하는 메모리를 프로그래밍 언어가 대신 해제해주는 기능이다.<br>
더 이상 이 메모리가 사용되지 않을 때 자동으로 해제된다.<br>요즘은 멀티 <a data-href="스레드" href="컴퓨터 공학\운영체제\프로세스\스레드\스레드.html" class="internal-link" target="_self" rel="noopener nofollow">스레드</a>로 처리한다고 함<br>
가비지 컬렉터는 만능이 아니기에 조심해야함<br><br>메모리를 직접 관리하는 프로그래밍 언어에서 까먹고 메모리를 해제하지 않은 상태를 말한다.<br>
이런 메모리가 모여서 메모리 공간을 다 채우면 프로그램이 종료된다.<br><br>메모리를 관리해주는 언어를 말한다.<br><br>실행하면서 변수들을 싹 훑어보고 필요한 변수만 마크를 남기고 마크 안된 것을 다 날리는 것이다.<br><br>참조 횟수를 보다가 참조 횟수가 0이 되면 삭제하는 방식이다<br><br>변수가 서로 참조하면 레퍼런스 카운팅이 0이 되지 않아서 끝까지 살아남는다.<br><br>메모리 관리하는 툴이 있으니 그걸 활용해서 메모리 누수 잡으면 됨]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\가비지 컬렉터.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/가비지 컬렉터.md</guid><pubDate>Thu, 19 Jun 2025 08:35:23 GMT</pubDate></item><item><title><![CDATA[변수]]></title><description><![CDATA[ 
 <br><br>값을 담을 수 있는 이름이 있는 그릇<br>
담은 값을 바꿀 수 있다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\변수와 값.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/변수와 값.md</guid><pubDate>Sat, 07 Jun 2025 07:06:16 GMT</pubDate></item><item><title><![CDATA[애플리케이션]]></title><description><![CDATA[ 
 <br><br>일반 사용자가 사용할 기능을 제공하는, 컴퓨터가 실행할 수 있는 명령어들의 집합<br><br>실행된 애플리케이션이 상주하는 곳<br><br>명령어를 실행하는 주체<br>]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\변수와 객체와 메모리의 관계.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/변수와 객체와 메모리의 관계.md</guid><pubDate>Wed, 25 Jun 2025 08:06:59 GMT</pubDate></item><item><title><![CDATA[재귀 함수]]></title><description><![CDATA[ 
 <br>스스로 스스로를 호출하는 함수<br>
탈출 조건이 없으면 메모리를 소진 할 때까지 스스로를 호출한다.<br>
함수를 호출 할 때마다 스택을 사용한다.<br>
함수를 호출하면서 함수 내 지역 변수들의 값이 계속 저장되기에 특정 상황에 자주 사용된다.<br>
코드 읽는 게 힘들어진다. 지난 정보 처리 기사 자격증 실기처럼<br>
반복문으로 해결이 가능한 경우가 있지만<br>
재귀 함수로 작성하면 더 효율적으로 코드를 짤 수 있는 종류의 문제가 있다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\재귀 함수.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/재귀 함수.md</guid><pubDate>Mon, 09 Jun 2025 07:53:50 GMT</pubDate></item><item><title><![CDATA[클로저]]></title><description><![CDATA[ 
 <br>함수가 선언될 당시의 환경을 기억했다가 나중에 호출 되었을 때 원래의 환경에 따라 수행되는 함수를 말한다.]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\클로저.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/클로저.md</guid><pubDate>Thu, 03 Jul 2025 07:20:03 GMT</pubDate></item><item><title><![CDATA[Scope]]></title><description><![CDATA[ 
 <br>변수에게 허용된 영역을 scope라고 함<br>
스택의 경우 할당을 했다가 해제했다를 반복하는데 할당 받고 해제하기 까지의 영역이다.<br>
변수는 가장 가까운 스코프를 먼저 본다.<br>
<a data-href="Javascript 변수" href="컴퓨터 공학\프로그래밍\언어\인터프리터 언어\Javascript\Javascript 변수.html" class="internal-link" target="_self" rel="noopener nofollow">Javascript 변수</a>에서 var 변수는 호이스팅을 통해 선언하기 전에 undefined로 사용가능함]]></description><link>컴퓨터 공학\프로그래밍\프로그래밍 언어론\Scope.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/프로그래밍 언어론/Scope.md</guid><pubDate>Tue, 17 Jun 2025 08:57:29 GMT</pubDate></item><item><title><![CDATA[컨트롤러]]></title><description><![CDATA[ 
 <br>아래 처럼 구조를 쌓아 두고 분리시키는 구조를 말한다.<br><br>입력을 받는 레이어<br><br>비스니스 로직을 담당한다.<br><br>데이터를 관리한다.]]></description><link>컴퓨터 공학\프로그래밍\레이어드 아키텍쳐.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/레이어드 아키텍쳐.md</guid><pubDate>Fri, 06 Jun 2025 02:43:16 GMT</pubDate></item><item><title><![CDATA[오픈소스]]></title><description><![CDATA[ 
 <br>누구나 공짜로 가져다 쓸 수 있고<br>
코드도 마음대로 볼 수 있고<br>
마음대로 개조할 수도 있는 것]]></description><link>컴퓨터 공학\프로그래밍\오픈소스.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/오픈소스.md</guid><pubDate>Mon, 23 Jun 2025 08:12:18 GMT</pubDate></item><item><title><![CDATA[어떤 것이 클린 코드인가]]></title><description><![CDATA[ 
 <br><br>
<br>중복이 적은 코드
<br>내가 작성한 코드를 처음 보는 동료, 미래의 나까지도 쉽게 읽을 수 있는 코드
<br>함수가 한 가지의 기능만 수행하는 경우
<br>코드를 작게 쓰고 추상화한 경우
<br><br><br><br><br><br><br><br><br><br><br><br><a data-tooltip-position="top" aria-label="https://velog.io/@yeseong31/Clean-Code-%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4" rel="noopener nofollow" class="external-link" href="https://velog.io/@yeseong31/Clean-Code-%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4" target="_blank">링크</a>]]></description><link>컴퓨터 공학\프로그래밍\클린 코드.html</link><guid isPermaLink="false">컴퓨터 공학/프로그래밍/클린 코드.md</guid><pubDate>Tue, 01 Jul 2025 08:35:43 GMT</pubDate></item><item><title><![CDATA[데이터베이스]]></title><description><![CDATA[ 
 <br><br>전자적으로 저장되고 사용되는 관련있는 데이터들의 조직화된 집합<br><br>Database Management System<br>
사용자에게 DB를 정의하고 만들고 관리하는 기능을 제공하는 소프트웨어 시스템<br><br>database를 정의하거나 기술하는 data<br>
catalog라고도 부름<br>
DBMS를 통해 저장/관리된다.<br><br>database + DBMS + 연관된 Applications 를 말한다.<br>
를 줄여 database라고도 부른다.<br><br>유저가 Database System으로 접속하고 SQL문을 DBMS에 제공하면<br>
DBMS가 SQL을 해석하고 Meta-Data를 먼저 조회를 하고 그 데이터를 바탕으로 DB에서 데이터를 가져와 유저에게 제공한다.<br><br>DB의 구조를 기술하는데 사용될 수 있는 개념들이 모인 집합<br>
DB 구조를 추상화해서 표현할 수 있는 수단을 제공한다.<br>
DB에 읽고 쓰기 위한 기본적인 동작들도 포함한다.<br>
<br><a data-href="개념적 데이터 모델링" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\개념적 데이터 모델링.html" class="internal-link" target="_self" rel="noopener nofollow">개념적 데이터 모델링</a> 

<br>높은 수준의 추상화를 한다.


<br><a data-href="논리적 데이터 모델링" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\논리적 데이터 모델링.html" class="internal-link" target="_self" rel="noopener nofollow">논리적 데이터 모델링</a>

<br>DB 구조화를 가능하게 한다.
<br>특정 DBMS에 종속되지 않는다.


<br><a data-href="물리적 데이터 모델링" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\물리적 데이터 모델링.html" class="internal-link" target="_self" rel="noopener nofollow">물리적 데이터 모델링</a><br>
이 있다.
<br><br>Data model을 바탕으로 database의 구조를 기술한 것이다.<br><br>특정 시점에 database에 있는 데이터를 Database State 혹은 Snapshot이라고 한다.<br><br>User application으로 부터 물리적인 Database를 분리시키는 것이 목적이다.<br>각 레벨을 독립시켜서 어느 레벨에서의 변화가 상위 레벨에 영향을 주지 않기 위해서 만들었다.<br>
대부분의 DBMS가 Three level을 완벽하게 혹은 명시적으로 나누지는 않는다.<br>
데이터가 존재하는 곳은 Internal level이다.<br><br>view 레벨에 정의되어 있는 스키마<br>
external views, user views라고 불림<br>
특정 유저들이 필요로 하는 데이터만 표현한다.<br>
그 외 알려줄 필요가 없는 데이터는 숨긴다.<br>
논리적 데이터 모델을 통해 표현한다.<br><br>전체 Database에 대한 구조를 기술한다.<br>
물리적인 저장 구조에 관한 내용은 숨긴다.<br>
Entities, Data types, Relationships, User operations, Constaints에 집중한다.<br>
논리적 데이터 모델을 통해 기술한다.<br><br>물리적으로 데이터가 어떻게 저장되는지 물리적 데이터 모델을 통해 표현한다.<br>
data storage, data structure, Access path등 실체가 있는 내용을 기술한다.<br><br>Conceptual Schemas를 정의하기 위해 사용되는 언어다.<br><br>Internal Schemas를 정의하는 용도로 사용되는 언어다.<br><br>External Schemas를 정의하기 위해 사용되는 언어다.<br>
대부분의 DBMS에서는 DDL이 VDL의 역할까지 수행한다.<br><br>Database에 있는 data를 활용하기 위한 언어다.<br><br>DML, VDL, DDL을 통합한 언어다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DB\데이터베이스 용어.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DB/데이터베이스 용어.md</guid><pubDate>Wed, 18 Jun 2025 08:48:23 GMT</pubDate></item><item><title><![CDATA[한글 검색]]></title><description><![CDATA[ 
 <br>엘라스틱 서치<br>
mroonga ]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DB\한글 검색.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DB/한글 검색.md</guid><pubDate>Tue, 24 Jun 2025 01:12:36 GMT</pubDate></item><item><title><![CDATA[중복 데이터 문제]]></title><description><![CDATA[ 
 <br>DB 테이블 설계를 잘못한 경우 발생할 수 있는 문제를 기술하려고 한다.<br><br>데이터를 중복되게 저장하면 데이터를 수정하거나 삭제할 때 여러 번 작업을 해야한다.<br>
별개의 관심사가 한 테이블에 있다.<br><br>저장공간을 낭비하고<br>
실수로 인해 데이터 불일치 가능성이 존재한다.<br>
null값을 많이 쓰게 된다.<br>
쓸데없는 값을 넣고 삭제 해야하는 경우도 발생한다.<br><br>의도치 않게 데이터를 삭제하는 경우도 발생하고<br>
이를 해결해도 null값을 많이 쓰게 된다.<br><br>일부만 업데이트 되어 데이터 불일치가 발생할 가능성이 있다.<br><br>join하면 가짜 정보가 발생한다.<br><br>null값이 있는 column으로 join하는 경우 상황에 따라 예상과 다른 결과가 발생한다.<br>
null값이 있는 column에 aggregate function을 사용했을 때 주의가 필요하다.<br>
불필요한 storage를 낭비한다.<br><br>
<br>의미적으로 관련있는 속성들끼리 테이블을 구성
<br>중복 데이터를 최대한 허용하지 않도록 설계
<br>join 수행 시 가짜 데이터가 생기지 않도록 설계
<br>되도록 null 값을 줄일 수 있는 방향으로 설계
]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DB\DB 테이블 설계 문제.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DB/DB 테이블 설계 문제.md</guid><pubDate>Fri, 04 Jul 2025 08:31:26 GMT</pubDate></item><item><title><![CDATA[Index란]]></title><description><![CDATA[ 
 <br><br>임의의 규칙대로 부여된 임의의 대상을 가리키는 것<br><br><br>정렬되어 있다.<br>
그래서 중간에 insert를 하면 뒤의 값을 밀어줘야 한다.<br><br>정렬되어 있지 않다.<br><br>순서대로 있고<br>
unique하다.<br>
범위 검색하기 좋다.<br>
존재하는 PK 사이에 Insert할 수 없다.<br><br>순서 상관 없고<br>
unique하지 않고<br>
추가 저장 공간이 필요하다.<br>
Insert시 추가 작업이 필요하다. (인덱스 생성한다.)<br><br>0.5초, 5초걸리던 작업이 0.00, 0.01초가 걸리게 변한다.<br><br>빠르게 데이터를 찾기 위해 정렬해둔  컬럼 사본<br>
실제로는 트리의 형태를 가진다.<br><br>각 노드에 여러 개를 넣을 수 있는데 성능이 올라간다. 이를 <a data-href="B-Tree" href="컴퓨터 공학\프로그래밍\자료 구조\Tree\B-Tree.html" class="internal-link" target="_self" rel="noopener nofollow">B-Tree</a>라고 부른다.<br>
이보다 성능을 좋게 만든 건 B+tree로 가이드 방식이다.<br>
몇 이상은 오른쪽 몇 이하는 왼쪽이라는 방식이 트리로 되어있음<br>
그리고 terminal끼리 연결되어있어 범위 검색이 가능하다.<br><br>인덱스를 통해 값을 찾고 값에 해당하는 Row값을 통해 데이터를 가져온다.<br><br>용량이 늘어남<br>
데이터가 늘어날 때마다 인덱스도 같이 수정해야해서 성능 하락이 있지만 걱정할만큼은 아니다.<br><br>Primary key는 이미 정렬되어있어 index 생성 필요없다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DB\Index.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DB/Index.md</guid><pubDate>Fri, 20 Jun 2025 05:03:48 GMT</pubDate></item><item><title><![CDATA[Isolation Level]]></title><description><![CDATA[ 
 <br>MultiVersion Concurrency Control의 약자다<br>MVCC는 commit된 데이터만 읽는다.<br><br><br>read하는 시간을 기준으로 그 전에 commit된 데이터를 읽는다.<br><br>트랜잭션 시작 시간 기준으로 그 전에 commit된 데이터를 읽는다.<br><br><br>MVCC로 동작하기 보다 lock으로 동작한다.<br><br>SSI(Serializable Snapshot Isolation) 기법이 적용된 MVCC로 동작한다.<br><br>MVCC는 committed된 데이터를 읽기 때문에<br>
이 level에서는 보통 MVCC가 적용되지 않는다.<br>postgresql의 경우 read uncommitted level이 존재하지만<br>
read committed level처럼 동작한다.<br><br>두 개의 트랜잭션이 동시에 돌아갈 때 같은 데이터에 접근할 때 둘다 read committed의 경우<br>
한 트랜잭션의 연산을 무시하게 되는데 이 상황을 말한다.<br><br>한 트랜잭션의 Isolation level을 변경한다.<br>postgresql에서는 repeatable read level에서 같은 데이터에 먼저 update한 tx가 commit되면 나중 tx는 rollback이 된다.<br>
먼저 업데이트 한 트랜잭션이 이긴다고 해서 first-updater-win이라고 부른다.<br><br>mysql에서는 위 개념이 없어서 오류가 발생한다.<br>읽을 때 Locking read를 한다.<br>
select 문에 for update 또는 for share를 붙여서 locking read를 한다.<br>
for update는 exclusive lock을 획득하고<br>
for share는 share lock을 획득한다.<br>처음으로 locking read를 하면 lock을 걸어서 읽지 못하게 막는다.<br>
두번쨰로 locking read를 하면 읽지 못하다가 commit이 끝난 후 읽는다.<br>locking read는 가장 최근의 commit된 데이터를 읽는다.<br>
따라서 업데이트가 된 데이터를 읽는다.<br><br>repeatable read isolation level에서<br>
두 개의 트랜잭션이 두 변수에 접근해 각각 다른 변수에 쓰는데<br>
각각 한개의 연산이 무시되어서 이상한 결과를 발생시키는 현상이다.<br>
예시 문제는 transaction 1은 x와 y를 더해서 x에 쓰고<br>
transaction 2는 x와 y를 더해서 y에 쓴다.<br><br>locking read를 사용한다.<br><br>위와 같은 방식을 사용하면 rollback이 되는 <a data-tooltip-position="top" aria-label="MVCC > Lost Update > postgresql 해결방법" data-href="MVCC#Lost Update#postgresql 해결방법" href="컴퓨터 공학\프로그램\데이터 베이스\DB\MVCC.html#Lost_Update" class="internal-link" target="_self" rel="noopener nofollow">문제</a>가 발생한다.<br>
그래서 다시 시도를 해야한다.<br><br><br>repeatable read와 유사하다<br>
트랜잭션의 모든 평범한 select 문은 암묵적으로 select for share 처럼 동작한다.<br>
for update 보다 데드락이 걸릴 가능성이 높기에 주의해야한다.<br><br>SSI로 구현한다.<br>
first-committer-winner 방식이다.<br><br>MVCC는 데이터를 읽을 때 특정 시점 기준으로 가장 최근에 commit된 데이터를 읽는다.<br>
데이터 변화 이력을 관리한다.<br>
read와 write는 서로를 block 하지 않는다.<br>이렇게 읽는 것을 MySql에서는 Consistent Read라고 부른다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DB\MVCC.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DB/MVCC.md</guid><pubDate>Sun, 06 Jul 2025 14:52:37 GMT</pubDate></item><item><title><![CDATA[ERD]]></title><description><![CDATA[ 
 <br><br>어떤 정보가 있는지 알게 해주고<br>
정보를 그룹화 시켜 묶고<br>
그 그룹간의 관계를 표현한다.<br><br>표 안에 표로 표현하면 안된다.<br>
어떻게 변경시켜 하나의 표를 만들어도 중복이 발생하면 안된다.<br>
그래서 표를 나눠야 한다.<br><br>표현할 때 동그라미로 표현한다.<br><br>속성 중 기본키에는 밑줄을 그어 표시한다.<br><br>하나의 표를 나눠서 Entity가 된다.<br>
표현할 때 네모로 표현한다.<br>
Attribute를 선으로 연결한다.<br><br>표현할 때 마름모로 표현한다.<br>
Entity와 선으로 연결한다.<br>엔티티간 관계에서<br>
<a data-href="Cardinality" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Cardinality.html" class="internal-link" target="_self" rel="noopener nofollow">Cardinality</a>와 <a data-href="Optionality" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Optionality.html" class="internal-link" target="_self" rel="noopener nofollow">Optionality</a>가 있는데 고려해서 표기한다.<br><br>쓰기 페이지에서 보이는 정보가 각각 하나의 테이블에 들어갈 만함<br><br>정규화를 통해 데이터의 중복을 없애야 한다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\개념적 데이터 모델링.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/개념적 데이터 모델링.md</guid><pubDate>Tue, 17 Jun 2025 06:25:20 GMT</pubDate></item><item><title><![CDATA[Mapping Rule]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>A가 B에게 Private Key를 넘겨 Foreign Key를 주면 됨<br><br>A가 B에게 Private Key를 넘겨 Foreign Key를 주면 됨<br><br>Mapping Table이 필요함<br>
A와 B의 Primary Key를 가지는 테이블을 생성함]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\논리적 데이터 모델링.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/논리적 데이터 모델링.md</guid><pubDate>Fri, 13 Jun 2025 07:40:03 GMT</pubDate></item><item><title><![CDATA[1. <a data-href="업무파악" href="컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/업무파악.html" class="internal-link" target="_self" rel="noopener nofollow">업무파악</a>]]></title><description><![CDATA[ 
 <br><br><br><br>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\데이터 모델링 전체 흐름.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/데이터 모델링 전체 흐름.md</guid><pubDate>Thu, 12 Jun 2025 08:04:13 GMT</pubDate></item><item><title><![CDATA[find slow query]]></title><description><![CDATA[ 
 <br><br>느려지는 쿼리를 파악을 하고<br>
최적화를 해야함<br><br>정리를 해서 찾는 데 걸리는 속도를 높임<br><br>캐시(임시 데이터)를 저장해서 사용하기<br><br>속도를 위해 정규화에서 반대로 설계하는 방법]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\물리적 데이터 모델링.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/물리적 데이터 모델링.md</guid><pubDate>Sat, 14 Jun 2025 07:50:35 GMT</pubDate></item><item><title><![CDATA[후보키]]></title><description><![CDATA[ 
 <br><br>하나만 있을 것으로 보이는 값들을 말한다.<br>
키가 될 수 있다.<br><br>정해진 키다.<br><br>기본키를 제외한 후보키다.<br><br>여러 개를 하나로 묶어서 만든 키다.<br><br>다른 테이블의 기본키를 가져온 것을 말한다.<br><br>relation에서 tuples를 unique하게 식별할 수 있는 attributes set이다.<br><br>어느 한 attribute라도 제거하면 unique하게 tuple을 식별할 수 없는 super key를 말한다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\식별자.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/식별자.md</guid><pubDate>Wed, 02 Jul 2025 08:13:08 GMT</pubDate></item><item><title><![CDATA[업무파악]]></title><description><![CDATA[ 
 <br>의뢰자와 실무자와 같이 UI를 작성해보는 방법이 좋다.<br>
말의 기능을 불신할 것]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\업무파악.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/업무파악.md</guid><pubDate>Thu, 12 Jun 2025 08:08:10 GMT</pubDate></item><item><title><![CDATA[정규화]]></title><description><![CDATA[ 
 <br><br>중복된 데이터를 없애는 게 목적<br><br>여러 개가 하나에 저장되어 있는 값을 분리시키는 작업이다.<br><br>부분 함수 종속을 제거<br><br>이행적 함수 종속 제거<br><br>결정자가 후보키가 아닌 함수 종속을 제거<br><br>다치 종속을 제거<br><br>조인 종속을 제거]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\정규화.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/정규화.md</guid><pubDate>Fri, 13 Jun 2025 07:53:37 GMT</pubDate></item><item><title><![CDATA[데이터 베이스]]></title><description><![CDATA[ 
 <br>데이터의 가작 작은 단위다.<br><br>데이터 베이스에서는 하나의 Column이다.<br><br>값이 존재하지 않는다.<br>
값이 존재하나 아직 그 값이 무엇인지 알지 못한다.<br>
해당 사항과 관련이 없다.<br>이렇듯 애매하기에 자주 사용하면 안된다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Attribute.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Attribute.md</guid><pubDate>Wed, 02 Jul 2025 08:10:49 GMT</pubDate></item><item><title><![CDATA[1 대 1 관계]]></title><description><![CDATA[ 
 <br><br>A와 B가 있을 때<br>
A에게는 B가 하나 있음<br>
B에게는 A가 하나 있음<br>
이런 관계를 말함<br><br>A와 B가 있을 때<br>
A에게는 B가 여러개임<br>
B에게는 A가 하나임<br>
이런 관계를 말함<br>
선으로 표현하면 B 근처에서 3갈래로 들어옴<br><br>A와 B가 있을 때<br>
A에게는 B가 여러개임<br>
B에게는 A가 여러개임<br>
이런 관계를 말함<br>
선으로 표현하면 A와 B 근처에서 3갈래로 들어옴<br>
이 경우 중개해주는 테이블을 하나 더 만들어서 1대 N 관계로 만들어 표현함]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Cardinality.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Cardinality.md</guid><pubDate>Thu, 12 Jun 2025 08:48:48 GMT</pubDate></item><item><title><![CDATA[implicit constraints]]></title><description><![CDATA[ 
 <br>relational database의 relations들이 언제나 항상 지켜줘야 하는 제약 사항을 말한다.<br><br>relational data model 자체가 가지는 constraints를 말한다.<br>
relation은 중복되는 tuple을 가질 수 없다.<br>
relation 내에서는 같은 이름의 attribute를 가질 수 없다.<br><br>주로 DDL을 통해 schema에 직접 명시할 수 있는 constraints다.<br>
explicit constraints라고 부른다.<br><br>attribute의 value는 해당 attribute의 domain에 속한 value여야 한다.<br><br>서로 다른 tuples는 같은 value의 key를 가질 수 없다.<br><br>attribute가 NOT NULL로 명시됐다면 NULL을 값으로 가질 수 없다.<br><br>primary key는 value에 NULL을 가질 수 없다.<br><br>FK와 PK와 도메인이 같아야 하고 PK에 없는 Value를 FK가 값으로 가질 수 없다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\constraints.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/constraints.md</guid><pubDate>Wed, 02 Jul 2025 08:29:38 GMT</pubDate></item><item><title><![CDATA[<a data-href="Attribute" href="컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Attribute.html" class="internal-link" target="_self" rel="noopener nofollow">Attribute</a>]]></title><description><![CDATA[ 
 <br><a data-href="Attribute" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Attribute.html" class="internal-link" target="_self" rel="noopener nofollow">Attribute</a>의 묶음이다.<br><br>Attribute는 Entity에 속해있다.<br><br>데이터 베이스로 가면 테이블이다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Entity.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Entity.md</guid><pubDate>Thu, 12 Jun 2025 08:26:50 GMT</pubDate></item><item><title><![CDATA[Optional]]></title><description><![CDATA[ 
 <br><br>A에게 B는 있을 수도 있고 없을 수도 있음<br>
이 경우 B는 Optional임<br>
표기할 때 B 근처로 동그라미를 그림<br><br>B에게는 A가 꼭 있어야함<br>
이 경우 A는 Mandatory임<br>
표기할 때 A 근처로 작대기를 하나 그음]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Optionality.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Optionality.md</guid><pubDate>Fri, 13 Jun 2025 07:21:12 GMT</pubDate></item><item><title><![CDATA[데이터 베이스]]></title><description><![CDATA[ 
 <br><a data-href="Entity" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a>간의 관계를 나타낸다.<br><br>데이터 베이스에서는 PK, FK가 된다.<br><br><br>중복된 tuple을 가질 수 없다.<br>
튜플을 식별하기 위해 attribute의 부분 집합을 key로 설정한다.<br>
relation에서 tuple의 순서는 중요하지 않다.<br>
하나의 relation에서 attribute의 이름은 중복되면 안된다.<br>
attribute는 atomic 해야 한다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Relation.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Relation.md</guid><pubDate>Wed, 02 Jul 2025 08:08:39 GMT</pubDate></item><item><title><![CDATA[degree]]></title><description><![CDATA[ 
 <br>relation의 구조를 나타낸다.<br>
relation 이름과 attributes 리스트로 표기된다.<br><br>atrribute의 수를 말한다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\Relation Schema.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/Relation Schema.md</guid><pubDate>Wed, 02 Jul 2025 08:02:09 GMT</pubDate></item><item><title><![CDATA[relational database schema]]></title><description><![CDATA[ 
 <br>relation schemas set과 integrity constrains set을 합친 것이다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터 모델링\relational database schema.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터 모델링/relational database schema.md</guid><pubDate>Wed, 02 Jul 2025 08:06:27 GMT</pubDate></item><item><title><![CDATA[MariaDb]]></title><description><![CDATA[ 
 <br><a data-href="MySql" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\MySql\MySql.html" class="internal-link" target="_self" rel="noopener nofollow">MySql</a>에서 벗어나 만든 데이터베이스로 기반이 <a data-href="MySql" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\MySql\MySql.html" class="internal-link" target="_self" rel="noopener nofollow">MySql</a>이다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\MariaDb\MariaDb.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/MariaDb/MariaDb.md</guid><pubDate>Fri, 20 Jun 2025 08:33:46 GMT</pubDate></item><item><title><![CDATA[MySql]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\MySql\MySql.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/MySql/MySql.md</guid><pubDate>Fri, 20 Jun 2025 08:33:02 GMT</pubDate></item><item><title><![CDATA[insert 할 때 자동 생성된 ID 값 가져오기]]></title><description><![CDATA[ 
 <br><br>public int insertWiseSaying( String content, String author){  
    PreparedStatement stmt;  
    int id = 0;  
    try{  
  
        stmt = conn.prepareStatement(getInsertSql(content, author), Statement.RETURN_GENERATED_KEYS);  
        stmt.executeUpdate();  
        ResultSet rs = stmt.getGeneratedKeys();  
        if(rs.next()){  
            id = rs.getInt(1);  
        }  
        stmt.close();  
    }catch (SQLException e){  
        System.out.println("sql failed" + e.getMessage());  
    }  
    return id;  
}
<br>이런 식으로 하면 됨<br><br>Properties properties = new Properties();
try {
  properties.load(new FileInputStream("db.properties"));
} catch (IOException e){
  e.printStackTrace();
}
URL = properties.getProperty("URL");
USERNAME = properties.getProperty("USERNAME");
PASSWORD = properties.getProperty("PASSWORD");
<br>이렇게 하면 될거임<br>
물론 암호화 해두면 좋을 듯<br><br>String query = "insert into wisesaying (content, author) values (?, ?)";
PreparedStatement preparedStatement = connection.prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
preparedStatement.setString(1, content);
preparedStatement.setString(2, author);
<br>이런식으로 가능함]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\MySql\MySql 팁.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/MySql/MySql 팁.md</guid><pubDate>Thu, 29 May 2025 00:10:37 GMT</pubDate></item><item><title><![CDATA[Oracle]]></title><description><![CDATA[ 
 <br>Oracle 사에서 만든 데이터베이스]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\Oracle\Oracle.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/Oracle/Oracle.md</guid><pubDate>Fri, 20 Jun 2025 08:32:37 GMT</pubDate></item><item><title><![CDATA[출처]]></title><description><![CDATA[ 
 <br>The PostgreSQL Global Development Group에서 개발하는 오픈 소스 ORDBMS다.<br><a data-href="MySql" href="컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\MySql\MySql.html" class="internal-link" target="_self" rel="noopener nofollow">MySql</a>에 비해서 SQL 표준을 더 잘 지원하고 기능이 더 강력하고<br>
쿼리가 복잡해질수록 성능이 더 잘 나오는 편이다.<br><br><a data-tooltip-position="top" aria-label="https://namu.wiki/w/PostgreSQL#%ED%83%80%20DB%EC%99%80%EC%9D%98%20%EB%B9%84%EA%B5%90" rel="noopener nofollow" class="external-link" href="https://namu.wiki/w/PostgreSQL#%ED%83%80%20DB%EC%99%80%EC%9D%98%20%EB%B9%84%EA%B5%90" target="_blank">나무위키</a><br>
<a data-tooltip-position="top" aria-label="https://youtu.be/-PbP1TcD94Q?si=19VVSk4LX468LUIJ" rel="noopener nofollow" class="external-link" href="https://youtu.be/-PbP1TcD94Q?si=19VVSk4LX468LUIJ" target="_blank">MYSQL vs PostgreSQL 당신의 선택은?</a>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\Postgresql\Postgresql.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/Postgresql/Postgresql.md</guid><pubDate>Sun, 06 Jul 2025 15:09:54 GMT</pubDate></item><item><title><![CDATA[Sqlite]]></title><description><![CDATA[ 
 <br>한 개의 파일에 데이터베이스를 저장하는 구조다.<br>
네트워크를 통해 접속하지 않는다.<br>
어쩌면 다른 데이터베이스 보다 빠를 수도 있다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\SqlLite\Sqlite.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/SqlLite/Sqlite.md</guid><pubDate>Fri, 20 Jun 2025 08:31:57 GMT</pubDate></item><item><title><![CDATA[개념]]></title><description><![CDATA[ 
 <br><br>relation data model에 기반하여 구조화된 database를 말한다.<br>
relational database는 여러개의 relations로 구성된다.<br><br>A집합과 B집합이 있을 때<br><br>A와 B의 조합 중 가능한 모든것을 Catesian product라고 하며 A X B로 표현한다.<br><br>Cartesian product의 부분 집합이다.<br><br>N개의 집합에 대한 Catesian Product의 부분 집합<br><br>cartesian product의 부분 집합<br>
튜플의 집합]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\관계형 데이터베이스\관계형 데이터베이스.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/관계형 데이터베이스/관계형 데이터베이스.md</guid><pubDate>Wed, 02 Jul 2025 08:05:07 GMT</pubDate></item><item><title><![CDATA[MongoDB]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\비관계형 데이터베이스\MongoDB\MongoDB.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/비관계형 데이터베이스/MongoDB/MongoDB.md</guid><pubDate>Mon, 23 Jun 2025 01:31:42 GMT</pubDate></item><item><title><![CDATA[Redis]]></title><description><![CDATA[ 
 ]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\DBMS\비관계형 데이터베이스\Redis\Redis.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/DBMS/비관계형 데이터베이스/Redis/Redis.md</guid><pubDate>Mon, 23 Jun 2025 01:31:49 GMT</pubDate></item><item><title><![CDATA[재귀 쿼리]]></title><description><![CDATA[ 
 <br>with recursive EDG as (
	select ID, PARENT_ID, 1 as GEN
	from ECOLI_DATA
	where PARENT_ID is null
	
	union all
	
	select CD.ID, CD.PARENT_ID, EDG.GEN+1
    from EDG
    inner join ECOLI_DATA as CD
    on EDG.ID = CD.PARENT_ID
)
<br>이처럼 select 문 안에 select 문이 있는 방식이다.<br>
첫 select문은 처음으로 실행되는 SQL문이고 그 이후로 union all을 통해 뒤에 붙이는 방식이다.]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\SQL\DML\재귀 쿼리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/SQL/DML/재귀 쿼리.md</guid><pubDate>Mon, 23 Jun 2025 07:47:38 GMT</pubDate></item><item><title><![CDATA[SELECT]]></title><description><![CDATA[ 
 <br><br>explain을 앞에 넣어서 사용하면 검색을 어떻게 했는지 알 수 있다.<br><br>두 개의 테이블을 하나로 합친다.<br>
join과 다르게 수직적으로 커진다.<br><br>두 개의 테이블을 하나로 합친다.<br>
union과 다르게 수평적으로 커진다.<br><br>INSERT 안에 SELECT를 넣을 수 있다.<br>
예시)<br>INSERT INTO member (regDate, loginId, loginPw, name)
SELECT NOW(), UUID(), 'pw', '아무개'
form member;
<br><br>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\SQL\DML\DML.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/SQL/DML/DML.md</guid><pubDate>Fri, 20 Jun 2025 08:39:10 GMT</pubDate></item><item><title><![CDATA[GRANT]]></title><description><![CDATA[ 
 <br><br>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\SQL\DCL.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/SQL/DCL.md</guid><pubDate>Mon, 09 Jun 2025 03:20:37 GMT</pubDate></item><item><title><![CDATA[CREATE]]></title><description><![CDATA[ 
 <br><br>데이터 베이스나 테이블을 생성할 때 사용한다.<br>
예시)<br>create table article(
	title VARCHAR(100),
    `body` TEXT
);
<br><br>테이블의 구조를 변경할 때 사용한다.<br>
예시)<br>alter table article add column id int first;
<br><br>테이블을 없앨 때 사용한다.<br><br>테이블의 모든 데이터를 날리고 싶을 때 사용한다.<br><br><br><br>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\SQL\DDL.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/SQL/DDL.md</guid><pubDate>Mon, 23 Jun 2025 07:46:16 GMT</pubDate></item><item><title><![CDATA[<a data-href="DML" href="컴퓨터 공학/프로그램/데이터 베이스/SQL/DML/DML.html" class="internal-link" target="_self" rel="noopener nofollow">DML</a>]]></title><description><![CDATA[ 
 <br>아래로 이루어짐<br><br><br><br>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\SQL\SQL.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/SQL/SQL.md</guid><pubDate>Mon, 09 Jun 2025 03:21:22 GMT</pubDate></item><item><title><![CDATA[COMMIT]]></title><description><![CDATA[ 
 <br><br><br>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\SQL\TCL.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/SQL/TCL.md</guid><pubDate>Mon, 09 Jun 2025 03:20:51 GMT</pubDate></item><item><title><![CDATA[ORM]]></title><description><![CDATA[ 
 <br>Object Relational Mapping의 약자로<br>데이터베이스에 연결 시 <a data-href="SQL" href="컴퓨터 공학\프로그램\데이터 베이스\SQL\SQL.html" class="internal-link" target="_self" rel="noopener nofollow">SQL</a>이 아닌 어플리케이션 개발 언어로 데이터베이스에 접근하게 하는 툴<br>
<a data-tooltip-position="top" aria-label="https://jalynne-kim.medium.com/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B0%B1%EC%97%94%EB%93%9C-orm-object-relational-mapping-%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98-%ED%99%9C%EC%9A%A9%EB%B0%A9%EC%95%88-c43b69028957" rel="noopener nofollow" class="external-link" href="https://jalynne-kim.medium.com/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B0%B1%EC%97%94%EB%93%9C-orm-object-relational-mapping-%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%A2%85%EB%A5%98-%ED%99%9C%EC%9A%A9%EB%B0%A9%EC%95%88-c43b69028957" target="_blank">출처</a>]]></description><link>컴퓨터 공학\프로그램\데이터 베이스\ORM.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/데이터 베이스/ORM.md</guid><pubDate>Mon, 23 Jun 2025 01:26:30 GMT</pubDate></item><item><title><![CDATA[<a data-href="Git" href="컴퓨터 공학/프로그램/버전관리/Git/Git.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a>]]></title><description><![CDATA[ 
 <br><br><br>내 컴퓨터의 로컬 깃 히스토리를 서버에 올릴 수 있다.<br>
그럼 내 동료가 서버로 부터 코드를 가져올 수 있어서 협업이 가능하다.<br>
다른 곳에서도 가능하다<br>
Bitbucket이나 GitLab인데 유명하진 않음]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\깃, 깃허브 초기 개념.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/깃, 깃허브 초기 개념.md</guid><pubDate>Tue, 01 Jul 2025 08:11:02 GMT</pubDate></item><item><title><![CDATA[소스 코드 관리 정책]]></title><description><![CDATA[ 
 <br>상황에 맞는 브랜치 전략을 선택하면 됨<br><br>여러 개발자가 동시에 다양한 기능 개발<br>
최종적으로 안정적인 소프트웨어 배포 보장<br>Git workflow라고도 불림<br>Git-flow, GitHub-flow가 있음<br><br><br><br>장기간 프로젝트가 존재하고 핫픽스 등 유지보수 전략이 필요하면 GIT-flow<br>
아니면 GitHub-flow<br><br><br>코드 병합을 믿어라<br>
극단적인 브랜치 전략을 피해라<br>
가능하다면 브랜치 계층 구조를 단순화해라]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\브랜치 전략.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/브랜치 전략.md</guid><pubDate>Mon, 16 Jun 2025 08:13:21 GMT</pubDate></item><item><title><![CDATA[창시자 리누스 토발즈]]></title><description><![CDATA[ 
 <br><a data-href="VCS" href="컴퓨터 공학\프로그램\버전관리\VCS.html" class="internal-link" target="_self" rel="noopener nofollow">VCS</a> 기술이다.<br>
소스코드를 저장하기 위한 기술<br>
모든 파일의 변화를 기록한다.<br>여러가지 갈래로 나뉘어 질 수도 있고<br>
여러 갈래의 공통 파일을 동시에 수정할 수도 있다.<br>
누가 코드에서 실수를 했는지도 알 수 있다.<br><br>리누스 토발즈가 만들어 냈다.<br>
비트 키퍼가 너무 비싸서 Git을 만들어냈다.<br><br><br><br>Git이 추적하지 않아야 할 파일들을 지정하는 설정 파일<br>
폴더 및 파일들을 적으면 git commit할 때 대상으로 뜨지 않는다.<br>
따라서 git에 올라가면 안되는 파일들 예를 들어 api 키 파일, DB 계정 정보 같은 경우 포함시키지 않기 위해 사용한다.<br><br>브랜치 전략 설계 블로그 보면 좋을 듯<br>
생활코딩의 git 영상 보면 좋을듯]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Git.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Git.md</guid><pubDate>Mon, 16 Jun 2025 08:16:25 GMT</pubDate></item><item><title><![CDATA[로컬 저장소]]></title><description><![CDATA[ 
 <br>여기 적혀있는 기능은 <a data-href="Git 명령" href="컴퓨터 공학\프로그램\버전관리\Git\Git 명령.html" class="internal-link" target="_self" rel="noopener nofollow">Git 명령</a>을 통해 사용 가능<br><br>개인 컴퓨터에 존재하는 저장소<br>
원격 저장소 코드의 복제다.<br>
로컬 저장소의 코드를 원격 저장소로 올린다.<br><br>로컬 저장소가 바라보는 공유 저장소<br>
별도의 서버로 관리한다.<br><br>동기화 하지 않을 파일들이다.<br><br>동기화할 파일들을 말한다.<br><br>코드를 바라보는 시점<br>
이전 코드로 돌아갈 수 있다.<br><br>Repository에 존재하는 분기<br>
언제든 만들고 지우는 것이 가능하다.<br><br>만든 Branch를 병합한다.<br><br>순차적 커밋에 맞춰 병합함<br>
브랜치를 생성한 시점과 Merge 시점이 동일한 경우 사용<br><br>공통 Branch A를 바탕으로 Branch B 생성<br>
Branch A와 Branch B 각각 Commit 존재<br>
갈래로 나온 시점인 Branch A를 기준으로<br>
Branch A와 Branch B 변경 사항을 병합 시도<br><br>여러 commit을 하나로 만든다.<br><br>동일한 라인을 수정하는 경우 코드 충돌이 발생한다.<br>
대부분 Git이 해주지만 나머지는 <br><br>커밋 순서 재배열<br>
브랜치를 만들고 시간이 지나 다시 병합하려 하면 충돌이 발생할 수 있음<br>
그래서 브랜치를 만들고 시간이 지나 base 브랜치에 rebase를 하고나서<br>
merge를 하면 충돌이 발생하지 않음<br>
브랜치가 참조하는 Commit의 기준점을 변경하는거임<br><br><br>새로운 commit을 생성한다.<br>
특정 commit 변경사항을 취소하고 취소한 변경 사항을 반영하는 commit을 생성한다.<br><br>이전 commit 상태로 돌아가고 이후 commit은 제거된다.<br><br>파일을 변경하진 않고 이전 기록은 새로운 브랜치로 만든다.<br><br><br>브랜치 commit 일부를 HEAD로 바라보는 branch에 적용한다.<br>
자주 안쓰임<br><br>코드의 변경 사항을 commit하지 않고 임시 저장<br><br>Git Repository를 다른 Git Repository에 포함시키는 기능]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Git 기능.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Git 기능.md</guid><pubDate>Mon, 16 Jun 2025 06:21:50 GMT</pubDate></item><item><title><![CDATA[Working Directory]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="Git 명령 > git init" data-href="Git 명령#git init" href="컴퓨터 공학\프로그램\버전관리\Git\Git 명령.html#git_init" class="internal-link" target="_self" rel="noopener nofollow">git init</a> 명령어를 통해 세가지 영역이 만들어진다.<br><br>작업 환경에서 변경 사항 발생<br><br>변경사항을 스테이징 영역에 임시 저장 이때 스냅샷이 만들어진다.<br><br>순간을 포착하는 것을 의미한다.<br>
변경사항일 있을 경우는 변경된 파일을 새로 저장하고<br>
변경사항이 없을 경우는 이전 파일의 스냅샷을 참조한다.<br><br>커밋을 통해 로컬 저장소에 저장한다.]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Git 동작원리.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Git 동작원리.md</guid><pubDate>Tue, 01 Jul 2025 08:15:32 GMT</pubDate></item><item><title><![CDATA[Git 등장 배경]]></title><description><![CDATA[ 
 <br>혼자 개발할 경우 문제가 없음<br>
근데 여러명이서 같이 만들면 문제가 발생<br>서로 따로 만들다가 합칠 때 충돌이 발생할 가능성이 있다.<br>그래서 <a data-href="VCS" href="컴퓨터 공학\프로그램\버전관리\VCS.html" class="internal-link" target="_self" rel="noopener nofollow">VCS</a>를 만듬]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Git 등장 배경.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Git 등장 배경.md</guid><pubDate>Mon, 16 Jun 2025 05:11:38 GMT</pubDate></item><item><title><![CDATA[git init]]></title><description><![CDATA[ 
 <br><br>git init
<br><br>처음으로 원격 저장소에서 로컬 저장소로 불러올 때 사용함<br><br>원격 저장소로 코드 동기화<br><br>리포지토리 불러오는데 사용 가능<br>
최신화 하는데 사용함<br>
원격 저장소에 변경된 코드를 가져온다.<br><br>파일을 tracked로 전환한다.<br><br>파일을 untracked로 전환한다.<br><br>로컬에 원격 트래킹 저장소 갱신한다.<br>
로컬 코드에 변화를 주지 않는다.<br><br>코드 변경사항을 기록하는 단위<br>
여러 개의 파일에 여러 라인을 수정하더라도 하나로 묶을 수 있다.<br>
commit 단위마다 메세지 입력이 가능하다.<br><br>해당 커밋으로 이동한다.<br><br>Branch를 병합하는 명령어다.<br>git merge --squach
<br><br>브랜치가 참조하는 Commit 기준점을 변경하는 명령어<br><br>git의 히스토리를 확인 가능하다.<br><br>git remote add origin [url]
]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Git 명령.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Git 명령.md</guid><pubDate>Fri, 20 Jun 2025 08:30:24 GMT</pubDate></item><item><title><![CDATA[Git-flow 브랜치]]></title><description><![CDATA[ 
 <br><br><br>기능 개발 브랜치<br><br>개발 중인 코드가 모이는 곳<br><br>배포 준비 단계<br>
배포할 코드가 모이는 곳<br><br>배포된 코드 이슈를 긴급 대응할 때 생성<br><br>고정 브랜치<br>
최신 배포 코드<br>
언제 배포하든 문제가 없어야 함<br><br>main -&gt; develop -&gt; feature -&gt; ... -&gt;feature -&gt; develop -&gt; develop(안한 feature들) -&gt; release -&gt; main<br><br>main -&gt; hotfix -&gt; hotfix -&gt; main<br><br>
<br>버저닝이 필요한
<br>정기 배포<br>
따라서 앱 애플리케이션에 적합
]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\GIT-flow.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/GIT-flow.md</guid><pubDate>Mon, 16 Jun 2025 07:58:29 GMT</pubDate></item><item><title><![CDATA[Untracked]]></title><description><![CDATA[ 
 <br>Untracked를 제외한 상태는 다 추적 중이다.<br><br><a data-href="Git" href="컴퓨터 공학\프로그램\버전관리\Git\Git.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a>에게 추적되지 않는다.<br>
<a data-tooltip-position="top" aria-label="Git 명령 > git add" data-href="Git 명령#git add" href="컴퓨터 공학\프로그램\버전관리\Git\Git 명령.html#git_add" class="internal-link" target="_self" rel="noopener nofollow">git add</a> 명령어를 통해 staged로 올릴 수 있다.<br><br>Git에게 추적되며 변경사항은 없는 상태다.<br>
이걸 수정하면 Modified 상태가 된다.<br><br>Git에게 추적되며 변경사항이 생긴 상태다.<br><br>Git 에게 추적되면 Staging Area에 스냅샷을 생성한다.<br>
commit을 통해 내부 저장소에 저장이 가능한데 그러면 Unmodified 상태가 된다.]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Git의 네가시 상태.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Git의 네가시 상태.md</guid><pubDate>Tue, 01 Jul 2025 08:21:13 GMT</pubDate></item><item><title><![CDATA[역사]]></title><description><![CDATA[ 
 <br><a data-href="Git" href="컴퓨터 공학\프로그램\버전관리\Git\Git.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a>을 기반으로 한 웹 호스팅 서비스<br><br>2008년 4월 서비스 시작<br>
CI/CD도 지원하게됨<br><br>공개 여부 설정 가능하고<br>
.gitignore 파일을 통해 git에서 특정 파일이나 디렉토리를 버전 관리에서 제외하는데<br>
이 파일도 자동적으로 넣어주는지 체크 가능<br><br>마크 다운 언어를 통해 프로젝트 개요, 설치 방법, 사용법, 기여 방법 등을 작성할 수 있다.<br><br>다른 사용자 repository에 내가 수정한 코드를 반영하도록 merge 요청<br>
Repository 개발하는 다른 동료에게 코드 리뷰 요청<br><br>코드 조각, 구성 파일, 메모 등을 빠르게 공유하니 위한 용도<br>
git repository와 같은 형태라 버전 관리가 가능하다.<br><br>IDE 내에서 chaGPT 기능을 쓸 수 있음<br>]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\GitHub.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/GitHub.md</guid><pubDate>Tue, 01 Jul 2025 08:11:02 GMT</pubDate></item><item><title><![CDATA[Github Actions]]></title><description><![CDATA[ 
 <br>코드 빌드 및 테스트<br>
배포 자동화<br>
정적 코드 분석<br>
태그 및 릴리즈 노트 자동 생성<br>
정기 작업 자동화<br>
보안 취약성 검사<br><br>수동/정기 실행<br>
브랜치 생성, 삭제<br>
push<br>
pull request<br>
Webhook<br><br>지속적 통함 Continuous Integration<br>
지속적 제공/배포 Continuous Delivery/Deployment<br>
소프트웨어 개발 라이프사이클 간소화<br>빌드 &amp; 테스트 자동화는 jenkins나 maven 사용<br>AWS 추천함<br><br>다른 개발자가 만들어 공개한 워크플로우 기능<br><br>별도 서버를 필요로 하지 않는다.<br><br>다른 사람이 만들어둔것 사용 가능<br><br>서버가 없는 스케쥴러를 만들 수 있음]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\Github Actions.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/Github Actions.md</guid><pubDate>Mon, 16 Jun 2025 06:51:26 GMT</pubDate></item><item><title><![CDATA[브랜치]]></title><description><![CDATA[ 
 <br>2011년 GitHub CIO인 Scott Chacon의 제안<br>워크플로우를 단순화 해야한다.<br><br><br><br><br>main -&gt; feature -&gt; feature -&gt; main<br>
필요하면 feature 브랜치에서 feature 브랜치를 만들면 된다.<br><br>main 브랜치는 언제든지 배포 가능<br>
모든 브랜치는 main 브랜치에서 파생<br>
local 브랜치에서 commit 정기적으로 remote 브랜치로 push<br>
도움이 필요하거나 코드 병합할 준비되면 pull request 생성<br>
다른 사람이 변경된 코드를 승인하면 main 브랜치에 merge<br>이는 상시 배포에 적합]]></description><link>컴퓨터 공학\프로그램\버전관리\Git\GitHub-flow.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/Git/GitHub-flow.md</guid><pubDate>Mon, 16 Jun 2025 08:05:11 GMT</pubDate></item><item><title><![CDATA[로컬 버전 관리]]></title><description><![CDATA[ 
 <br><br><br>최초의 파일 기반 버전 관리 시스템<br>
파일의 변경된 부분에 대해서 저장한다.<br>로컬에 저장하기 때문에 공유가 힘들고<br>
로컬 컴퓨터가 고장나면 모두 다 잃는다.<br><br><br>중앙 집중식 버전 관리 시스템<br>
중앙 서버에서 모든 버전 기록을 관리하는 방식이다.<br>서버가 다운되면 모든 작업이 중단된다.<br><br><br>분산 버전 관리 시스템<br>
중앙 서버 없이도 버전 관리할 수 있는 방식이다.<br>
RCS와 CVCS의 장점을 합했다.<br><br><a data-tooltip-position="top" aria-label="Git > 창시자 리누스 토발즈" data-href="Git#창시자 리누스 토발즈" href="컴퓨터 공학\프로그램\버전관리\Git\Git.html#창시자_리누스_토발즈" class="internal-link" target="_self" rel="noopener nofollow">GIT</a>을 만들었다.]]></description><link>컴퓨터 공학\프로그램\버전관리\버전 관리 역사.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/버전 관리 역사.md</guid><pubDate>Tue, 01 Jul 2025 08:11:02 GMT</pubDate></item><item><title><![CDATA[Version Control System]]></title><description><![CDATA[ 
 <br><br>문서나 설계도 또는 소스 코드 등 다양한 파일의 변경 사항을 관리하는 소프트웨어<br><br><br>
<br>히스토리 관리

<br>모든 변경사항 기록
<br>누가, 언제 무엇을 변경했는지 추적


<br>버전관리

<br>과거 버전과 비교함


<br><br>
<br>병렬작업

<br>여러 개발자가 동시에 동일한 프로젝트를 작업해도 각 변경사항이 독립적으로 관리


<br>분기와 병합 그리고 충돌 해결

<br>충돌 발생시 쉽게 해결 가능한 기능


<br><br>
<br>데이터 보호

<br>코드 변경이력을 중앙 저장소에 저장해 데이터 유실을 방지한다.


<br>복제

<br>중앙 저장소 데이터를 로컬로 복제
<br>원본 데이터가 손상되더라도 복구 가능


<br><br>
<br>태그 및 릴리즈 관리

<br>특정 시점 코드를 태그로 관리
<br>릴리즈 버전을 손쉽게 관리


<br>자동화 도구 통합

<br>CI/CD 시스템과 통합


<br><br>
<br>권한 관리

<br>누가 어떤 파일을 수정할지 권한 설정 가능


<br>감사 추적

<br>변경 이력을 추적하여 보안 감사에 활용


<br><br>
<br>BitKeeper
<br>Subversion, SVN
<br><a data-href="Git" href="컴퓨터 공학\프로그램\버전관리\Git\Git.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a>
]]></description><link>컴퓨터 공학\프로그램\버전관리\VCS.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/버전관리/VCS.md</guid><pubDate>Tue, 01 Jul 2025 08:11:02 GMT</pubDate></item><item><title><![CDATA[IntelliJ 설정]]></title><description><![CDATA[ 
 <br>코딩용 폰트 D2Coding]]></description><link>컴퓨터 공학\프로그램\IDE\JetBrains\IntelliJ 설정.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/IDE/JetBrains/IntelliJ 설정.md</guid><pubDate>Tue, 27 May 2025 07:54:29 GMT</pubDate></item><item><title><![CDATA[Ultimate]]></title><description><![CDATA[ 
 <br><br>유로 버전 IDE 모든 기능 사용가능<br><br>무료 버전 IDE<br><br>버그 리포팅을 위한 무료 버전<br><br>Toolbox를 통해 IDE 다운그레이드나 업데이트를 할 수 있다.<br><br>
<br>rainbow bracket
<br>rainbow indent
<br>code glance pro
<br>GitToolBox
<br><br>
<br>전체 검색 : shift + shift
<br>코드 검색 :

<br>mac : shift + command + F
<br>windows: ctrl + shift + F
<br>검색에서 제외하기

<br>디렉토리 마크해서 제외하면 됨




<br>코드 자동 정렬

<br>mac : command + option + L
<br>windows : ctrl + alt + L


<br>import 정리

<br>mac : control + option + O
<br>windows : ctrl + alt + O


<br>Commit

<br>mac : command + K
<br>windows : ctrl + K


<br>Push

<br>mac : shift + command + K
<br>windows : shift + ctrl + K


<br><br>코드 라인 별로 언제, 무슨 이유로 수정되었는지 확인 가능<br><br>Git Stach에 대응하는 IDE 기능<br>
commit 하지 않고 코드 임시 저장]]></description><link>컴퓨터 공학\프로그램\IDE\JetBrains\JetBrains IDE.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/IDE/JetBrains/JetBrains IDE.md</guid><pubDate>Wed, 02 Jul 2025 08:00:33 GMT</pubDate></item><item><title><![CDATA[Cursor]]></title><description><![CDATA[ 
 <br><a data-href="Visual Studio Code" href="컴퓨터 공학\프로그램\IDE\Visual Studio Code.html" class="internal-link" target="_self" rel="noopener nofollow">Visual Studio Code</a>에 <a data-href="인공지능" href="컴퓨터 공학\프로그래밍\알고리즘\인공지능\인공지능.html" class="internal-link" target="_self" rel="noopener nofollow">인공지능</a> 기능을 넣어서 만든 IDE다.]]></description><link>컴퓨터 공학\프로그램\IDE\Cursor.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/IDE/Cursor.md</guid><pubDate>Wed, 02 Jul 2025 07:56:14 GMT</pubDate></item><item><title><![CDATA[IDE]]></title><description><![CDATA[ 
 <br>Integrated Development Environment<br>
개발에 필요한 모든 과정을 한 프로그램 안에 처리하는 환경을 제공하는 프로그램이다.<br>
코드 작성, 편집, 테스트, 빌드, 배포 등을 한다.]]></description><link>컴퓨터 공학\프로그램\IDE\IDE.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/IDE/IDE.md</guid><pubDate>Fri, 06 Jun 2025 02:52:46 GMT</pubDate></item><item><title><![CDATA[Visual Studio]]></title><description><![CDATA[ 
 <br><a data-href="C" href="컴퓨터 공학\프로그래밍\언어\C 계열\C\C.html" class="internal-link" target="_self" rel="noopener nofollow">C</a>, <a data-href="C++" href="컴퓨터 공학\프로그래밍\언어\C 계열\C++\C++.html" class="internal-link" target="_self" rel="noopener nofollow">C++</a>, <a data-tooltip-position="top" aria-label="C-Sharp" data-href="C-Sharp" href="컴퓨터 공학\프로그래밍\언어\C 계열\C#\C-Sharp.html" class="internal-link" target="_self" rel="noopener nofollow">C#</a>을 개발 할 때 주로 쓰는 IDE다.<br>
윈도우 환경에서 개발할 때 사용하고<br>
무거운 IDE다.]]></description><link>컴퓨터 공학\프로그램\IDE\Visual Studio.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/IDE/Visual Studio.md</guid><pubDate>Wed, 02 Jul 2025 07:58:38 GMT</pubDate></item><item><title><![CDATA[Visual Studio Code]]></title><description><![CDATA[ 
 <br><a data-href="Visual Studio" href="컴퓨터 공학\프로그램\IDE\Visual Studio.html" class="internal-link" target="_self" rel="noopener nofollow">Visual Studio</a>가 너무 무거워서 경량화를 시킨 IDE다.<br>
여러가지 확장 프로그램이 존재해서 C 계열이 아니더라도 개발이 가능하다.]]></description><link>컴퓨터 공학\프로그램\IDE\Visual Studio Code.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/IDE/Visual Studio Code.md</guid><pubDate>Wed, 02 Jul 2025 08:00:01 GMT</pubDate></item><item><title><![CDATA[Postman]]></title><description><![CDATA[ 
 <br>웹 개발을 하면서 <a data-href="API" href="컴퓨터 공학\인터넷\web\back end\서버\API\API.html" class="internal-link" target="_self" rel="noopener nofollow">API</a> 테스트를 하고 싶을 때 사용하기 좋은 <a data-href="프로그램" href="컴퓨터 공학\운영체제\프로그램.html" class="internal-link" target="_self" rel="noopener nofollow">프로그램</a>이다.<br>
GET, POST, PUT, DELETE등 여러가지 메소드로 요청을 할 수 있다.]]></description><link>컴퓨터 공학\프로그램\Postman\Postman.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/Postman/Postman.md</guid><pubDate>Tue, 01 Jul 2025 08:17:35 GMT</pubDate></item><item><title><![CDATA[Postman TDD]]></title><description><![CDATA[ 
 <br>Postman을 둘러보다가 발견한 방법인데<br>TDD방식으로 테스트가 가능하다.<br>Request에서 Scripts로 들어가<br>Post-response 탭으로 들어가면 스크립트를 짤 수 있는데<br>pm.test("Response has required fields", function () {

    const responseData = pm.response.json();

    pm.expect(responseData).to.be.an('object').that.includes.all.keys('id', 'createDate', 'modifyDate', 'content');

});
<br>이 방식으로 작성하면 테스트가 가능하다.]]></description><link>컴퓨터 공학\프로그램\Postman\Postman TDD.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/Postman/Postman TDD.md</guid><pubDate>Thu, 26 Jun 2025 02:20:19 GMT</pubDate></item><item><title><![CDATA[FTP]]></title><description><![CDATA[ 
 <br>파일을 전송하기 위한 프로토콜<br>
TCP/IP 프로토콜을 사용한다.<br>
그러니 아마 <a data-href="TCP IP 소켓통신" href="컴퓨터 공학\인터넷\네트워크\소켓통신\TCP IP 소켓통신.html" class="internal-link" target="_self" rel="noopener nofollow">TCP IP 소켓통신</a>을 할 거임<br>보안적으로는 안전하지 않기에<br>
보안을 강화한 <a data-href="SFTP" href="컴퓨터 공학\프로그램\SSH\SFTP.html" class="internal-link" target="_self" rel="noopener nofollow">SFTP</a>가 있다.]]></description><link>컴퓨터 공학\프로그램\SSH\FTP.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/SSH/FTP.md</guid><pubDate>Mon, 23 Jun 2025 08:11:00 GMT</pubDate></item><item><title><![CDATA[출처]]></title><description><![CDATA[ 
 <br>기존 <a data-href="FTP" href="컴퓨터 공학\프로그램\SSH\FTP.html" class="internal-link" target="_self" rel="noopener nofollow">FTP</a>의 방식은 보안적인 취약점이 있기에 중요한 파일을 전송하기는 힘들다.<br>
파일 전송 시 <a data-href="SSH" href="컴퓨터 공학\프로그램\SSH\SSH.html" class="internal-link" target="_self" rel="noopener nofollow">SSH</a> 방식을 사용해서<br><br><a data-tooltip-position="top" aria-label="https://parkadd.tistory.com/129" rel="noopener nofollow" class="external-link" href="https://parkadd.tistory.com/129" target="_blank">링크</a>]]></description><link>컴퓨터 공학\프로그램\SSH\SFTP.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/SSH/SFTP.md</guid><pubDate>Mon, 23 Jun 2025 08:06:52 GMT</pubDate></item><item><title><![CDATA[주요기능]]></title><description><![CDATA[ 
 <br>Secure SHell은 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜이다.<br>
강력한 인증 방법을 사용하고<br>
기본적으로 22번 포트를 사용한다.<br>
암호화 기법을 사용하기에 통신이 노출되어도 이해할 수 없는 암호화된 문자로 보인다.<br><br>보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, <a data-href="FTP" href="컴퓨터 공학\프로그램\SSH\FTP.html" class="internal-link" target="_self" rel="noopener nofollow">FTP</a> 등을 안전하게 제공한다.]]></description><link>컴퓨터 공학\프로그램\SSH\SSH.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/SSH/SSH.md</guid><pubDate>Mon, 23 Jun 2025 08:09:49 GMT</pubDate></item><item><title><![CDATA[웹 브라우저]]></title><description><![CDATA[ 
 <br>웹 서버에게 HTTP로 요청을 보내고 받은 요청을 화면에 나타내 주는 프로그램이다.]]></description><link>컴퓨터 공학\프로그램\웹 브라우저.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/웹 브라우저.md</guid><pubDate>Tue, 17 Jun 2025 15:04:15 GMT</pubDate></item><item><title><![CDATA[이동]]></title><description><![CDATA[ 
 <br><br>과거에는 화살표가 키보드에 없었기에<br>
hjkl를 통해 이동했다<br><br>CLI 텍스트 편집기로 편집하려면 i를 눌러 편집을 시작한다.<br>
그리고 esc를 눌러 편집을 종료하고<br>
:wq를 통해 저장하고 종료하고<br>
:q!를 통해 저장하지 않고 종료가 가능하다.<br>
:q를 통해 아무것도 수정하지 않은 경우 종료할 수 있다. 수정을 조금이라도 한 경우 작동하지 않는다.]]></description><link>컴퓨터 공학\프로그램\Vim.html</link><guid isPermaLink="false">컴퓨터 공학/프로그램/Vim.md</guid><pubDate>Tue, 01 Jul 2025 00:38:45 GMT</pubDate></item><item><title><![CDATA[LiveData]]></title><description><![CDATA[ 
 <br><br>데이터가 변경될 때 옵저버에게 업데이트를 전달한다.<br>갔다 오면 다시 활성화가 되어 무한 반복한다.<br><br>이벤트를 한 번만 전파하고 소모되도록 LiveData와 결합한 이벤트 래퍼다.<br><br>View 모델과 LiveData를 같이 사용하는 것은 안좋다.<br><br>ViewModel에서 안드로이드 프레임워크의 종속성을 벗어나기 위해 Channel을 도입해 문제를 개선할 수 있다.<br>Android 프레임워크와 독립적으로 동작하고 코루틴 기반의 비동기 데이터 전송을 지원해 테스트 시 Android의 의존성을 줄이고, 모듈화 및 유지보수성을 향상시킨다.<br><br>Lifecycle 상태에 맞춰 코루틴을 자동으로 관리하는 기능을 제공한다.<br>
지정된 Lifecycle.State에 도달하면 코루틴을 실행하고, 해당 상태에서 벗어나면 자동으로 중단한다. 이러한 자동관리를 통해 개발자는 코루틴의 시작과 중지를 일일히 처리할 필요가 없다.<br><br>코루틴 기반의 Flow를 사용하여 여러 구독자에게 데이터를 동시에 전달할 수 있다.<br>
브로드캐스트 방식으로 여러 구독자가 동일한 데이터를 받아 처리할 수 있다.<br><br>이벤트가 발생했을 때 이를 캐시한 후, 해당 이벤트가 소비되었는지 여부에 따라 새로운 옵저버가 구독할 때 이벤트를 전달할지를 결정하는 구조다.<br><br>이벤트가 발생했을 때 이를 캐시하고, 이벤트의 소비 여부에 따라 새로 구독하는 옵저버에게 이벤트를 전파할지 여부를 결정하는 구조다.<br><br>각 이벤트와 해당 이벤트를 소비하는 옵저버의 상태를 관리하는데 사용한다.<br><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=J0ZeznIBjF0" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=J0ZeznIBjF0" target="_blank">링크</a>]]></description><link>컴퓨터 공학\UI\UI 이벤트 처리.html</link><guid isPermaLink="false">컴퓨터 공학/UI/UI 이벤트 처리.md</guid><pubDate>Thu, 03 Jul 2025 08:29:15 GMT</pubDate></item><item><title><![CDATA[UI]]></title><description><![CDATA[ 
 <br><br>제품이나 서비스를 이용할 때 직접 보고 상호작용하는 것<br><br>제품이나 서비스를 이용하면서 느끼는 감정과 경험<br><br>
잘 짜인 UI는 UX를 개선해서 서비스를 계속 이용하고 싶게 한다.
<br>
수많은 선택지는 사용자에게 자유를 주지만,<br>
최선의 선택을 해야 한다는 압박감에<br>
선택하지 않는다는 선택을 하기도 한다.
<br>
사용자는 상호작용 피드백이 직관적이고 빠를수록 더 큰 만족감을 느낀다.
]]></description><link>컴퓨터 공학\UI\UI, UX.html</link><guid isPermaLink="false">컴퓨터 공학/UI/UI, UX.md</guid><pubDate>Thu, 03 Jul 2025 07:49:39 GMT</pubDate></item><item><title><![CDATA[주의]]></title><description><![CDATA[ 
 <br><br>해당 내용은 제가 알고있는 지식을 상기시키기 위한 용도로 제작 되었습니다.<br>따라서 최적화된 데이터만 넣기도 해서 설명이 생략되어있을 수도 있습니다.]]></description><link>readme.html</link><guid isPermaLink="false">readme.md</guid><pubDate>Sat, 21 Jun 2025 13:17:22 GMT</pubDate></item></channel></rss>